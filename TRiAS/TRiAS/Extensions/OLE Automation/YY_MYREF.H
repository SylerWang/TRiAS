
//////////////////////////////////////////////////////////////////////////////
//
//  FILENAME:          yy_myref.h
//
//  FILE DESCRIPTION:  Header file with union declarations
//
//  Input file:        clause.yxx
//  Options:           -no_ast_dump -debug -table readable -line -no_far
//                     -microsoft_precompiled_header precomp.hxx
//  Include Paths:     current directory
//
//  Automatically generated by Yacc++ Revision 2.1 (96 July 12)
//  on Thu Nov 27 23:28:41 1997
//
//////////////////////////////////////////////////////////////////////////////

#include "yy_ast.h"
#include "yy_err.h"
#include "yy_sym.h"

/////////////////////////////////////////////////////////////////////////////
//
//  POINTER TYPE DECLARATIONS:
//
//  yy_ref_ptr          is a typedef which defines a pointer to an object on
//                      the parser stack.
//
/////////////////////////////////////////////////////////////////////////////

typedef class yy_export yy_ref_obj            *yy_ref_ptr;

/////////////////////////////////////////////////////////////////////////////
//
//  AST CLASS DERIVATION:
//
//  yxx -no_ast_dump      derive from yy_ast_nodump_obj
//
/////////////////////////////////////////////////////////////////////////////

#ifndef yy_ast_obj_decl_
#define yy_ast_obj_decl_ 1
    class yy_export yy_ast_obj : public yy_ast_nodump_obj {};
#endif /* yy_ast_obj_decl_ */

#ifndef clause_psr_gbl
#define clause_psr_gbl 1

typedef class INTEGER			*integer_ptr;
typedef class STRING_CONSTANT	*string_ptr;
typedef class clause_cmd_obj	*clause_cmd_ptr;
#endif /* clause_psr_gbl */

/////////////////////////////////////////////////////////////////////////////
//
//  CLASS:  yy_ref_obj
//
//  The yy_ref_obj is a class which provides the reference objects which can
//  be associated with tokens, keywords, or parser non-terminals.  Objects of
//  this class can be stored in the parser stack.
//
//  CONFIGURATION CONSTANTS:
//
//  yy_discard_type_    is the token type number reserved for all discarded
//                      tokens.
//
//  PUBLIC FUNCTIONS:
//
//  yy_ref_obj()        constructors for a reference object.
//
//  ~yy_ref_obj()       destructor for a reference object.
//
//  INTERNAL STATE:
//
//  yy_type             is the lexer (token or keyword) or parser 
//                      (non-terminal) type represented by this object.
//
//  yy_int              is the union member which hold integer values.
//
//  yy_ptr              is the union member which hold pointer values.
//
/////////////////////////////////////////////////////////////////////////////

#ifndef yy_decl_union
#define yy_decl_union 1
typedef union yy_export {
    int         yy_int;
    yy_void_ptr    yy_ptr;

	integer_ptr as_integer_ptr;	
	string_ptr as_string_ptr;
	clause_cmd_ptr as_clause_ptr;
} yy_union;

class yy_export yy_ref_obj {

 public:

    enum yy_ref_discard_enum {
        yy_discard_type_ = -3
        };

    inline yy_ref_obj(); 

    inline yy_ref_obj(yy_union yy_new_union); 

    inline yy_ref_obj(int yy_new_type, yy_union yy_new_union);

    inline yy_ref_obj(int yy_new_int);

    inline yy_ref_obj(int yy_new_type, int yy_new_int); 

    inline yy_ref_obj(yy_void_ptr yy_new_ptr); 

    inline yy_ref_obj(int yy_new_type, yy_void_ptr yy_new_ptr); 

    inline yy_ref_obj(yy_ast_ptr yy_new_ptr);

    inline yy_ref_obj(int yy_new_type, yy_ast_ptr yy_new_ptr);

    inline yy_ref_obj(yy_sym_ptr yy_new_ptr); 

    inline yy_ref_obj(int yy_new_type, yy_sym_ptr yy_new_ptr); 

    inline yy_ref_obj(const yy_ref_obj &yy_old_ref); 

    inline ~yy_ref_obj();

    inline yy_ref_obj &operator=(const yy_ref_obj &yy_old_ref);

    inline operator yy_union();

    inline operator int();

    inline operator yy_void_ptr();

    inline operator yy_ast_ptr();

    inline operator yy_sym_ptr();

    inline int &yy_type();

    inline int &yy_type(int yy_new_type);

    int                 yy_this_type;

    union {
        yy_union        yy_this_union;
        int             yy_int;
        yy_void_ptr     yy_ptr;

	integer_ptr as_integer_ptr;	
	string_ptr as_string_ptr;
	clause_cmd_ptr as_clause_ptr;
        };  // nested anonymous union    

    };  // yy_ref_obj


//////////////////////////////////////////////////////////////////////////////
//
//  INLINE FUNCTIONS:
//
//  These are the INLINE functions for the ref object, defined above.
//
//////////////////////////////////////////////////////////////////////////////
    
inline yy_ref_obj::yy_ref_obj(): 
        yy_this_type(yy_discard_type_)
    {
        yy_int = 0; 
    }

inline yy_ref_obj::yy_ref_obj(yy_union yy_new_union): 
        yy_this_type(yy_discard_type_)
    {
        yy_this_union = yy_new_union;
    }

inline yy_ref_obj::yy_ref_obj(int yy_new_type, yy_union yy_new_union): 
        yy_this_type(yy_new_type)
    {
        yy_this_union = yy_new_union;
    }

inline yy_ref_obj::yy_ref_obj(int yy_new_int): 
        yy_this_type(yy_discard_type_)
    {
        yy_int = yy_new_int;
    }

inline yy_ref_obj::yy_ref_obj(int yy_new_type, int yy_new_int): 
        yy_this_type(yy_new_type)
    {
        yy_int = yy_new_int;
    }

inline yy_ref_obj::yy_ref_obj(yy_void_ptr yy_new_ptr): 
        yy_this_type(yy_discard_type_)
    {
        yy_ptr = yy_new_ptr;
    }

inline yy_ref_obj::yy_ref_obj(int yy_new_type, yy_void_ptr yy_new_ptr): 
        yy_this_type(yy_new_type)
    {
        yy_ptr = yy_new_ptr;
    }

inline yy_ref_obj::yy_ref_obj(yy_ast_ptr yy_new_ptr): 
        yy_this_type(yy_discard_type_)
    {
        yy_ptr = yy_void_ptr(yy_new_ptr);
    }

inline yy_ref_obj::yy_ref_obj(int yy_new_type, yy_ast_ptr yy_new_ptr): 
        yy_this_type(yy_new_type)
    {
        yy_ptr = yy_void_ptr(yy_new_ptr);
    }

inline yy_ref_obj::yy_ref_obj(yy_sym_ptr yy_new_ptr): 
        yy_this_type(yy_discard_type_)
    {
        yy_ptr = yy_void_ptr(yy_new_ptr);
    }

inline yy_ref_obj::yy_ref_obj(int yy_new_type, yy_sym_ptr yy_new_ptr): 
        yy_this_type(yy_new_type)
    {
        yy_ptr = yy_void_ptr(yy_new_ptr);
    }

inline yy_ref_obj::yy_ref_obj(const yy_ref_obj &yy_old_ref): 
        yy_this_type(yy_old_ref.yy_this_type)
    {
        yy_this_union = yy_old_ref.yy_this_union;
    }

inline yy_ref_obj::~yy_ref_obj() 
    {}

inline yy_ref_obj &yy_ref_obj::operator=(const yy_ref_obj &yy_old_ref)
    {
        if (this != &yy_old_ref) {
            if (yy_old_ref.yy_this_type != yy_discard_type_) {
                yy_this_type = yy_old_ref.yy_this_type;
                }
            yy_this_union = yy_old_ref.yy_this_union;
            }
        return(*this);
    }

inline yy_ref_obj::operator yy_union() 
    { return(yy_this_union); }

inline yy_ref_obj::operator int() 
    { return(yy_int); }

inline yy_ref_obj::operator yy_void_ptr() 
    { return(yy_ptr); }

inline yy_ref_obj::operator yy_ast_ptr() 
    { return(yy_ast_ptr(yy_ptr)); }

inline yy_ref_obj::operator yy_sym_ptr() 
    { return(yy_sym_ptr(yy_ptr)); }

inline int &yy_ref_obj::yy_type() 
    { return(yy_this_type); }

inline int &yy_ref_obj::yy_type(int yy_new_type) 
    { return(yy_this_type = yy_new_type); }

#endif /* yy_decl_union */
