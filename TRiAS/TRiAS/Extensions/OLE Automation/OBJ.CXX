// Eine Objekt (Controlling Unknown) ------------------------------------
// File: OBJ.CXX

#include "precomp.hxx"

#include <dirisole.h>
#include <objcontx.hxx>

#include "Strings.h"
#include "obj.hxx"		// CGeoObject
#include "ftobtree.hxx"

#if defined(_DEBUG) && defined(WIN32)
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif // _DEBUG

// Anzahl der Pixel/mm in beiden Koordinatenrichtungen für dieses Fenster -----
static SIZE GetDotsPerMM (HDC hDC);
static POINT BSKoordinaten (KoOrd XD, KoOrd YD, bool bKipp);

DefineSmartInterface2(_DGeoClass, IID_DGeoClass);

///////////////////////////////////////////////////////////////////////////////
// zugehörige CriticalSection
//CComGlobalsThreadModel::AutoCriticalSection CGeoObject::m_cs;

///////////////////////////////////////////////////////////////////////////////
// Das eigentliche Object 
CGeoObject::CGeoObject (void)
	: m_fValid(false)
{
	CONSTRUCT_TRACE(CGeoObject);
	
	m_pUnk = NULL;
	m_pApp = NULL;
	m_pDoc = NULL;

	m_pFeatObjTree = NULL;
		
	m_lONr = INVALID_ONR;
	m_pName = NULL;
}


bool CGeoObject::FInit (
	LPUNKNOWN pUnk, CTriasApp *pApp, CGeoDoc *pDoc, 
	GEOOBJECTMODE rgMode, LONG lONr, VARIANT *pvClass)
{
	if (pUnk == NULL || pApp == NULL || pDoc == NULL) return false;

	m_lONr = lONr;
		
// create object, if applicable
	switch (rgMode) {
	case GEOOBJECTMODE_Get:			// TODO: test, if exists object
	case GEOOBJECTMODE_Replace:	
		if (lONr == INVALID_ONR) return false;
		{
		ErrInstall EI (EC_INVADDR);
		ErrInstall EI1 (EC_DELRECORD);
		
			if (DEX_GetObjIdent (lONr) == INVALID_IDENT)
				return false;
		}
		break;
		
	case GEOOBJECTMODE_Add:
		if (m_lONr != INVALID_ONR) return false;  
		{
		ULONG lIdent = INVALID_IDENT;
		HPROJECT hPrCtx = pDoc -> GetCtxDataSource();

			if (NULL != pvClass) {
				if (SUCCEEDED(VariantChangeType (pvClass, pvClass, 0, VT_DISPATCH))) {
				// Pointer auf GeoClass-Objekt gegeben
					COM_TRY {
						W_DGeoClass(V_DISPATCH(pvClass)) -> get_Code ((LONG *)&lIdent);
					} COM_CATCH_IGNORE;
				} else if (SUCCEEDED(VariantChangeType (pvClass, pvClass, 0, VT_I4))) {
				// Identifikator selbst gegeben
					lIdent = V_I4(pvClass);
				}

			// ggf. Datenquelle von der Objektklasse holen
				if (HACTCONNECTION == hPrCtx && INVALID_IDENT != lIdent)
					hPrCtx = DEX_GetObjectsProject(lIdent);
			}

			if (INVALID_ONR != lONr && HACTCONNECTION == hPrCtx)
				hPrCtx = DEX_GetObjectProject(lONr);

			ASSERT(HACTCONNECTION != hPrCtx);

		CNotifyWrapper WrapNotif;
		OBJCREATE OCr;
		
			INITSTRUCT (OCr, OBJCREATE);
			OCr.lONr = INVALID_ONR;		// new object (generated by TRiAS)
			OCr.lIdent = lIdent;		// evtl. unknown class (generated by TRiAS)
			OCr.iObjTyp = OGUnknown;	// unknown Type
			OCr.iFlags = OGNewObject;
			if (!DEX_ModObjGeometrieEx (hPrCtx, OCr))
				return false;
				
			m_lONr = OCr.lONr;
		}
		break;
		
	case GEOOBJECTMODE_Remove:			// ne Tut
		return false;

	default:
		return false;
	}
		
// parent
	m_pUnk = pUnk;
//	ADDREF (m_pUnk);
	
// Applikation festhalten
	m_pApp = pApp;
//	ADDREF_CAST(_IApplication, m_pApp);
	
// Document festhalten
	m_pDoc = pDoc;
//	ADDREF_CAST(_IDocument, m_pDoc);
	
// init GeoFeatures Tree 
	m_pFeatObjTree = CFeatObjTree::CreateInstance (m_pApp, m_pDoc, this);
	if (m_pFeatObjTree == NULL) return false;

	return true;
}

bool CGeoObject::FInit (
	LPUNKNOWN pUnk, CTriasApp *pApp, CGeoDoc *pDoc,
	GEOOBJECTMODE rgMode, LPCSTR bName, VARIANT *pvClass)
{
	if (pUnk == NULL || pApp == NULL || pDoc == NULL) return false;
	
	if (!SetName (bName, false, true))		// copy Object Name
		return false;
	
HPROJECT hPrCtx = pDoc -> GetCtxDataSource();

	if (HACTCONNECTION == hPrCtx)
		hPrCtx = DEX_GetDataSourceHandle();

	ASSERT(HACTCONNECTION != hPrCtx);
	switch (rgMode) {
	case GEOOBJECTMODE_Get:
	case GEOOBJECTMODE_Replace:
		m_lONr = DEX_GetONrFromObjName (bName);
		if (m_lONr == INVALID_ONR) return false;
		break;
		
	case GEOOBJECTMODE_Add:
		{
		ULONG lIdent = INVALID_IDENT;

			if (NULL != pvClass) {
				if (SUCCEEDED(VariantChangeType (pvClass, pvClass, 0, VT_DISPATCH))) {
				// Pointer auf GeoClass-Objekt gegeben
					COM_TRY {
						W_DGeoClass(V_DISPATCH(pvClass)) -> get_Code ((LONG *)&lIdent);
					} COM_CATCH_IGNORE;
				} else if (SUCCEEDED(VariantChangeType (pvClass, pvClass, 0, VT_I4))) {
				// Identifikator selbst gegeben
					lIdent = V_I4(pvClass);
				}
			}

		CNotifyWrapper WrapNotif;
		OBJCREATE OCr;

			INITSTRUCT (OCr, OBJCREATE);
			OCr.lONr = INVALID_ONR;		// new object (generated by TRiAS)
			OCr.lIdent = lIdent;		// evtl. unknown class (generated by TRiAS)
			OCr.iObjTyp = OGUnknown;	// unknown Type
			OCr.iFlags = OGNewObject;
			if (!DEX_ModObjGeometrieEx (hPrCtx, OCr))
				return false;
				
			m_lONr = OCr.lONr;
			if (m_lONr == INVALID_ONR) return false;
			
			if (!SetName (bName, true, true)) return false;
		}
		break;
		
	case GEOOBJECTMODE_Remove:			// ne Tut
		return false;

	default:
		return false;
	}

// parent
	m_pUnk = pUnk;
//	ADDREF (m_pUnk);
	
// Applikation festhalten
	m_pApp = pApp;
//	ADDREF_CAST(_IApplication, m_pApp);
	
// Document festhalten
	m_pDoc = pDoc;
//	ADDREF_CAST(_IDocument, m_pDoc);
	
// init GeoFeatures Tree 
	m_pFeatObjTree = CFeatObjTree::CreateInstance (m_pApp, m_pDoc, this);
	if (m_pFeatObjTree == NULL) return false;

	return true;
}


CGeoObject::~CGeoObject (void)
{
	DESTRUCT_TRACE(CGeoObject);
	
//	RELEASE (m_pUnk);	// Parent wieder loslassen
//	RELEASE_CAST(_IApplication, m_pApp);	// Applikation wieder loslassen
//	RELEASE_CAST(_IDocument, m_pDoc);		// Document wieder loslassen
	
	DELETE_OBJ(m_pFeatObjTree);
	DELETE_OBJ(m_pName);
}


CGeoObject *CGeoObject::CreateInstance (
	LPUNKNOWN pUnk, CTriasApp *pApp, CGeoDoc *pDoc,
	LONG lONr, GEOOBJECTMODE rgMode, VARIANT *pvClass)
{
CComObject<CGeoObject> *pGeoObject = NULL;

	try {
	// Create an instance of CGeoObject.  Exit if an error occurs.
	HRESULT hr = CComObject<CGeoObject>::CreateInstance (&pGeoObject);

		if (FAILED(hr)) _com_issue_error(hr);
		if (!pGeoObject -> FInit (pUnk, pApp, pDoc, rgMode, lONr, pvClass)) 
			_com_issue_error(E_FAIL);

		pGeoObject -> AddRef();	// fertig initialisiert

	} catch (_com_error&) {
		DELETE_OBJ (pGeoObject);
		return NULL;
	}
	
// If execution has reached this point, then no errors have occurred.
	pGeoObject -> Validate();
	return pGeoObject;
}


CGeoObject *CGeoObject::CreateInstance (
	LPUNKNOWN pUnk, CTriasApp *pApp, CGeoDoc *pDoc,
	LPCSTR bName, GEOOBJECTMODE rgMode, VARIANT *pvClass)
{
CComObject<CGeoObject> *pGeoObject = NULL;

	try {
	// Create an instance of CGeoObject.  Exit if an error occurs.
	HRESULT hr = CComObject<CGeoObject>::CreateInstance (&pGeoObject);

		if (FAILED(hr)) _com_issue_error(hr);
		if (!pGeoObject -> FInit (pUnk, pApp, pDoc, rgMode, bName, pvClass)) 
			_com_issue_error(E_FAIL);

		pGeoObject -> AddRef();	// fertig initialisiert

	} catch (_com_error&) {
		DELETE_OBJ (pGeoObject);
		return NULL;
	}
	
// If execution has reached this point, then no errors have occurred.
	pGeoObject -> Validate();
	return pGeoObject;
}

// Diverse ZugriffsFunktionen -------------------------------------------------
const char *CGeoObject::GetName (void)
{
	if (!m_fValid) return NULL;

	if (NULL == m_pName) { 		// noch nicht eingelesen
	// erstmaliges einlesen des Objektnamens
	OBJECTFEATURE OF;
	char *pBuffer = NULL;

		memset (&OF, '\0', sizeof(OBJECTFEATURE));
		OF.m_dwSize = sizeof(OBJECTFEATURE);
		OF.m_lONr = GetValue();
		if (!DEX_GetObjectName(OF))	// Länge abfragen
			return g_cbNil;			// kein Objektname gegeben
	
		ATLTRY(pBuffer = new char [OF.m_iLen+2]);
		if (pBuffer != NULL) {
			OF.m_pMText = pBuffer;
			OF.m_iLen = OF.m_iLen+1;
			if (DEX_GetObjectName (OF)) 
				m_pName = pBuffer;
			else 
				delete [] pBuffer;
		}
	}	
	return (NULL != m_pName) ? m_pName : g_cbNil;
}


// Setzen/löschen eines neuen KurzTextes --------------------------------------
bool CGeoObject::SetName (const char *pName, bool fCreate, bool fIgnoreValid)
{
	if (!fIgnoreValid && !m_fValid) return false;

// als erstes alten KurzText freigeben
	DELETE_OBJ(m_pName);
	if (fCreate) {
	// write to TRiAS
	OBJECTFEATURE OF;
		
		memset (&OF, '\0', sizeof(OBJECTFEATURE));
		OF.m_dwSize = sizeof(OBJECTFEATURE);
		OF.m_lONr = fIgnoreValid ? m_lONr : GetValue();
		OF.m_pMText = (char *) pName;
		OF.m_iLen = pName ? strlen(pName) : 0;
	
        if (DEX_ModObjectName (OF) != EC_OKAY)
        	return false;
	}
	        
// neuen KurzText kopieren
	if (pName) {
		m_pName = new char [strlen(pName)+1];
		if (m_pName) strcpy (m_pName, pName);
	}
	return (NULL != m_pName) ? true : false;
}

// ClassSpecificMembers -------------------------------------------------------
ULONG CGeoObject::GetObjIdent (void)
{
	if (!m_fValid) 
		return INVALID_IDENT;

	return DEX_GetObjIdent (m_lONr);
}

ULONG CGeoObject::GetObjIdentEx (void)
{
	if (!m_fValid) 
		return INVALID_IDENT;

	return DEX_GetObjIdentEx (m_lONr);
}

short CGeoObject::GetObjectType (void)
{
	if (!m_fValid) return OGUnknown;
	
	return DEX_GetObjectType(m_lONr);
}

// modify the ident of object, returns old ident ------------------------------
ULONG CGeoObject::ChangeObjIdent (ULONG lNewIdent, bool fIsNotification)
{
	if (!m_fValid) return INVALID_IDENT;

ULONG lOldIdent = GetObjIdent();

	if (!fIsNotification) {
	// Objektklasse ändern
	MODOBJIDENT MI;

		INITSTRUCT (MI, MODOBJIDENT);
		MI.lONr = m_lONr;
		MI.lNewIdent = lNewIdent;
		MI.iMode = MODIDENT_TYP;
		if (!DEX_ModObjectIdent (MI))
			return INVALID_IDENT;	// error
	}

// Featurebaum freigeben, damit die unterliegenden Objekteigenschaften wirklich
// neu eingelesen werden. Selbiges ist notwendig, da die MCodeProps intern eine
// Liste von Zuordnungen vom Identifikator zum MCode halten, welche damit wieder
// aus den aktuellen Stand gebracht werden kann.
	m_pFeatObjTree -> EveryDelete();
	return lOldIdent;
}

// remove object physically ---------------------------------------------------
bool CGeoObject::Remove (void)
{
	if (!m_fValid) return false;
	
	D_OUTF1(2, "CGeoObject::Remove (%ld): removing directly.", m_lONr);

WUnknown Unk (GetUnknown());	// stabilize
bool fResult = DEX_DeleteObject (m_lONr);

	Invalidate();
	return fResult;
}

void CGeoObject::Validate (void)
{ 
	if (NULL == m_pFeatObjTree) 
		m_pFeatObjTree = CFeatObjTree::CreateInstance (m_pApp, m_pDoc, this);

	if (NULL != m_pFeatObjTree) 
		m_fValid = true; 
}

void CGeoObject::Invalidate (void) 
{ 
	DELETE_OBJ (m_pFeatObjTree);
	m_fValid = false; 
}

// Objekt neu zeichnen --------------------------------------------------------
void CGeoObject::RePaint (bool fComplete)
{
long lONr = GetValue();

	if (lONr == INVALID_ONR) return;

	if (!fComplete) {
		DEX_RePaintObject (lONr);	// nur draufmalen (default)
		return;
	}

SIZE Dim = GetDotsPerMM (NULL);	// Anzahl der Pixel/mm in beiden Koordinatenrichtungen für Hauptfenster
double dQuot = 1.0;		// Quotient von Bezugsmaßstab und Darstellungsmaßstab

	// Quotient aus Bezugs- und Darstellungsmaßstab ermitteln
	DEX_GetActiveScaling (dQuot);
	if (dQuot > 0) dQuot *= 100.0;		// Werte in 1/100 mm
	
POINT PLO, PRU;		// linker oberer (PLO) bzw. rechter unterer Eckpunkt (PRU) von OC im Point-Format
HANDLEVISINFO HVI;
long lCont[4];

	DEX_GetObjContainer (lONr, lCont);		// ObjektContainer holen

ObjContainer OC (lCont[0], lCont[1], lCont[2], lCont[3]);	// Container um editiertes Objekt

	INITSTRUCT (HVI, HANDLEVISINFO);
	HVI.m_lONr = lONr;	// ObjektNummer
//	HVI.m_lIdent = 0L;	// Identifikator
//	HVI.m_pDesc = NULL;	// beschreibender Text
//	HVI.m_pView = NULL;	// SichtName (aktuelle Sicht: NULL)

	switch (GetObjectType()) {
	case OGPunkt:
		{
		PVISINFO PVI;
		
			HVI.m_iVTyp = VTPunkt;		// VisInfoTyp
			HVI.m_pVI = &(PVI.m_VI);	// generischer Pointer auf VisInfo
		
		int ixpix = 0;
		int iypix = 0;
		
			if (DEX_GetIdentVisInfo (HVI)) {
				ixpix = (int) ((long(PVI.m_Size.cx) * Dim.cx) / dQuot);    // Größe des Punktsymbols in BS-Pixel (x-Richtung)
				iypix = (int) ((long(PVI.m_Size.cy) * Dim.cy) / dQuot);   //  bzw. y-Richtung
			}
			
		POINT PEO = BSKoordinaten (OC.XMin(), OC.YMin(), false);
						    
			PLO.x = PEO.x - ixpix/2 - 2; PLO.y = PEO.y + iypix/2 + 2;
			PRU.x = PEO.x + ixpix/2 + 2; PRU.y = PEO.y - iypix/2 - 2;
		}
		break;
			
	case OGLinie:
		{
		LVISINFO LVI;
		
			HVI.m_iVTyp = VTLinie;		// VisInfoTyp
			HVI.m_pVI = &(LVI.m_VI);	// generischer Pointer auf VisInfo

		int iWidth = 1;
		
			if (DEX_GetIdentVisInfo (HVI))
				iWidth = LVI.m_Width; 
			
			PLO = BSKoordinaten (OC.XMin(), OC.YMax(), false);
			PLO.x -= (int) ((long(iWidth) * Dim.cx) / dQuot) + 2;  // zu bildendes Rechteck noch um Linienbreite
			PLO.y += (int) ((long(iWidth) * Dim.cy) / dQuot) + 2; //   bzw. Sicherheitszugabe vergrößern
			PRU = BSKoordinaten (OC.XMax(), OC.YMin(), false);
			PRU.x += (int) ((long(iWidth) * Dim.cx) / dQuot) + 2;
			PRU.y -= (int) ((long(iWidth) * Dim.cy) / dQuot)+ 2;
		}
		break;
	
	case OGFlaeche:
		{
		FVISINFO FVI;
		
			HVI.m_iVTyp = VTFlaeche;	// VisInfoTyp
			HVI.m_pVI = &(FVI.m_VI);	// generischer Pointer auf VisInfo
		
		int iKontBr = 1;
		
			if (DEX_GetIdentVisInfo (HVI))
				iKontBr = ((FVI.m_VI.m_Style) & 0x7FFF) / 100;                
		
			PLO = BSKoordinaten (OC.XMin(), OC.YMax(), false);
			PLO.x -= (int) ((long(iKontBr) * Dim.cx) / dQuot) + 2;		// zu bildendes Rechteck noch um Linienbreite
			PLO.y += (int) ((long(iKontBr) * Dim.cy) / dQuot) + 2;	//   bzw. Sicherheitszugabe vergrößern
			PRU = BSKoordinaten (OC.XMax(), OC.YMin(), false);
			PRU.x += (int) ((long(iKontBr) * Dim.cx) / dQuot) + 2;
			PRU.y -= (int) ((long(iKontBr) * Dim.cy) / dQuot)+ 2;
		}
		break;

	default:
		break;
	}
	 
RECT Rec;

	SetRect (&Rec, PLO.x, PLO.y, PRU.x, PRU.y);
	DEX_RePaintRectWait (Rec);
}

// Anzahl der Pixel/mm in beiden Koordinatenrichtungen für dieses Fenster -----
static SIZE GetDotsPerMM (HDC hDC) 
{
HDC hDCloc;
SIZE dimD;

	dimD.cx = dimD.cy = 0;

	if (hDC != NULL) hDCloc = hDC;
	else		 hDCloc = GetDC (GetDesktopWindow());

	switch (GetMapMode (hDCloc)) {
	default:		// MM_ANISOTROPIC/MM_ISOTROPIC
	case MM_TEXT:		// der bisherige Stand
		{
		int HorzSize = GetDeviceCaps (hDCloc, HORZSIZE);       // Breite in mm
		int VertSize = GetDeviceCaps (hDCloc, VERTSIZE);       // Höhe in mm
		int HorzRes = GetDeviceCaps (hDCloc, HORZRES);         // Breite in Dots
		int VertRes = GetDeviceCaps (hDCloc, VERTRES);         // Höhe in Dots

			dimD.cx = HorzRes/HorzSize;
			dimD.cy = VertRes/VertSize;
		}
		break;

	case MM_HIMETRIC:	// [0.01 mm]
		dimD.cx = dimD.cy = 100;
		break;
		
	case MM_LOMETRIC:	// [0.1 mm]
		dimD.cx = dimD.cy = 10;
		break;
		
	case MM_HIENGLISH:	// [0.001 inch]
		dimD.cx = dimD.cy = 40;
		break;
		
	case MM_LOENGLISH:	// [0.01 inch]
		dimD.cx = dimD.cy = 4;
		break;
		
	case MM_TWIPS:
		dimD.cx = dimD.cy = 57;
		break;
	}

// DC bei Bedarf wieder freigeben
	if (hDC == NULL) ReleaseDC (GetDesktopWindow(), hDCloc);

return dimD;
}

static POINT BSKoordinaten (KoOrd XD, KoOrd YD, bool bKipp)
{
COORDCONVERT CC;
POINT BSPkt;
long DBKoord[2];

	DBKoord[0] = XD; DBKoord[1] = YD;
	CC.lpPt = &BSPkt;
	CC.lpPkt = DBKoord;

	if (bKipp)
		DEX_OCtoDC (CC);        // kippt die y-Koordinate
	else
		DEX_OCtoDCEx (CC);      // kippt die y-Koordinate nicht

return BSPkt;
} // BSKoordinaten

///////////////////////////////////////////////////////////////////////////////
// Funktionen werden gerufen, wenn externe Locks entstehen bzw.
// verschwinden
ULONG CGeoObject::InternalAddRef()
{
	_ASSERTE(m_dwRef != -1L);
	Lock();

long l = CComObjectRoot::InternalAddRef();

	if (m_dwRef == OBJ_EXTERNAL_THRESHOLD+1) {
		Unlock();
		FinalExternalConstruct();
	} else 
		Unlock();
	return l;
}

ULONG CGeoObject::InternalRelease()
{
	Lock();

long l = CComObjectRoot::InternalRelease();

	if (m_dwRef == OBJ_EXTERNAL_THRESHOLD) {
		Unlock();
		FinalExternalRelease();
	} else 
		Unlock();
	return l;
}

HRESULT CGeoObject::FinalExternalConstruct (void)
{
	ADDREF(m_pUnk);
	ADDREF_CAST(_DApplication, m_pApp);
	ADDREF_CAST(_DDocument, m_pDoc);
	return S_OK;
}

void CGeoObject::FinalExternalRelease (void)
{
	RELEASE_NONULL(m_pUnk);					// Parent wieder loslassen
	RELEASE_CAST(_DApplication, m_pApp);	// Applikation wieder loslassen
	RELEASE_CAST(_DDocument, m_pDoc);		// Dokument wieder loslassen
}

