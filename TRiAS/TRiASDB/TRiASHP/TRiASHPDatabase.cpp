// $Header: $
// Copyright© 1998-2000 TRiAS GmbH Potsdam, All rights reserved
// Created: 10.05.2000 19:36:40
//
// This file was generated by the TRiASDB Data Server Wizard V1.02.086 (#HK000510)
//
// @doc 
// @module TRiASHPDatabase.cpp | Datenbankobjekt TRiASDB Data Server TRiASHP

#include "stdafx.h"

#include <float.h>

#include <ospace/file/path.h>
#include <Com/ComBool.h>

#import "tlb/Helper.tlb" \
	raw_interfaces_only raw_dispinterfaces no_namespace named_guids \
	exclude("IParseRegularExpression", "IComposeStringPairs") 

#include "Version.h"
#include "Strings.h"

#include "TRiASHP.h"
#include "TRiASHPDatabase.h"

///////////////////////////////////////////////////////////////////////////////
// SmartIF's
DefineSmartInterface(Dispatch);
DefineSmartInterface(EnumVARIANT);
DefineSmartInterface(PersistStreamInit);

DefineSmartInterface(TRiASConnection);
DefineSmartInterface(TRiASPropertyBase);
DefineSmartInterface(TRiASProperties);
DefineSmartInterface(TRiASObjectsCollection);
DefineSmartInterface(TRiASObjects);
DefineSmartInterface(TRiASObjectHandleMap);

DefineSmartInterface(TRiASCS);
DefineSmartInterface(TRiASCSGCS);
DefineSmartInterface(TRiASCSDatumTransformation);
DefineSmartInterface(TRiASTransformGeometry);

DefineSmartInterface(TRiASSimpleRectangle);

DefineSmartInterface(TRiASMDSMap);
DefineSmartInterface(TRiASMDSStringColl);

DefineSmartInterface(ParseStringPairs2);

///////////////////////////////////////////////////////////////////////////////
// CTRiASMDatabase

STDMETHODIMP CTRiASHPDatabase::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITRiASDatabase,
		&IID_ITRiASPropertyBase,
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

HRESULT CTRiASHPDatabase::FinalConstruct (void)
{
	return S_OK;
}

void CTRiASHPDatabase::FinalRelease()
{
}

///////////////////////////////////////////////////////////////////////////////
// ITRiASBase
STDMETHODIMP CTRiASHPDatabase::get_Application (IDispatch **pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	CHECKOUTPOINTER(pVal);

WDispatch disp (m_Application);

	*pVal = disp.detach();
	return S_OK;
}

STDMETHODIMP CTRiASHPDatabase::put_Application (IDispatch *newVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	m_Application = newVal;
	return S_OK;
}

STDMETHODIMP CTRiASHPDatabase::get_Parent (IDispatch **pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	CHECKOUTPOINTER(pVal);

WDispatch disp (m_Parent);

	*pVal = disp.detach();
	return S_OK;
}

STDMETHODIMP CTRiASHPDatabase::put_Parent (IDispatch *newVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	m_Parent = newVal;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// ITRiASDatabase
STDMETHODIMP CTRiASHPDatabase::get_Handle (INT_PTR *pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	CHECKOUTPOINTER(pVal);
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED);

	*pVal = reinterpret_cast<INT_PTR>(this);
	return S_OK;
}

STDMETHODIMP CTRiASHPDatabase::get_IsDirty (VARIANT_BOOL *pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	CHECKOUTPOINTER(pVal);
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED);

	*pVal = m_fIsDirty ? VARIANT_TRUE : VARIANT_FALSE;
	return S_OK;
}

STDMETHODIMP CTRiASHPDatabase::put_IsDirty (VARIANT_BOOL newVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED);

	m_fIsDirty = newVal ? true : false;
	return S_OK;
}

STDMETHODIMP CTRiASHPDatabase::get_OpenedAsCopy (VARIANT_BOOL * pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	CHECKOUTPOINTER(pVal);
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED);
		
	*pVal = VARIANT_FALSE;
	return S_OK;
}

STDMETHODIMP CTRiASHPDatabase::get_CouldOpenTarget (VARIANT_BOOL * pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	CHECKOUTPOINTER(pVal);
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED);
		
	*pVal = VARIANT_FALSE;
	return S_OK;
}

STDMETHODIMP CTRiASHPDatabase::get_SchemaUpdatable (VARIANT_BOOL * pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	CHECKOUTPOINTER(pVal);
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED);
		
#if defined(_READWRITE)
#pragma TODO("get_SchemaUpdatable muß VARIANT_TRUE liefern, wenn die Struktur der Datenquelle modifizierbar ist.")
#endif // defined(_READWRITE)

	*pVal = VARIANT_FALSE;
	return S_OK;
}

STDMETHODIMP CTRiASHPDatabase::get_Name (BSTR *pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	CHECKOUTPOINTER(pVal);
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED);

CComBSTR bstrName (m_bstrName);

	if (!bstrName)
		return E_OUTOFMEMORY;

	*pVal = bstrName.Detach();
	return S_OK;
}

STDMETHODIMP CTRiASHPDatabase::get_Version (BSTR * pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	CHECKOUTPOINTER(pVal);
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED);

char cbBuffer[64];

	wsprintf (cbBuffer, "%d.%02d", TRIASHP_VERSION_MAJOR, TRIASHP_VERSION_MINOR);

CComBSTR bstrVersion (cbBuffer);

	*pVal = bstrVersion.Detach();
	return S_OK;
}

STDMETHODIMP CTRiASHPDatabase::get_VersionLong (LONG *pVal)
{
	CHECKOUTPOINTER(pVal);
	*pVal = TRIASHP_VERSION_MAJOR*100 + TRIASHP_VERSION_MINOR;
	return S_OK;
}

STDMETHODIMP CTRiASHPDatabase::get_CollatingOrder (LONG * pVal)
{
	CHECKOUTPOINTER(pVal);
	return E_NOTIMPL;
}

STDMETHODIMP CTRiASHPDatabase::get_Connect (BSTR * pVal)
{
	CHECKOUTPOINTER(pVal);
	return E_NOTIMPL;
}

STDMETHODIMP CTRiASHPDatabase::get_Transactions (VARIANT_BOOL * pVal)
{
	CHECKOUTPOINTER(pVal);
	*pVal = VARIANT_FALSE;
	return S_OK;
}

STDMETHODIMP CTRiASHPDatabase::get_Updatable (VARIANT_BOOL * pVal)
{
	CHECKOUTPOINTER(pVal);

#if defined(_READWRITE)
	*pVal = VARIANT_TRUE;
#else
	*pVal = VARIANT_FALSE;
#endif // defined(_READWRITE)
	return S_OK;
}

STDMETHODIMP CTRiASHPDatabase::get_Temporary (VARIANT_BOOL * pVal)
{
	CHECKOUTPOINTER(pVal);
	return E_NOTIMPL;
}

STDMETHODIMP CTRiASHPDatabase::put_Temporary (VARIANT_BOOL pVal)
{
	return E_NOTIMPL;
}

STDMETHODIMP CTRiASHPDatabase::get_TemporaryName (BSTR * pVal)
{
	return get_Name (pVal);
}

STDMETHODIMP CTRiASHPDatabase::get_Type (BSTR * pVal)
{
	CHECKOUTPOINTER(pVal);
		
// ProgID des zugehörigen Datenbankobjektes
CComBSTR bstr (g_cbDatabase);

	*pVal = bstr.Detach();
	return S_OK;
}

STDMETHODIMP CTRiASHPDatabase::get_StorageMode (DATABASESTORAGEMODE * pVal)
{
	CHECKOUTPOINTER(pVal);

	*pVal = DATABASESTORAGEMODE_DirectoryBased;
	return S_OK;
}

STDMETHODIMP CTRiASHPDatabase::CreateDatabase (BSTR Name, BSTR Locale, BSTR Source)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#if defined(_READWRITE)
#pragma TODO("CreateDatabase erzeugt eine neue Datenquelle.")
#endif // defined(_READWRITE)

	return E_NOTIMPL;
}

STDMETHODIMP CTRiASHPDatabase::CreateDatabaseFromFiles (IUnknown * FileNames, BSTR Locale, BSTR Source)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	return E_NOTIMPL;
}

STDMETHODIMP CTRiASHPDatabase::CreateDatabaseOnStg (IUnknown *pIUnk, BSTR Name, BSTR Locale, BSTR Source)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	return E_NOTIMPL;
}

STDMETHODIMP CTRiASHPDatabase::OpenDatabase (
	BSTR Name, VARIANT_BOOL Exclusive, VARIANT_BOOL fReadOnly, VARIANT_BOOL ModTrack, BSTR Source)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

#if !defined(_READWRITE)
	_ASSERTE(fReadOnly);		// darf nur schreibgeschützt geöffnet werden
	if (!fReadOnly)
	{
		RETURN_FAILED_HRESULT(E_INVALIDARG);
	}
#endif // !defined(_READWRITE)

	USES_CONVERSION;
	COM_TRY {
	// Datenbasis öffnen
		if (FAILED(m_DB.Open(OLE2A(Name), !fReadOnly, false)))
			return TRIASDB_E_COULD_NOT_OPEN;

		m_bstrName = Name;

	// neue PropertiesCollection anlegen und initialisieren
		THROW_FAILED_HRESULT(CreatePropertiesCollection());		// --> TRiASHPPropertyBase.h

	// Tabelle der Objektklassenbeschreibungen initialisierne
		THROW_FAILED_HRESULT(InitObjectsTable());

	// KoordinatenSystemService erzeugen und initialisieren
		THROW_FAILED_HRESULT(InitCoordSystemService(Source));

	} COM_CATCH_OP(if (IsOpened()) m_DB.Close(););
	return S_OK;
}

STDMETHODIMP CTRiASHPDatabase::OpenFilesAsDatabase (
	IUnknown * FileNames, VARIANT_BOOL Exclusive, VARIANT_BOOL ReadOnly, VARIANT_BOOL ModTrack, BSTR Source)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	return E_NOTIMPL;
}

STDMETHODIMP CTRiASHPDatabase::OpenStorageAsDatabase(
	IUnknown *pIUnk, VARIANT_BOOL Exclusive, VARIANT_BOOL fReadOnly, VARIANT_BOOL ModTrack, BSTR Source)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	return E_NOTIMPL;
}

STDMETHODIMP CTRiASHPDatabase::Save()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

#if defined(_READWRITE)
#pragma TODO("Save speichert die Änderungen der Datenquelle.")
#endif // defined(_READWRITE)

	m_fIsDirty = false;
	return E_NOTIMPL;
}

STDMETHODIMP CTRiASHPDatabase::SaveAs (BSTR NewName)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

#if defined(_READWRITE)
#pragma TODO("Save speichert die Änderungen der Datenquelle unter einem neuen Namen.")
#endif // defined(_READWRITE)

	return E_NOTIMPL;
}

STDMETHODIMP CTRiASHPDatabase::Close()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED);

	COM_TRY {
	// alle Objekte abhängen (_vor_ FreePropertiesCollection, da sonst neue Coll erzeugt wird)
		if (m_ObjectsDefs.IsValid()) {
			m_ObjectsDefs -> put_Parent (NULL);
			m_ObjectsDefs.Assign(NULL);
		}
		
	// FeatureMap entleeren (break reference cycle)
	WTRiASObjectHandleMap Map (GetPropertyFrom (GetDispatch(), g_cbFeatureMap, (IDispatch *)NULL), false);	// GetProperty liefert AddRef'ed ab

		if (Map.IsValid())
			Map -> RemoveObject (NULL, OBJECTMAPMODE_RemoveAllObjects);

	// alles freigeben
		ShutdownCoordSystemService();
		ReleasePropertySupportObjects();		// --> TRiASHPPropertySupport.h
		FreePropertiesCollection();				// --> TRiASHPPropertyBase.h

		m_bstrName.Empty();

	// es _muß_ vorher gespeichert worden sein
		m_DB.Close();

	} COM_CATCH;
	return S_OK;
}

STDMETHODIMP CTRiASHPDatabase::BeginTrans()
{
	return E_NOTIMPL;
}

STDMETHODIMP CTRiASHPDatabase::ClearModificationLog(LONG Entry)
{
	return E_NOTIMPL;
}

STDMETHODIMP CTRiASHPDatabase::CommitTrans()
{
	return E_NOTIMPL;
}

STDMETHODIMP CTRiASHPDatabase::Rollback()
{
	return E_NOTIMPL;
}

STDMETHODIMP CTRiASHPDatabase::ReLoad (RELOADDATABASE rgWhat)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

HRESULT hr = S_OK;

	if (RELOADDATABASE_All == rgWhat) {
	// alles neu einlesen
		RETURN_FAILED_HRESULT(OnReLoadObjects());
		RETURN_FAILED_HRESULT(OnReLoadEnvelope());

	} else switch (rgWhat) {
	case RELOADDATABASE_Envelope:
		hr = OnReLoadEnvelope();
		break;

	case RELOADDATABASE_Objects:
		hr = OnReLoadObjects();
		break;

	case RELOADDATABASE_ConnectionInitialized:
		hr = InitObjectsTable();
		break;
	}
	return hr;
}

HRESULT CTRiASHPDatabase::OnReLoadObjects()
{
	return S_OK;
}

HRESULT CTRiASHPDatabase::OnReLoadEnvelope()
{
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// 
STDMETHODIMP CTRiASHPDatabase::RefreshChangesFromModificationLog (
	ITRiASRefreshChangesCallback *pICallback)
{
	return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////////
// ITRiASAccessDatabase

// liefert die Sammlung aller Objektklassen dieser Datenquelle
STDMETHODIMP CTRiASHPDatabase::get_ObjectsDefs (ITRiASObjectsCollection **pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	CHECKOUTPOINTER(pVal);
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED)

// wenn die Collection bereits existiert, dann lediglich diese zurückliefern
	if (m_ObjectsDefs.IsValid()) 
		return LPUNKNOWN(*pVal = m_ObjectsDefs) -> AddRef(), S_OK;

// ansonsten neu erzeugen
	return EnsureObjectsDefs (pVal);
}

HRESULT CTRiASHPDatabase::EnsureObjectsDefs (ITRiASObjectsCollection **pVal)
{
	_ASSERTE(!m_ObjectsDefs.IsValid());
	COM_TRY {
	WTRiASObjectsCollection ObjsColl (CLSID_TRiASHPObjectsCollection);

		THROW_FAILED_HRESULT(ObjsColl -> put_Application(m_Application));
		THROW_FAILED_HRESULT(ObjsColl -> put_Parent(GetDispatch()));

		if (m_DB.GetLayerCount() > 0) {
		CLayerIterator it (m_DB);
		CShapeLayer *pLayer = it.GetFirstLayer();

			_ASSERTE(NULL != pLayer);
			do {
			// Objektklasse instantiieren
			WTRiASObjects Objs (CLSID_TRiASHPObjects);

			// Objektklasse fertig initialisieren
				THROW_FAILED_HRESULT(WPersistStreamInit(Objs) -> InitNew());
				THROW_FAILED_HRESULT(Objs -> put_Application (m_Application));
				THROW_FAILED_HRESULT(Objs -> put_Parent (GetDispatch()));

			// Namen etc. dieser Objektklasse festlegen
				_ASSERTE(NULL != pLayer -> GetName() && '\0' != *pLayer -> GetName());

			CComBSTR bstrTable(pLayer -> GetName());
				
			// evtl. existierende Beschreibungstabelle auswerten
			WTRiASMDSMap ObjsTable (GetProperty (GetProperties(), g_cbMetaDataMap, (IDispatch *)NULL), false);
			WTRiASMDSStringColl ObjsDesc;
			CComBSTR bstrDesc, bstrName;

				_ASSERTE(ObjsTable.IsValid());
				if (S_OK == ObjsTable -> Search (bstrTable, mdsSM_SrchName|mdsSM_Compare, ObjsDesc.ppi())) {
				WEnumVARIANT Enum;
				CComVariant v, vIdent;

					THROW_FAILED_HRESULT(ObjsDesc -> _NewEnum (Enum.ppu()));
					THROW_FAILED_HRESULT(Enum -> Reset());

					if (S_OK == Enum -> Next (1, &v, NULL)) {
					// das erste gefundene Element wird verwendet
						THROW_FAILED_HRESULT(v.ChangeType (VT_BSTR));

					// ggf. existierende neue Texte speichern
#if defined(_DEBUG)
					CComBSTR bstrTableT;

						THROW_FAILED_HRESULT(ObjsTable -> GetAt (V_BSTR(&v), &bstrTableT, CLEARED(&bstrName), CLEARED(&bstrDesc), CLEARED(&vIdent)));
						_ASSERTE(bstrTableT == bstrTable);
#else
						THROW_FAILED_HRESULT(ObjsTable -> GetAt (V_BSTR(&v), NULL, CLEARED(&bstrName), CLEARED(&bstrDesc), CLEARED(&vIdent)));
#endif // defined(_DEBUG)

//					CComVariant vOks;
//					ULONG ulOks = wcstoul (V_BSTR(&v), NULL, 16);

						THROW_FAILED_HRESULT(vIdent.ChangeType (VT_UI4));
//						if (0 != ulOks && V_UI4(&vIdent) != ulOks) {
							THROW_FAILED_HRESULT(Objs -> put_OKS (V_BSTR(&v)));			// OKS
//						} 

					// TabellenNamen setzen (wird für put_Handle benötigt)
						THROW_FAILED_HRESULT(Objs -> put_Name (bstrTable));				// Tabellennamen setzen

					// Handle zuweisen
						THROW_FAILED_HRESULT(Objs -> put_Handle (V_I4(&vIdent)));
						
					// ggf. alles andere wegschreiben
						if (!!bstrName && bstrName.Length() > 0) {
							THROW_FAILED_HRESULT(Objs -> put_Name (bstrName));			// Kurztext
						}
						if (!!bstrDesc && bstrDesc.Length() > 0) {
							THROW_FAILED_HRESULT(Objs -> put_Description (bstrDesc));	// Langtext
						}

					} else {
					// Tabellenname ist erstmal gleichzeitig Kurztext
					INT_PTR hObjs = NULL;

						THROW_FAILED_HRESULT(Objs -> put_Name (bstrTable));
						THROW_FAILED_HRESULT(Objs -> get_Handle (&hObjs));			// Handle erzwingen
					}
				} else {
				// Tabellenname ist erstmal gleichzeitig Kurztext
				INT_PTR hObjs = NULL;

					THROW_FAILED_HRESULT(Objs -> put_Name (bstrTable));
					THROW_FAILED_HRESULT(Objs -> get_Handle (&hObjs));			// Handle erzwingen
				}

			// Typen der Objektklasse setzen
				THROW_FAILED_HRESULT(Objs -> put_CollectionType(OBJECTSCOLLECTIONTYPE_Class));
				THROW_FAILED_HRESULT(Objs -> put_Types(pLayer -> GetTypes()));
				THROW_FAILED_HRESULT(Objs -> put_Updatable(CComBool(pLayer -> GetUpdatable())));

			// Namen der Standard-Objekteigenschaften (Geometrie und Normal) setzen
				THROW_FAILED_HRESULT(Objs -> put_DefaultGeometry (CComBSTR(g_cbGeometry)));
				THROW_FAILED_HRESULT(Objs -> put_PrimaryKey (CComBSTR(g_cbShapeID)));

			// an der erzeugten Objektklasse unsere Nummer (cursor) speichern
				THROW_FAILED_HRESULT(SetPropertyBy (Objs, g_cbObjectsCursor, CComVariant(reinterpret_cast<ULONG>(pLayer), VT_I4), true));

			// die neu instantiierte Objektklasse zur Menge der Objektklassen hinzufügen
				THROW_FAILED_HRESULT(ObjsColl -> _Add (Objs, VARIANT_TRUE));

				pLayer = it.GetNextLayer();
			} while (NULL != pLayer);
		}
		m_ObjectsDefs = ObjsColl;
		if (NULL != pVal)
			*pVal = ObjsColl.detach();

	} COM_CATCH;
	return S_OK;
}

// liefert bzw. erzeugt eine neue Objektklasse dieser Datenquelle
STDMETHODIMP CTRiASHPDatabase::get_ObjectsDef(
	VARIANT vItem, VARIANT_BOOL fCreate, BSTR Type, ITRiASObjects **pIObjDef)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	CHECKOUTPOINTER(pIObjDef);
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED)

	if (!m_ObjectsDefs.IsValid())
	{
		RETURN_FAILED_HRESULT(EnsureObjectsDefs());
	}
	_ASSERTE(m_ObjectsDefs.IsValid());

HRESULT hr = m_ObjectsDefs -> Item (vItem, pIObjDef);

	if (TRIASDB_E_UNKNOWN_OBJECTS == hr && fCreate) {	// evtl. neu erzeugen
	CComVariant v;

		hr = v.ChangeType (VT_BSTR, &vItem);
		if (SUCCEEDED(hr)) {
		CIID ClsId (Type, CIID::INITCIID_InitFromProgId);

			if (!ClsId)	
				hr = m_ObjectsDefs -> Add (V_BSTR(&v), CComBSTR(g_cbNil), pIObjDef);	// default type verwenden
			else
				hr = m_ObjectsDefs -> Add (V_BSTR(&v), CComBSTR(ClsId.ProgID().c_str()), pIObjDef);
			if (S_OK == hr) hr = S_FALSE;				// Objektmenge wurde neu erzeugt
		}
	}
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// Umschließenden Datenbank-Container liefern
STDMETHODIMP CTRiASHPDatabase::get_Envelope (ENVELOPETYPE rgType, IDispatch **pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	CHECKOUTPOINTER(pVal);
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED)

	COM_TRY {
	// Koordinaten deskalieren
	double dXMin = DBL_MAX, dYMin = DBL_MAX, dXMax = -DBL_MAX, dYMax = -DBL_MAX;

		if (m_DB.GetLayerCount() > 0) {
		CLayerIterator it (m_DB);
		CShapeLayer *pLayer = it.GetFirstLayer();

			_ASSERTE(NULL != pLayer);
			do {
			double dXMinT = DBL_MAX, dYMinT = DBL_MAX, dXMaxT = -DBL_MAX, dYMaxT = -DBL_MAX;

				if (SUCCEEDED(pLayer -> GetBoundingRect (&dXMinT, &dYMinT, &dXMaxT, &dYMaxT))) {
					dXMin = min(dXMin, dXMinT);
					dYMin = min(dYMin, dYMinT);
					dXMax = max(dXMax, dXMaxT);
					dYMax = max(dYMax, dYMaxT);
				}
				pLayer = it.GetNextLayer();
			} while (NULL != pLayer);
		}
				
	// CS-Transformator besorgen
	WTRiASCSTransform CST (GetPropertyFrom (GetDispatch(), g_cbTRiASCSTransform, (IDispatch *)NULL), false);

		_ASSERTE(CST.IsValid());

	// Container der Datenquelle setzen
	WTRiASSimpleRectangle Rect (CLSID_TRiASCSRectangleGeometry);
	
		THROW_FAILED_HRESULT(WPersistStreamInit(Rect) -> InitNew());
		THROW_FAILED_HRESULT(Rect -> SetRect (dXMin, dYMin, dXMax, dYMax));
		THROW_FAILED_HRESULT(WTRiASTransformGeometry(Rect) -> Transform ((CSID &)m_CtfGuid, CST));

		*pVal = Rect.detach();

	} COM_CATCH;
	return S_OK;
}

STDMETHODIMP CTRiASHPDatabase::get_ObjectCount (long *pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	CHECKOUTPOINTER(pVal);
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED)

	if (m_DB.GetLayerCount() > 0) {
	CLayerIterator it (m_DB);
	CShapeLayer *pLayer = it.GetFirstLayer();

		_ASSERTE(NULL != pLayer);
		do {
			*pVal += pLayer -> GetObjectCount();
			pLayer = it.GetNextLayer();
		} while (NULL != pLayer);
	} else
		*pVal = 0;

	return S_OK;
}

STDMETHODIMP CTRiASHPDatabase::get_AttachedCS(BSTR bstrDbName, BSTR *pbstrAssocCS)
{
	if (NULL == pbstrAssocCS)
		return E_POINTER;
	*pbstrAssocCS = NULL;

	COM_TRY {
	CComBSTR bstrAttachedCS;

		if (SUCCEEDED(FindTcfFile(bstrDbName, &bstrAttachedCS))) {
		WTRiASCS CS(CLSID_TRIASCS);	
				
			if (SUCCEEDED(CS -> LoadFromFile(bstrAttachedCS))) {
				*pbstrAssocCS = bstrAttachedCS.Detach();
				return S_OK;
			}
		}

	} COM_CATCH_IGNORE;
	return E_FAIL;
}

STDMETHODIMP CTRiASHPDatabase::get_ConnectionFilter (ITRiASConnectionFilter **ppIGeom)
{
	return E_NOTIMPL;
}

STDMETHODIMP CTRiASHPDatabase::put_ConnectionFilter (ITRiASConnectionFilter *pIGeom)
{
	return E_NOTIMPL;
}

STDMETHODIMP CTRiASHPDatabase::get_Views (ITRiASViews **pVal)
{
	return E_NOTIMPL;
}

STDMETHODIMP CTRiASHPDatabase::get_StartViewName (BSTR *pVal)
{
	return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////////
// Koordinatensystem neu initialisieren
HRESULT CTRiASHPDatabase::InitCSFromSource (BSTR bstrDbName, BSTR bstrSource, 
	ITRiASCS **ppICS)
{
	COM_TRY {
	WParseStringPairs2 Pairs (CLSID_ParseStringPairs);
	long lPairs = 0;

		THROW_FAILED_HRESULT(Pairs -> put_Pattern(CComBSTR(g_cbPattern)));
		THROW_FAILED_HRESULT(Pairs -> Parse(bstrSource, &lPairs));

	CComBSTR bstrCSName;

		if (S_OK == Pairs -> get_Value(CComBSTR("COORDSYS"), &bstrCSName)) {
		WTRiASCS CS (CLSID_TRIASCS);

			if (SUCCEEDED(CS -> LoadFromFile(bstrCSName))) {
				WriteCSToIni(bstrDbName, bstrCSName);
				*ppICS = CS.detach();
				return S_OK;
			}
		}
			
	} COM_CATCH;
	return E_FAIL;
}

HRESULT CTRiASHPDatabase::InitCoordSystemService(BSTR bstrSource)
{
	COM_TRY {
	// Ausgabesystem von der Connection holen (hat sich u.U. geändert)
	WTRiASConnection Conn;

		THROW_FAILED_HRESULT(FindSpecificParent (m_Parent, Conn.ppi()));

	WTRiASCS CSOut (GetPropertyFrom (Conn, g_cbTRiASCSService, (IDispatch *)NULL), false);

		_ASSERTE(CSOut.IsValid());	// muß bereits existieren

	// CTF-Service holen/initialisieren
	WTRiASProperties Props (GetProperties());
	WTRiASCSTransform CST (GetProperty (Props, g_cbTRiASCSTransform, (IDispatch *)NULL), false);
	WTRiASCS CS;

		if (!CST.IsValid()) {
		// neuen CTF-Service erzeugen und am Objekt ablegen
			CST = WTRiASCSTransform(CLSID_TRiASCSTransform);

		// Versuchen aus CS dem ConnectString zu laden (hat Vorrang!)
			if (FAILED(InitCSFromSource(m_bstrName, bstrSource, CS.ppi()))) {
			// Koordinatensystem-Datei finden
			CComBSTR bstrTcfName;

				if (SUCCEEDED(FindTcfFile (m_bstrName, &bstrTcfName))) {
				// gefundenes Koordinatensystem laden
					CS = WTRiASCS(CLSID_TRIASCS);	
					if (FAILED(CS -> LoadFromFile(bstrTcfName)))
						CS.Assign(NULL);
				} 
			}
			if (!CS.IsValid())
				CS = CSOut;		// CS vom Projekt als letzten Ausweg

		// Guid des Koordinatensystemes speichern
		CComBSTR bstrGuid;

			THROW_FAILED_HRESULT(CS -> get_GUID(&bstrGuid));
			m_CtfGuid = CIID(bstrGuid, CIID::INITCIID_InitFromGuid);
			_ASSERTE(!!m_CtfGuid);			// CS-Guid muß jetzt gültig sein

		// dieses Koordinatensystem als InputCS zum Transformator hinzufügen
			THROW_FAILED_HRESULT(CST -> AddInputCS (CS));

		// CS-Guid und Transformator an der Datenbank speichern
			THROW_FAILED_HRESULT(SetProperty (Props, g_cbCSSGuid, 
				CComBSTR(os_string(m_CtfGuid).c_str()), true));
			THROW_FAILED_HRESULT(SetProperty (Props, g_cbTRiASCSTransform, 
				CComVariant(CST), true));
		}

	// AusgangsSystem an unserem Transformator setzen
		THROW_FAILED_HRESULT(CST -> putref_OutputCS (CSOut));
		THROW_FAILED_HRESULT(CSOut -> Recompute());		// TransformationsPfad neu berechnen

	} COM_CATCH;
	return S_OK;
}

// Koordinatensystem freigeben
HRESULT CTRiASHPDatabase::ShutdownCoordSystemService()
{
	COM_TRY {
	WTRiASCSTransform CST (GetProperty (GetProperties(), g_cbTRiASCSTransform, 
		(IDispatch *)NULL), false);

		ERROR_EXPR_TRUE(!CST.IsValid(), E_UNEXPECTED);
		THROW_FAILED_HRESULT(CST -> ShutDown());

	} COM_CATCH;
	return S_OK;
}

namespace {
	inline bool FileExists (LPCSTR pcName)
	{
		return ((DWORD)-1 == ::GetFileAttributes (pcName)) ? false : true;
	}
}

// Finden der Koordinatensystemdatei
// Die Koordinatensystemdatei wird auf folgende Weise gesucht:
// 1. Ini-Datei der Datenquelle: [CoordSystem], LoadFromFile=Dateiname
// 2. 'DatenquellenVerzeichnis/NameDesDatenquellenVerzeichnisses.tcf'
// 3. Es wird das Koordinatensystem des Projektes übernommen
HRESULT CTRiASHPDatabase::FindTcfFile (BSTR bstrDbName, BSTR *pbstrTcfName)
{
	USES_CONVERSION;

// 1. über Ini-Datei der Datenquelle suchen
// Dateinamen der ProfileDatei neu generieren
os_path rootpath = os_string(OLE2A(bstrDbName));

	_ASSERTE(!rootpath.file_path());		// Datenquelle ist verzeichnisorientiert

	rootpath.filename (rootpath.tail());
	if (!rootpath.file_path())			// Targetverzeichnis ist Laufwerkswurzel (!?)
		rootpath.filename (g_cbRoot);

os_path inipath (rootpath);

	inipath.extension (g_cbIni);

char cbBuffer[_MAX_PATH];
DWORD dwLen = GetPrivateProfileString(g_cbCoordSystem, g_cbLoadFromFile, g_cbNil, cbBuffer, sizeof(cbBuffer), (LPCSTR)inipath);

	if (dwLen > 0) {
	// angegebener Name paßt zu einer existierenden Datei
		if (FileExists (cbBuffer)) {
			return S_OK;		// found 
		}

	// prüfen, ob der angegebene Name evtl. relativer Pfad ist
	os_path found (rootpath);
	os_path file (cbBuffer);

		found.filename(file.filename());
		if (!file.has_extension())
			found.extension(g_cbTcf);
		else
			found.extension(file.extension());
			
		if (FileExists (found)) {
		CComBSTR bstrName ((LPCSTR)found);

			*pbstrTcfName = bstrName.Detach();
			return S_OK;		// found 
		}
	}

// 2. direkt als Datei suchen
os_path tcfpath (rootpath);

	tcfpath.extension(g_cbTcf);
	if (FileExists (tcfpath)) {
	CComBSTR bstrName ((LPCSTR)tcfpath);

		*pbstrTcfName = bstrName.Detach();
		return S_OK;		// found 
	}

// den Namen direkt zurückliefern (ist ja vielleicht ein CS in der Resource :-)
CComBSTR bstrName (cbBuffer);

	*pbstrTcfName = bstrName.Detach();
	return S_FALSE;
}

HRESULT CTRiASHPDatabase::WriteCSToIni(BSTR bstrDbName, BSTR bstrCSName)
{
	USES_CONVERSION;

os_path rootpath = os_string(OLE2A(bstrDbName));

	_ASSERTE(!rootpath.file_path());	// Datenquelle ist verzeichnisorientiert

	rootpath.filename (rootpath.tail());
	if (!rootpath.file_path())			// Targetverzeichnis ist Laufwerkswurzel (!?)
		rootpath.filename (g_cbRoot);

os_path inipath (rootpath);

	inipath.extension (g_cbIni);

BOOL fSuccess = WritePrivateProfileString(g_cbCoordSystem, g_cbLoadFromFile, 
	OLE2A(bstrCSName), (LPCSTR)inipath);

	return fSuccess ? S_OK : E_FAIL;
}

///////////////////////////////////////////////////////////////////////////////
// Verwaltung der Tabelle der Objektklassenbeschreibungen (an der Connection)
HRESULT CTRiASHPDatabase::InitObjectsTable()
{
	COM_TRY {
	// Tabelle der Objektklassenbeschreibungen holen/initialisieren
	WTRiASMDSMap ObjsTable (GetProperty (GetProperties(), g_cbMetaDataMap, (IDispatch *)NULL), false);

		if (!ObjsTable.IsValid()) {
		// neue Tabelle erzeugen, wenn selbige noch nicht existiert
			ObjsTable = WTRiASMDSMap(CLSID_TRiASMDSMap);

		// als Property an der Datenbank speichern
			THROW_FAILED_HRESULT(SetProperty (GetProperties(), g_cbMetaDataMap, CComVariant(ObjsTable), true));
		}

	} COM_CATCH;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// OleItemContainerSupport
// nach einer bestimmten Objektklasse fragen
HRESULT CTRiASHPDatabase::GetObjectsDef (
	LPCTSTR pcItem, DWORD dwSpeedNeeded, REFIID riid, LPVOID *ppvObj, bool fTestRunningOnly)
{
	if (!m_ObjectsDefs) {
		if (BINDSPEED_IMMEDIATE == dwSpeedNeeded)
			return MK_E_EXCEEDEDDEADLINE;

	// evtl. Neuerzeugen der benötigten Collection
	WTRiASObjectsCollection Coll;

		RETURN_FAILED_HRESULT(get_ObjectsDefs (Coll.ppi()));	// fills in m_ObjectsDefs
	}
	_ASSERTE(m_ObjectsDefs.IsValid());

HRESULT hr = S_OK;

	COM_TRY {
	WTRiASObjects Objs;
		
		hr = m_ObjectsDefs -> Item (CComVariant(pcItem), Objs.ppi());
		if (TRIASDB_E_UNKNOWN_OBJECTS == hr && !fTestRunningOnly) {
		// Objektklasse ist neu und muß erzeugt werden
			if (BINDSPEED_IMMEDIATE == dwSpeedNeeded)
				return MK_E_EXCEEDEDDEADLINE;
			hr = m_ObjectsDefs -> Add (CComBSTR(pcItem), CComBSTR("TRiASDB.TRiASHPObjects.1"), Objs.ppi());
		}

		if (SUCCEEDED(hr) && !fTestRunningOnly && NULL != ppvObj)	// Objektklasse ist (jetzt) bekannt
		{
			_ASSERTE(Objs.IsValid());
			THROW_FAILED_HRESULT(Objs -> QueryInterface (riid, ppvObj));
		}
	} COM_CATCH;
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// nach einem bestimmten Objekt fragen
HRESULT CTRiASHPDatabase::GetObjectDef (
	LPCTSTR pcItem, DWORD dwSpeedNeeded, REFIID riid, LPVOID *ppvObj, bool fTestRunningOnly)
{
	if (BINDSPEED_IMMEDIATE == dwSpeedNeeded)	// muß immer in der eigentlichen Datenbank gesucht werden
		return MK_E_EXCEEDEDDEADLINE;

	COM_TRY {
#pragma TODO("Objekt anhand des übergenenen Displaynames wiederfinden.")

	} COM_CATCH;
	return S_OK;
}

// DisplayName parsen und Moniker liefern
HRESULT CTRiASHPDatabase::ParseObjectsDef (
	LPCTSTR pcItem, ULONG ulSkipped, ULONG *pulEaten, IMoniker **ppmkOut)
{
CComBSTR bstrItem(pcItem);

	RETURN_FAILED_HRESULT(CreateItemMoniker (g_cbMkDel, bstrItem, ppmkOut));
	*pulEaten += bstrItem.Length();
	return S_OK;
}

HRESULT CTRiASHPDatabase::ParseObjectDef (
	LPCTSTR pcItem, ULONG ulSkipped, ULONG *pulEaten, IMoniker **ppmkOut)
{
CComBSTR bstrItem(pcItem);

	RETURN_FAILED_HRESULT(CreateItemMoniker (g_cbMkDel, bstrItem, ppmkOut));
	*pulEaten += bstrItem.Length();
	return S_OK;
}

