// $Header: $
// Copyright© 1998-2000 TRiAS GmbH Potsdam, All rights reserved
// Created: 10.05.2000 19:36:40 
//
// This file was generated by the TRiASDB Data Server Wizard V1.02.086 (#HK000510)
//
// @doc
// @module TRiASHPObjects.cpp | Implementation of the <c CTRiASHPObjects> class

#include "stdafx.h"

#include <Com/SafeArray.h>

#include "Strings.h"

#include "TRiASHP.h"
#include "ShapeLayer.h"
#include "TRiASHPObjects.h"
#include "TRiASHPPropertySupport.h"
#include "TRiASHPGeoFeature.h"

#if defined(_DEBUG)
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif // _DEBUG

///////////////////////////////////////////////////////////////////////////////
// SmartIF's
DefineSmartInterface(TRiASObject);
DefineSmartInterface(TRiASObjects);
DefineSmartInterface(TRiASFeature);
DefineSmartInterface(TRiASFeatures);
DefineSmartInterface(TRiASDatabase);
DefineSmartInterface(TRiASObjectHandleMap);
DefineSmartInterface(TRiASPropertyMapHandler);
DefineSmartInterface(TRiASSearchObjects);

DefineSmartInterface(TRiASMDSMap);

DefineSmartInterface(PersistStreamInit);
DefineSmartInterface(Dispatch);

///////////////////////////////////////////////////////////////////////////////
// CTRiASHPObjects

STDMETHODIMP CTRiASHPObjects::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITRiASObjects,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// ITRiASObjectsCallback

STDMETHODIMP CTRiASHPObjects::get_DefaultType (BSTR *pbstrType)
{
	CHECKOUTPOINTER(pbstrType);

CIID Guid (CLSID_TRiASHPObject);		// DefaultType der _Elemente_ (hier: Object)!
CComBSTR bstrType (Guid.ProgID().c_str());

	*pbstrType = bstrType.Detach();
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Erstmalige Initialisierung
STDMETHODIMP CTRiASHPObjects::SetupObjects(SETUPOBJECTSMODE rgMode)
{
HRESULT hr = E_INVALIDARG;

	switch (rgMode) {
	case SETUPOBJECTSMODE_Count:
		hr = EnsureObjectsCount();
		_ASSERTE(HasType (m_rgInitState, INITSTATE_CountsInitialized));
		break;

	case SETUPOBJECTSMODE_Load:
		ERROR_EXPR_TRUE(!m_fIsInitialized, E_UNEXPECTED);
		hr =  EnsureObjectsLoaded();
		_ASSERTE(HasType (m_rgInitState, INITSTATE_ObjectsInitialized));
		break;

	case SETUPOBJECTSMODE_InitOrLoad:	// wird während der Initialisierung gerufen
		COM_TRY {
		// Properties zum aggregierten Objekt hinzufügen
		WTRiASPropertyMapHandler MapHandler(m_BaseUnk);

		// Cursor für Objects-Objektes
			THROW_FAILED_HRESULT(MapHandler -> AddMapEntry (
				CComBSTR(g_cbObjectsCursor), (INT_PTR)&CLSID_TRiASHPCursorProperty, PROPERTYSUPPORT_NOFLAGS, vtMissing));

		// Zuordnung ObjectCursor --> pIObjects
			THROW_FAILED_HRESULT(MapHandler -> AddMapEntry (
				CComBSTR(g_cbObjectMap), (INT_PTR)&CLSID_GenObjectMap, PROPERTYSUPPORT_NOFLAGS, vtMissing));

		// MetaDataMap für Feature-Beschreibungsdaten
			THROW_FAILED_HRESULT(MapHandler -> AddMapEntry (
				CComBSTR(g_cbMetaDataMap), (INT_PTR)&CLSID_TRiASMetaDataMap, PROPERTYSUPPORT_AGGREGATE, vtMissing));

			m_fIsDirty = false;
			m_fIsInitialized = true;
			hr = S_OK;
		} COM_CATCH;
		break;

	case SETUPOBJECTSMODE_ResetObjectInfo:
		m_fIsDirty = true;
		m_rgInitState = INITSTATE_NotInitialized;
		hr = S_OK;
		break;

	default:
		_ASSERTE(SETUPOBJECTSMODE_Count == rgMode || 
			SETUPOBJECTSMODE_Load == rgMode || 
			SETUPOBJECTSMODE_InitOrLoad == rgMode ||
			SETUPOBJECTSMODE_ResetObjectInfo == rgMode);
		break;
	}
	return hr;
}

HRESULT CTRiASHPObjects::EnsureObjectsCount()
{
	if (HasType (m_rgInitState, INITSTATE_CountsInitialized))
		return S_OK;		// wurden bereits geladen

	COM_TRY {
	WTRiASObjects BaseObjs;
	long lObjCount = 0;
	OBJECTTYPE rgTypes = OBJECTTYPE_Unknown;

		THROW_FAILED_HRESULT(m_BaseUnk -> QueryInterface (BaseObjs.ppi()));

	CShapeLayer *pLayer = reinterpret_cast<CShapeLayer *>(GetPropertyFrom (BaseObjs, g_cbObjectsCursor, 0L));

		_ASSERTE(NULL != pLayer);

	// Ergebnis der schweißtreibenden Arbeit dem aggregierten Objekt mitteilen
		THROW_FAILED_HRESULT(BaseObjs -> put_Count (pLayer -> GetObjectCount()));		// Basisklasse informieren
		THROW_FAILED_HRESULT(BaseObjs -> put_Types (pLayer -> GetTypes()));

	// Zähler sind jetzt initialisiert
		SetType (m_rgInitState, INITSTATE_CountsInitialized);

	} COM_CATCH;
	return S_OK;
}

HRESULT CTRiASHPObjects::EnsureObjectsLoaded()
{
	if (HasType (m_rgInitState, INITSTATE_ObjectsInitialized))
		return S_OK;		// wurden bereits geladen

	COM_TRY {
	WTRiASObjects BaseObjs;
	
		THROW_FAILED_HRESULT(m_BaseUnk -> QueryInterface (BaseObjs.ppi()));

	CShapeLayer *pLayer = reinterpret_cast<CShapeLayer *>(GetPropertyFrom (BaseObjs, g_cbObjectsCursor, 0L));

		_ASSERTE(NULL != pLayer);

	// alle Objekte durchgehen und instantiieren
	WTRiASObjectHandleMap Map (GetPropertyFrom (BaseObjs, g_cbObjectMap, (IDispatch *)NULL), false);
	WDispatch App;
	OBJECTTYPE rgType = pLayer -> GetTypes();
	int iObjCnt = pLayer -> GetObjectCount();

		_ASSERTE(Map.IsValid());

		THROW_FAILED_HRESULT(BaseObjs -> get_Application (App.ppi()));
		for (int i = 0; i < iObjCnt; i++) {
		// zuerst versuchen, dieses Objekt in der Map wiederzufinden
		WTRiASObject Obj;
		
			if (!Map.IsValid() || S_OK != Map -> GetObject (static_cast<INT_PTR>(i+1), Obj.ppu())) {
			// jetzt wirklich neu erzeugen und fertig initialisieren
				Obj = WTRiASObject(CLSID_TRiASHPObject);

			// fertig initialisieren
				THROW_FAILED_HRESULT(WPersistStreamInit(Obj) -> InitNew());
				THROW_FAILED_HRESULT(Obj -> put_Application(App));
				THROW_FAILED_HRESULT(Obj -> put_Parent(BaseObjs));

			// Typ etc. setzen
			wchar_t cbBuffer[64];
			CComBSTR bstrName (_ltow (i, cbBuffer, 10));

				THROW_FAILED_HRESULT(Obj -> put_Type (rgType));
				THROW_FAILED_HRESULT(Obj -> put_Name (bstrName));

			// an dem erzeugten Objekt unsere Nummer (cursor) speichern
				THROW_FAILED_HRESULT(SetPropertyBy (Obj, g_cbObjectCursor, CComVariant(i+1), true));
			}

		// das neu instantiierte Objekt zu dieser Objektklasse hinzufügen
			THROW_FAILED_HRESULT(BaseObjs -> _Add (Obj, VARIANT_TRUE));
		}

	// Objekte sind jetzt initialisiert
		SetType (m_rgInitState, INITSTATE_ObjectsInitialized);

	// Features initialisieren
		THROW_FAILED_HRESULT(SetupFeatures (SETUPFEATURESMODE_Force));

	} COM_CATCH;
	return S_OK;
}

STDMETHODIMP CTRiASHPObjects::SetupFeatures(SETUPFEATURESMODE rgMode)
{
	ERROR_EXPR_TRUE(!m_fIsInitialized, E_UNEXPECTED);

// unterstützte Attribute mit Objektmenge assoziieren
	if (!m_fHasFeatures || (rgMode & SETUPFEATURESMODE_Force)) {
		COM_TRY {
		WTRiASFeatures Feats (CLSID_TRiASHPFeatures);

			THROW_FAILED_HRESULT(WTRiASObjects(m_BaseUnk) -> put_Features (Feats))
			THROW_FAILED_HRESULT(Feats -> Refresh());	// ruft CTRiASHPFeatures::SetupFeatures()
			m_fHasFeatures = true;

		} COM_CATCH;
	}

// existierende Geometrien mit dieser Objektklasse assoziieren
	if (!m_fHasGeoFeatures || (rgMode & SETUPFEATURESMODE_Force)) {
		COM_TRY {
		WTRiASFeatures GeoFeats (CLSID_TRiASHPGeoFeatures);

			THROW_FAILED_HRESULT(WTRiASObjects(m_BaseUnk) -> put_GeometryFeatures (GeoFeats))
			THROW_FAILED_HRESULT(GeoFeats -> Refresh());	// ruft CTRiASHPGeoFeatures::SetupFeatures()
			m_fHasGeoFeatures = true;

		} COM_CATCH;
	}
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Ein neues Objekt soll erzeugt werden
STDMETHODIMP CTRiASHPObjects::OnCreate (BSTR Name, BSTR Type, OBJECTTYPE rgType, ITRiASObject **ppIObj)
{
#if defined(_READWRITE)
	CHECKOUTPOINTER(ppIObj);
	COM_TRY {
	// jetzt wirklich erzeugen
	CIID ClsId (Type, CIID::INITCIID_InitFromProgId);

		if (!ClsId)	ClsId = CLSID_TRiASHPObject;	// default ClsId
	
	WTRiASObject Obj (ClsId);

#pragma TODO("Neues Objekt entsprechend Typ (rgType) initialisieren.")

		THROW_FAILED_HRESULT(Obj -> put_Name(Name));

	// wenn Feature bereits zu dieser Attributmenge gehört, dann liefert _Add den Wert S_FALSE
		THROW_FAILED_HRESULT(WTRiASObjects(m_BaseUnk) -> _Add (Obj, VARIANT_TRUE));
		*ppIObj = Obj.detach();

	} COM_CATCH;
	return S_OK;
#else
	return TRIASDB_E_OBJECTSNOTUPDATABLE;
#endif // defined(_READWRITE)
}

/////////////////////////////////////////////////////////////////////////////
// Irgend was wurde modifiziert
STDMETHODIMP CTRiASHPObjects::OnChanging(CHANGEDOBJECTS rgWhat, VARIANT vNewValue, VARIANT_BOOL *pDisAllow)
{
	CHECKOUTPOINTER(pDisAllow);

	switch(rgWhat) {
	case CHANGEDOBJECTS_Name:
	case CHANGEDOBJECTS_Description:
	case CHANGEDOBJECTS_OKS:
	case CHANGEDOBJECTS_Handle:
		*pDisAllow = VARIANT_FALSE;		// immer einverstanden sein
		return S_OK;

	case CHANGEDOBJECTS_Types:
	case CHANGEDOBJECTS_ROMode:
		*pDisAllow = VARIANT_TRUE;		// verhindert Modifikation
		return TRIASDB_E_DATABASENOTUPDATABLE;

	default:
		break;
	}
	return E_INVALIDARG;
}

/////////////////////////////////////////////////////////////////////////////
// Irgend was wurde modifiziert
STDMETHODIMP CTRiASHPObjects::OnChanged(CHANGEDOBJECTS rgWhat, VARIANT vOldValue)
{
	switch(rgWhat) {
	case CHANGEDOBJECTS_Name:
		return OnChangedName(vOldValue);

	case CHANGEDOBJECTS_Description:
		return OnChangedDescription(vOldValue);

	case CHANGEDOBJECTS_OKS:
		return OnChangedOKS(vOldValue);

	case CHANGEDOBJECTS_Handle:
		return OnChangedHandle(vOldValue);

	case CHANGEDOBJECTS_Types:
		return OnChangedTypes(vOldValue);

	case CHANGEDOBJECTS_ROMode:
		return OnChangedROMode(vOldValue);

	default:
		break;
	}
	return E_INVALIDARG;
}

/////////////////////////////////////////////////////////////////////////////
// Ein Objekt soll gelöscht werden
STDMETHODIMP CTRiASHPObjects::OnDelete (INT_PTR hObj)
{
#if defined(_READWRITE)
#pragma TODO("Gegebenenfalls Objekt aus Datenquelle löschen.")

	// S_OK:	Objekt wurde gelöscht
	// S_FALSE: das Objekt soll sich selbst löschen (geschieht nicht hier)
	// ansonsten Fehlercode
	return S_FALSE;
#else
	return TRIASDB_E_OBJECTSNOTUPDATABLE;
#endif // defined(_READWRITE)
}

/////////////////////////////////////////////////////////////////////////////
// Ein Objekt soll zu dieser Objektmenge hinzugefügt werden
STDMETHODIMP CTRiASHPObjects::OnAdd (ITRiASObject *pIObj, CLASSIFYMODE rgMode)
{
	if (CLASSIFYMODE_DoNotClassify == rgMode)
		return S_OK;	// nicht umklassifizieren/Rekursion verhindern

#if defined(_READWRITE)
#pragma TODO("Objekt zu dieser Objektklasse hinzufügen und evtl. aus alter Objektklasse entfernen (s. OnRemove).")

	// S_OK:	  erfolgreich dieser Objektklasse zugeordnet
	// E_NOTIMPL: Objekt muß in neue Objektklasse umkopiert werden (geschieht nicht hier)
	return S_OK;
#else
	return TRIASDB_E_OBJECTSNOTUPDATABLE;
#endif // defined(_READWRITE)
}

// Ein Objekt soll aus dieser Objektmenge entfernt werden
STDMETHODIMP CTRiASHPObjects::OnRemove (ITRiASObject *pIObj)
{
#if defined(_READWRITE)
#pragma TODO("Gegebenenfalls Objekt aus dieser Objektklasse entfernen (s. OnAdd).")

	// S_OK:	erfolgreich entfernt
	// S_FALSE:	wird in 'OnAdd' der neuen Objektklasse zugeordnet und aus alter Objektklasse entfernt
	// ansonsten Fehlercode
	return S_FALSE;
#else
	return TRIASDB_E_OBJECTSNOTUPDATABLE;
#endif // defined(_READWRITE)
}

// Eine Zugriffsnummer eines Attributes kann an dieser Stelle auf ein konkretes
// Attribut dieser Objektklasse gemappt werden
STDMETHODIMP CTRiASHPObjects::MapFeatureHandle (VARIANT vNameOrHandle, VARIANT *pvNewNameOrHandle)
{
	// default: nicht verändern
	return CComVariant(vNameOrHandle).Detach (pvNewNameOrHandle);
}

// Objekt wird logisch freigegeben
STDMETHODIMP CTRiASHPObjects::OnFinalRelease()
{
	COM_TRY {
	WDispatch BaseUnk(m_BaseUnk);

	// Cursor für Objects-Objektes
		THROW_FAILED_HRESULT(DelPropertyBy (BaseUnk, g_cbObjectsCursor));

	// Zuordnung ObjectCursor --> pIObjects
		THROW_FAILED_HRESULT(DelPropertyBy (BaseUnk, g_cbObjectMap));

	// MetaDataMap für Feature-Beschreibungsdaten
		THROW_FAILED_HRESULT(DelPropertyBy (BaseUnk, g_cbMetaDataMap));

	} COM_CATCH;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Helperfunktionen
HRESULT CTRiASHPObjects::OnChangedName(VARIANT vOldValue)
{
	COM_TRY {
	// wenns die Erstinistialisierung ist, dann nichts machen
	CComVariant vOldVal;

		THROW_FAILED_HRESULT(vOldVal.ChangeType(VT_BSTR, &vOldValue));
		if (NULL == V_BSTR(&vOldVal) || 0 == ::SysStringLen(V_BSTR(&vOldVal)))
			return S_OK;

	// neuen Namen vom Bezugsobjekt besorgen
	CComBSTR bstrName, bstrOKS;
	WTRiASObjects BaseObjs;

		THROW_FAILED_HRESULT(m_BaseUnk -> QueryInterface (BaseObjs.ppi()));
		THROW_FAILED_HRESULT(BaseObjs -> get_Name (CLEARED(&bstrName)));
		THROW_FAILED_HRESULT(BaseObjs -> get_OKS (CLEARED(&bstrOKS)));
		
	// in Objektklassenbeschreibungstabelle Namen modifizieren
	WTRiASDatabase Dbase;

		THROW_FAILED_HRESULT(FindSpecificParent (m_BaseUnk, Dbase.ppi()));
	
	WTRiASMDSMap ObjsTable (GetPropertyFrom (Dbase, g_cbMetaDataMap, (IDispatch *)NULL), false);
	CComBSTR bstrDesc, bstrTable;
	CComVariant vHandle;
	
		_ASSERTE(ObjsTable.IsValid());
		ObjsTable -> GetAt (bstrOKS, &bstrTable, NULL, &bstrDesc, &vHandle);

	// korrigierten Eintrag in Tabelle ablegen
		if (!bstrTable || 0 == bstrTable.Length())
			bstrTable = bstrName;
		THROW_FAILED_HRESULT(ObjsTable -> SetAt (bstrOKS, bstrTable, bstrName, bstrDesc, vHandle));
		m_fIsDirty = true;

	} COM_CATCH;
	return S_OK;
}

HRESULT CTRiASHPObjects::OnChangedDescription(VARIANT vOldValue)
{
	COM_TRY {
	// neue Beschreibung vom Bezugsobjekt besorgen
	CComBSTR bstrOKS, bstrDesc;
	WTRiASObjects BaseObjs;

		THROW_FAILED_HRESULT(m_BaseUnk -> QueryInterface (BaseObjs.ppi()));
		THROW_FAILED_HRESULT(BaseObjs -> get_Description(CLEARED(&bstrDesc)));
		THROW_FAILED_HRESULT(BaseObjs -> get_OKS (CLEARED(&bstrOKS)));

	// in Objektklassenbeschreibungstabelle Beschreibung modifizieren
	WTRiASDatabase Dbase;

		THROW_FAILED_HRESULT(FindSpecificParent (m_BaseUnk, Dbase.ppi()));
	
	WTRiASMDSMap ObjsTable (GetPropertyFrom (Dbase, g_cbMetaDataMap, (IDispatch *)NULL), false);
	CComBSTR bstrName, bstrTable;
	CComVariant vHandle;
	
		_ASSERTE(ObjsTable.IsValid());
		ObjsTable -> GetAt (bstrOKS, &bstrTable, &bstrName, NULL, &vHandle); 

	// korrigierten Eintrag in Tabelle ablegen
		if (!bstrTable || 0 == bstrTable.Length())
			bstrTable = bstrName;
		THROW_FAILED_HRESULT(ObjsTable -> SetAt (bstrOKS, bstrTable, bstrName, bstrDesc, vHandle));
		m_fIsDirty = true;

	} COM_CATCH;
	return S_OK;
}

HRESULT CTRiASHPObjects::OnChangedOKS(VARIANT vOldValue)
{
	COM_TRY {
	// neuen Objektklassenschlüssel vom Bezugsobjekt besorgen
	CComBSTR bstrOKS;
	WTRiASObjects BaseObjs;
	CComVariant vOldOks;
	
		THROW_FAILED_HRESULT(m_BaseUnk -> QueryInterface (BaseObjs.ppi()));
		THROW_FAILED_HRESULT(BaseObjs -> get_OKS(CLEARED(&bstrOKS)));
		THROW_FAILED_HRESULT(vOldOks.ChangeType (VT_BSTR, &vOldValue));

	// in Objektklassenbeschreibungstabelle OKS modifizieren
	WTRiASDatabase Dbase;

		THROW_FAILED_HRESULT(FindSpecificParent (m_BaseUnk, Dbase.ppi()));
	
	WTRiASMDSMap ObjsTable (GetPropertyFrom (Dbase, g_cbMetaDataMap, (IDispatch *)NULL), false);
	CComBSTR bstrDesc, bstrTable, bstrName;
	CComVariant vHandle;
	
		_ASSERTE(ObjsTable.IsValid());
		if (SUCCEEDED(ObjsTable -> GetAt (V_BSTR(&vOldOks), &bstrTable, &bstrName, &bstrDesc, &vHandle)))
		{
			THROW_FAILED_HRESULT(ObjsTable -> RemoveAt (V_BSTR(&vOldOks)));
		}

	// korrigierten Eintrag in Tabelle ablegen
		if (!bstrTable || 0 == bstrTable.Length())
			bstrTable = bstrName;
		THROW_FAILED_HRESULT(ObjsTable -> SetAt (bstrOKS, bstrTable, bstrName, bstrDesc, vHandle));
		m_fIsDirty = true;

	} COM_CATCH;
	return S_OK;
}

HRESULT CTRiASHPObjects::OnChangedHandle(VARIANT vOldValue)
{
	COM_TRY {
	// neue Beschreibung vom Bezugsobjekt besorgen
	CComBSTR bstrOKS;
	WTRiASObjects BaseObjs;
	INT_PTR hObjs = NULL;
	
		THROW_FAILED_HRESULT(m_BaseUnk -> QueryInterface (BaseObjs.ppi()));
		THROW_FAILED_HRESULT(BaseObjs -> get_Handle(&hObjs));			// unbedingt _vor_ get_OKS
		THROW_FAILED_HRESULT(BaseObjs -> get_OKS (CLEARED(&bstrOKS)));

	// in Objektklassenbeschreibungstabelle Beschreibung modifizieren
	WTRiASDatabase Dbase;

		THROW_FAILED_HRESULT(FindSpecificParent (m_BaseUnk, Dbase.ppi()));
	
	WTRiASMDSMap ObjsTable (GetPropertyFrom (Dbase, g_cbMetaDataMap, (IDispatch *)NULL), false);
	CComBSTR bstrName, bstrTable, bstrDesc;
	CComVariant vHandle;
	
		_ASSERTE(ObjsTable.IsValid());
		ObjsTable -> GetAt (bstrOKS, &bstrTable, &bstrName, &bstrDesc, NULL); 

	// korrigierten Eintrag in Tabelle ablegen
		if (!bstrName || 0 == bstrName.Length()) {
		// den Namen geben lassen, um einen sinnvollen MapEintrag zusammen zu bekommen
			THROW_FAILED_HRESULT(BaseObjs -> get_Name(&bstrName));
		}
		if (!bstrTable || 0 == bstrTable.Length())
			bstrTable = bstrName;
		THROW_FAILED_HRESULT(ObjsTable -> SetAt (bstrOKS, bstrTable, bstrName, bstrDesc, CComVariant(hObjs, VT_I4)));
		m_fIsDirty = true;

	} COM_CATCH;
	return S_OK;
}

HRESULT CTRiASHPObjects::OnChangedTypes(VARIANT vOldValue)
{
	return TRIASDB_E_DATABASENOTUPDATABLE;
}

HRESULT CTRiASHPObjects::OnChangedROMode(VARIANT vOldValue)
{
	return TRIASDB_E_DATABASENOTUPDATABLE;
}

///////////////////////////////////////////////////////////////////////////////
// ITRiASSearchObjects
HRESULT CTRiASHPObjects::ConsiderSearch (BSTR bstrCommand, SAFEARRAY *pParams)
{
	if (wcscmp (bstrCommand, SEARCHCOMMAND_IntersectsWindow)) {
	// alle sonstigen Recherchen der Basisklasse überlassen
	WTRiASSearchObjects BaseObjs;

		RETURN_FAILED_HRESULT(m_BaseUnk -> QueryInterface (BaseObjs.ppi()));
		return BaseObjs -> ConsiderSearch (bstrCommand, pParams);
	}
	return S_OK;	// Geometrie- Recherchen werden hier unterstützt
}

HRESULT CTRiASHPObjects::SearchObjects (BSTR bstrCommand, ITRiASObjects *pIObjs, SAFEARRAY *pParams)
{
	if (wcscmp (bstrCommand, SEARCHCOMMAND_IntersectsWindow)) {
	// alle sonstigen Recherchen der Basisklasse überlassen
	WTRiASSearchObjects BaseObjs;

		RETURN_FAILED_HRESULT(m_BaseUnk -> QueryInterface (BaseObjs.ppi()));
		return BaseObjs -> SearchObjects (bstrCommand, pIObjs, pParams);
	}

// Geometrierecherchen hier selbst ausführen
	COM_TRY {
	// dazu Recherche an die Geometrie-Objekteigenschaft delegieren
	WTRiASFeature Feat;

		THROW_FAILED_HRESULT(GetSearchFeature(pParams, Feat.ppi()));
		_ASSERTE(ObjectIsActually (Feat, (CTRiASHPGeoFeature *)NULL));
		THROW_FAILED_HRESULT(WTRiASSearchObjects(Feat) -> SearchObjects (bstrCommand, pIObjs, pParams));

	} COM_CATCH;
	return S_OK;
}

// Eine bestimmte Objekteigenschaft liefern
HRESULT CTRiASHPObjects::GetSearchFeature (SAFEARRAY *pParams, ITRiASFeature **ppIFeat)
{
	_ASSERTE(NULL != ppIFeat);
	COM_TRY {
	// Objekteigenschaft aus Parameterfeld herauslösen
	CSafeArray sa(VT_VARIANT);

		if (NULL == pParams || !sa.Attach (pParams, true)) 
			return E_INVALIDARG;

	CSafeArrayLock<VARIANT> lock(sa);
	WTRiASFeature Feat;

		_ASSERTE(lock.Size() > 1);				// FeatureName/Feature muß gegeben sein
		if (VT_DISPATCH == V_VT(&lock[1])) {
		// Objekteigenschaft ist direkt gegeben
			Feat = WTRiASFeature (V_DISPATCH(&lock[1]));
		} 
		else {
		// Objekteigenschaft auf üblichem Wege besorgen (Name muß gegeben sein)
			_ASSERTE(V_ISBSTR(&lock[1]));

		WTRiASObjects BaseObjs;

			RETURN_FAILED_HRESULT(m_BaseUnk ->QueryInterface(BaseObjs.ppi()));
			RETURN_FAILED_HRESULT(BaseObjs -> get_GeometryFeature (lock[1], VARIANT_FALSE, CComBSTR(g_cbNil), Feat.ppi()));
		}
		*ppIFeat = Feat.detach();

	} COM_CATCH;
	return S_OK;
}

HRESULT CTRiASHPObjects::ConstraintObjects (ITRiASObjects *pIObjs)
{
WTRiASSearchObjects BaseObjs;

	RETURN_FAILED_HRESULT(m_BaseUnk -> QueryInterface (BaseObjs.ppi()));
	return BaseObjs -> ConstraintObjects (pIObjs);
}


