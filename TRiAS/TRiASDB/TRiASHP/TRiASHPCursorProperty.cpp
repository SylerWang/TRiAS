// $Header: $
// Copyright© 1998-2000 TRiAS GmbH Potsdam, All rights reserved
// Created: 10.05.2000 19:36:40 
//
// This file was generated by the TRiASDB Data Server Wizard V1.02.086 (#HK000510)
//
// @doc
// @module TRiASHPCursorProperty.cpp | Implementation of the <c CTRiASHPCursorProperty> class

#include "stdafx.h"

#include "Strings.h"

#include "TRiASHP.h"
#include "TRiASHPCursorProperty.h"

#if defined(_DEBUG)
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// Die vorliegende Klasse implementiert eine spezielle Property 'ObjectCursor',
// 'ObjectsCursor' oder 'FeatureCursor' eines Objektes (CTRiASHPObject, 
// CTRiASHPObjects bzw. CTRiASHPFeature) die dafür sorgt, daß in 
// dem Moment, wenn ein Cursor für ein Objekt definiert bzw. freigegeben wird, 
// dieses Objekt mit seinem Cursor in einer speziellen Tabelle gespeichert bzw. 
// freigegeben wird. 
// Die Zuordnungstabelle 'ObjectCursor' wird für die Recherchen benötigt, 
// um den gefundenen Objekten in der Datenbank (Cursor) die zugeordneten C++ Objekte 
// (CTRiASHPObject) zuordnen zu können.
// Weiterhin können diese Zuordnungstabellen verwendet werden, um jeweils
// genau ein C++ Objekt für jeweils ein Datenbankobjekt zu erzeugen.
//
// Die Tabellen sind im vorliegenden Beispiel als Property ('ObjectMap', 'ObjectsMap'
// bzw. 'FeatureMap') an der zugehörigen Datenbank (CTRiASHPDatabase) abgelegt. 
//
// Für andere Datenquellen ist es u.U. notwendig diese Tabellen z.B. in Bezug 
// zur Objektklasse (CTRiASHPObjects) oder evtl. zum zugehörigen Objekt 
// (CTRiASHPObject) zu speichern. Die entsprechende Modifikation ist dann von
// Hand auszuführen.
// 
// Die Verwendung einer GenObjectMap (s. TRiASHPDatabase.h: BEGIN_PROPERTYSUPPORT_MAP)
// beschränkt den CursorTyp auf VT_I4.

/////////////////////////////////////////////////////////////////////////////
// SmartIF's
DefineSmartInterface(TRiASObjectHandleMap);
DefineSmartInterface(TRiASDatabase);
DefineSmartInterface(Dispatch);

/////////////////////////////////////////////////////////////////////////////
// CTRiASHPCursorProperty

void CTRiASHPCursorProperty::FinalRelease()
{
	ResetCursor();		// Cursor wieder freigeben
}

/////////////////////////////////////////////////////////////////////////////
// PropertySupport
// Callback-interface, welches für die Konkretheit der Properties zuständig ist

STDMETHODIMP CTRiASHPCursorProperty::PutValue (BSTR Name, VARIANT Value)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	_ASSERTE(NULL != Name);
	_ASSERTE(!wcscmp (Name, m_bstrName));		// muß voreingestellter Name sein

	RETURN_FAILED_HRESULT(m_Value.Copy(&Value));	// Wert setzen
	RETURN_FAILED_HRESULT(SetCursor());				// Zuordnung in Map setzen bzw. entfernen
	return S_OK;
}

STDMETHODIMP CTRiASHPCursorProperty::GetValue (BSTR Name, VARIANT *pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	
	_ASSERTE(NULL != Name || NULL != pVal);
	_ASSERTE(!wcscmp (Name, m_bstrName));		// muß voreingestellter Name sein
	if (NULL == pVal) return E_POINTER;

CComVariant val (m_Value);

	RETURN_FAILED_HRESULT(val.Detach (pVal));
	return S_OK;
}

STDMETHODIMP CTRiASHPCursorProperty::PutType (BSTR Name, PROPERTY_TYPE newVla)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	_ASSERTE(NULL != Name);
	_ASSERTE(!wcscmp (Name, m_bstrName));		// muß voreingestellter Name sein

	return E_NOTIMPL;
}

STDMETHODIMP CTRiASHPCursorProperty::GetType (BSTR Name, PROPERTY_TYPE *pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	_ASSERTE(NULL != Name || NULL != pVal);
	_ASSERTE(!wcscmp (Name, m_bstrName));		// muß voreingestellter Name sein

	if (NULL == pVal) return E_POINTER;

	*pVal = PROPERTY_TYPE(PROPERTY_TYPE_Dynamic);
	return S_OK;
}

STDMETHODIMP CTRiASHPCursorProperty::PutValueAndType(BSTR Name, VARIANT Value, PROPERTY_TYPE Type)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	_ASSERTE(NULL != Name);
	_ASSERTE(!wcscmp (Name, m_bstrName));		// muß voreingestellter Name sein

// Wert setzen
	RETURN_FAILED_HRESULT(m_Value.Copy(&Value));
	return S_OK;		// Typ wird nicht bearbeitet
}

STDMETHODIMP CTRiASHPCursorProperty::GetValueAndType(BSTR Name, VARIANT * pVal, PROPERTY_TYPE * pType)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	_ASSERTE(NULL != Name || NULL != pVal || NULL != pType);
	_ASSERTE(!wcscmp (Name, m_bstrName));		// muß voreingestellter Name sein

	if (NULL != pVal) return E_POINTER;
	if (NULL != pType) return E_POINTER;

CComVariant val (m_Value);

	RETURN_FAILED_HRESULT(val.Detach (pVal));
	*pType = PROPERTY_TYPE(PROPERTY_TYPE_Dynamic);
	return S_OK;
}

STDMETHODIMP CTRiASHPCursorProperty::Refresh(BSTR bstrName)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////////
// IObjectWithSite
STDMETHODIMP CTRiASHPCursorProperty::SetSite (IUnknown *pISite)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	if (NULL != pISite)
		m_Obj = pISite;
	else {
		ResetCursor();
		m_Obj.Assign(NULL);
	}
	return S_OK;
}

STDMETHODIMP CTRiASHPCursorProperty::GetSite (REFIID riid, void **ppvSite)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	if (!m_Obj) 
		return TRIASDB_E_PROPERTY_NOT_INITIALIZED;
	return m_Obj -> QueryInterface (riid, ppvSite);
}

// IObjectWithName
STDMETHODIMP CTRiASHPCursorProperty::put_Name (BSTR bstrName)
{
	m_bstrName = bstrName;
	return S_OK;
}

STDMETHODIMP CTRiASHPCursorProperty::get_Name (BSTR *pbstrName)
{
	if (NULL == pbstrName)
		return E_POINTER;

	m_bstrName.CopyTo(pbstrName);
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// Helper
namespace {
	typedef struct tagCURSORNAMES {
		const wchar_t *m_pCursorName;
		const wchar_t *m_pMapName;
		const IID *m_pParentIID;
	} CURSORNAMES;

	const CURSORNAMES s_cbNames[] = {
		{ g_cbObjectCursor, g_cbObjectMap, &IID_ITRiASObjects },	// cursor eindeutig innerhalb Objektklasse
		{ g_cbObjectsCursor, g_cbObjectsMap, &IID_ITRiASDatabase },	// cursor eindeutig innerhalb Datenquelle
		{ g_cbFeatureCursor, g_cbFeatureMap, &IID_ITRiASDatabase },
		{ NULL, NULL },
	};
}

HRESULT CTRiASHPCursorProperty::GetCursorMap (ITRiASObjectHandleMap **ppIMap)
{
	if (!m_Obj.IsValid())
		return TRIASDB_E_PROPERTY_NOT_INITIALIZED;

	COM_TRY {
	// geht davon aus, daß die Map am CTRiASHPDatabase/CTRiASHPObjects -Objekt als Property abgelegt ist
	WDispatch Parent;
	const CURSORNAMES *pT = s_cbNames;		// Namen der Map aus Propertynamen ableiten

		for (/**/; NULL != pT -> m_pCursorName; ++pT) {
			if (!wcscmp (pT -> m_pCursorName, m_bstrName)) {
				THROW_FAILED_HRESULT(FindSpecificParent (m_Obj, *(pT -> m_pParentIID), Parent.ppv()));
				break;		// Eintrag gefunden
			}
		}
		if (NULL == pT -> m_pCursorName || !Parent.IsValid())
			THROW_FAILED_HRESULT(E_UNEXPECTED);		// muß wiedergefunden werden
	
	// Map vom Bezugsobjekt holen
	WTRiASObjectHandleMap Map (GetPropertyFrom (Parent, pT -> m_pMapName, (IDispatch *)NULL), false);	// GetProperty liefert AddRef'ed ab

		if (!Map.IsValid())
			THROW_FAILED_HRESULT(E_UNEXPECTED);

		*ppIMap = Map.detach();

	} COM_CATCH;
	return S_OK;
}

HRESULT CTRiASHPCursorProperty::SetCursor()
{
	COM_TRY {
	WTRiASObjectHandleMap Map;
	CComVariant vVal;
	HRESULT hr = S_OK;

		THROW_FAILED_HRESULT(GetCursorMap (Map.ppi()));
		THROW_FAILED_HRESULT(vVal.ChangeType (VT_I4, &m_Value));
		Map -> RemoveObject (V_I4(&vVal), OBJECTMAPMODE_RemoveAllReferences);

	OBJECTMAPMODE rgMode = OBJECTMAPMODE(OBJECTMAPMODE_CreateObjectHandle|OBJECTMAPMODE_DoNotRegisterNativeHandle);

		THROW_FAILED_HRESULT(hr = Map -> GetObjectHandle (vtMissing, m_Obj, rgMode, (INT_PTR *)&V_I4(&vVal)));
		_ASSERTE(S_OK == hr);		// Handle darf sich nicht geändert haben

	} COM_CATCH;
	return S_OK;
}

HRESULT CTRiASHPCursorProperty::ResetCursor()
{
	if (!m_Obj)
		return S_FALSE;		// nicht das erste mal

	COM_TRY {
	WTRiASObjectHandleMap Map;
	CComVariant vVal;

		THROW_FAILED_HRESULT(GetCursorMap (Map.ppi()));
		THROW_FAILED_HRESULT(vVal.ChangeType (VT_I4, &m_Value));
		THROW_FAILED_HRESULT(Map -> RemoveObject (V_I4(&vVal), OBJECTMAPMODE_RemoveAllReferences));

	} COM_CATCH;
	return S_OK;
}
