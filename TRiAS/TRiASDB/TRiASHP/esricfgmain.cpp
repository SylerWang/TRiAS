
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1990-94, Compiler Resources, Inc.
//
//  FILENAME:             yy_main
//
//  FILE DESCRIPTION:     main routine which creates the objects and calls
//                        the lexer and parser
//
//                        *******************   NOTE   ******************* 
//                        This is the default main() which parses from an
//                        input file object using the command line class
//                        with one lexer and parser for the default entry
//                        point for a single grammar.
//
//                        You may wish to vary the object creation to fit
//                        your specific application by differing your 
//                        method of input, multiple lexers and parsers, 
//                        alternate entry points, etc.  Many examples are
//                        provided in the tutorials -- see the TUTORS 
//                        sub-directory and the Yacc++ Developer's Guide
//                        for a complete list.
//                        ************************************************ 
//
//  MODIFICATION HISTORY:
//  
//    11/23/93   bz/cc  updated for Revision 2.0 native C++ lexer and parser
//                      object creation and deletion.  Also, the error
//                      message and syntax assist tables have been moved
//                      to here from the parser and error objects.
//    04/09/93   bz     updated for Revision 2.0 native C++ error stream
//                      object creation and deletion.  Also, yy_err2.h no
//                      longer exists.
//    02/26/93   bz     updated for Revision 2.0 native C++ symbol table
//                      and symbol object creation and deletion.
//    10/30/92   bz     disabled warning 4505 for Microsoft 7.0.
//    08/07/92   bz     removed macros and #ifdefs in C++ only version.
//    03/30/90   bz/cc  coding and final review completed.  
//  
//////////////////////////////////////////////////////////////////////////////

#include "yy_ansi.h"
#include "yy_stdio.h"
#include "yy_bool.h"
#include "yy_cmd.h"
#include "yy_errst.h"
#include "yy_inpfi.h"
#include "esricfgl.h"
#include "esricfgy.h"
#include "yy_sym.h"
#include "yy_trace.h"


//////////////////////////////////////////////////////////////////////////////
//
//  "yy_err.tbl" is the error message table which is automatically 
//  generated by yy_etbl which uses the abstract error message object 
//  in the declaration.  This must be changed into a derived class for 
//  purposes of inclusion.
//
//////////////////////////////////////////////////////////////////////////////

#include "yy_err.tbl"


//////////////////////////////////////////////////////////////////////////////
//
//  "yy_syna.tbl" is the syntax assist message table which is automatically 
//  generated by yy_stbl which uses the abstract error message object 
//  in the declaration.  This must be changed into a derived class for 
//  purposes of inclusion.
//
//  If the grammar does not have syntax assists, there will be no syntax 
//  assist table and a NULL pointer will suffice in its place.
//
//////////////////////////////////////////////////////////////////////////////

#ifdef yy_has_synas_
#include "yy_syna.tbl"
#else
const yy_synamsg_dflt_ptr yy_syna_tbl = NULL;
const int yy_syna_tbl_max_ = 0;
#endif /* yy_has_synas_ */


//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION:   int main(argc, argv);
//
//  main() is the uppermost entry point to your application.  It processes
//  the command line options and lexes and parses the input.
//
//  argc        is the number of command line arguments plus one.
//
//  argv        is an array of strings containing the command line invocation.
//              The first string is the application name the command was 
//              invoked by.  The subsequent strings are the filename and
//              command line options.
//
//  main() returns 1 if parse was unsuccessful -- via yy_err_exit().
//  main() returns 0 if parse was successful.
//
//////////////////////////////////////////////////////////////////////////////

int main(
    int     argc,
    char    *argv[])
{
    int                 code;
    yy_cmd_dflt_ptr     yy_cmd;
    yy_err_dflt_ptr     yy_err;
    yy_inp_file_ptr     yy_inp;
    yy_symtab_dflt_ptr  yy_symtab;
    yy_lex_dflt_ptr     yy_lexer;
    yy_psr_dflt_ptr     yy_parser;

//  create an error object, the default is to report errors to a C++ stream

    yy_err = new yy_err_dflt_obj(
        yy_err_tbl, yy_err_tbl_max_, 
        yy_syna_tbl, yy_syna_tbl_max_,
        &cout
        );

//  create an input object which processes input from a file

    yy_inp = new yy_inp_file_obj(yy_err);

//  create a command line object

    yy_cmd = new yy_cmd_dflt_obj(yy_inp, yy_err);

//  create a symbol table object, the default is hashed symbol lookups

    yy_symtab = new yy_symtab_dflt_obj;

//  create a lexer object

    yy_lexer = new yy_lex_dflt_obj(yy_inp, yy_symtab, 
                        yy_lex_obj::yy_lex_dflt_class_);

//  create a parser object

    yy_parser = new yy_psr_dflt_obj(yy_lexer, 
                        yy_psr_obj::yy_psr_dflt_class_, 
                        yy_psr_obj::yy_psr_dflt_start_);

//  process the command line options and open the input file

    yy_cmd -> yy_cmd_line(argc, argv);

//  lex and parse the input

    code = yy_psr(yy_parser);

#if yy_trace_after_error_ <= yy_trace_
    if (code == 0) {
        yy_err -> yy_err_puts("MAIN:  successfully parsed!\n");
        }
    else if (code == 1) {
        yy_err -> yy_err_puts("MAIN:  unrecovered error during parse!\n");
        }
    else {
        yy_err -> yy_err_printf(
            "MAIN:  unexpected code (%d) returned from yy_psr?\n", code);
        }
#endif /*  yy_trace_after_error_ <= yy_trace_ */

//  close the input object

    yy_inp -> yy_inp_close(yy_true);

//  delete the objects in reverse order of creation

    delete yy_parser;

    delete yy_lexer;

    delete yy_symtab;

    delete yy_cmd;

    delete yy_inp;

//  call the exit status routine before deleting the error object

    yy_err_exit();

    delete yy_err;

    return(0);

}   // main
