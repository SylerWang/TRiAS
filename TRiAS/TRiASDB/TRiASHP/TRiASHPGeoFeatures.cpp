// $Header: $
// Copyright© 1998-2000 TRiAS GmbH Potsdam, All rights reserved
// Created: 10.05.2000 19:36:40 
//
// This file was generated by the TRiASDB Data Server Wizard V1.02.086 (#HK000510)
//
// @doc
// @module TRiASHPGeoFeatures.cpp | Implementation of the <c CTRiASHPGeoFeatures> class

#include "stdafx.h"

#include "Strings.h"

#include "TRiASHP.h"
#include "TRiASHPGeoFeatures.h"

#if defined(_DEBUG)
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// SmartIF's
DefineSmartInterface(Dispatch);
DefineSmartInterface(PersistStreamInit);

DefineSmartInterface(TRiASObjects);
DefineSmartInterface(TRiASFeature);
DefineSmartInterface(TRiASDatabase);
DefineSmartInterface(TRiASObjectHandleMap);

/////////////////////////////////////////////////////////////////////////////
// CTRiASHPGeoFeatures

STDMETHODIMP CTRiASHPGeoFeatures::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITRiASFeatures,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// ITRiASFeaturesCallback

STDMETHODIMP CTRiASHPGeoFeatures::get_DefaultType (BSTR *pbstrType)
{
	CHECKOUTPOINTER(pbstrType);

CIID Guid (CLSID_TRiASSimpleGeoFeature);		// DefaultType der _Elemente_ !
CComBSTR bstrType (Guid.ProgID().c_str());

	*pbstrType = bstrType.Detach();
	return S_OK;
}

// eine neue Objekteigenschaft soll erzeugt werden
STDMETHODIMP CTRiASHPGeoFeatures::OnCreate (VARIANT NameOrHandle, BSTR Type, FEATURETYPE rgType, ITRiASFeature **ppIFeat)
{
// wird z.Zt. nicht gerufen (TRiAS unterstützt lediglich eine Geometrie je Objektklasse)
	_ASSERTE(FALSE);
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
//
STDMETHODIMP CTRiASHPGeoFeatures::OnChanging(CHANGEDFEATURES rgWhat, VARIANT vNewValue, VARIANT_BOOL *pDisAllow)
{
	CHECKOUTPOINTER(pDisAllow);

#if defined(_READWRITE)
	*pDisAllow = VARIANT_FALSE;		// immer einverstanden sein
	return S_OK;
#else
	*pDisAllow = VARIANT_TRUE;		// nie einverstanden sein
	return TRIASDB_E_OBJECTSNOTUPDATABLE;
#endif
}

// Irgend was wurde modifiziert
STDMETHODIMP CTRiASHPGeoFeatures::OnChanged(CHANGEDFEATURES rgWhat, VARIANT vOldValue)
{
	return E_NOTIMPL;
}

// Objekt wird logisch freigegeben
STDMETHODIMP CTRiASHPGeoFeatures::OnFinalRelease()
{
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Ein Objekt soll gelöscht werden
STDMETHODIMP CTRiASHPGeoFeatures::OnDelete (VARIANT vWhich)
{
// wird z.Zt. nicht gerufen (TRiAS unterstützt lediglich eine Geometrie je Objektklasse)
	_ASSERTE(FALSE);
	return E_NOTIMPL;
}

STDMETHODIMP CTRiASHPGeoFeatures::SetupFeatures(IDispatch *pIParent, SETUPFEATURESMODE rgMode)
{
// Der Parameter pIParent enthält einen Zeiger auf das Bezugsobjekt (Objektklasse) für 
// welches die Objekteigenschaften erzeugt werden sollen
	COM_TRY {
	// zugehörigen ShapeLayer wiederfinden
	WTRiASFeatures BaseFeats;
	WTRiASObjects Objs;

		THROW_FAILED_HRESULT(m_BaseUnk -> QueryInterface (BaseFeats.ppi()));
		THROW_FAILED_HRESULT(pIParent -> QueryInterface (Objs.ppi()));

	CShapeLayer *pLayer = reinterpret_cast<CShapeLayer *>(GetPropertyFrom (Objs, g_cbObjectsCursor, 0L));

	// zuerst versuchen, dieses Feature in der Map wiederzufinden
	WTRiASDatabase DBase;

		THROW_FAILED_HRESULT(FindSpecificParent (pIParent, DBase.ppi()));

	WTRiASObjectHandleMap Map (GetPropertyFrom (DBase, g_cbFeatureMap, (IDispatch *)NULL), false);
	WTRiASFeature Feat;

		if (!Map.IsValid() || S_OK != Map -> GetObject (reinterpret_cast<INT_PTR>(pLayer -> GetSHPHandle()), Feat.ppu())) {
		// jetzt wirklich neu erzeugen
			Feat = WTRiASFeature(CLSID_TRiASHPGeoFeature);		// Feature erzeugen

			_ASSERTE(NULL != pLayer);

		// fertig initialisieren
			THROW_FAILED_HRESULT(WPersistStreamInit(Feat) -> InitNew());

		// Namen etc. stzen
		FEATURETYPE rgType = (FEATURETYPE)(FEATURETYPE_Object | DATATYPE_FROM_VT(VT_ARRAY|VT_UI1) | FEATURETYPE_IsPrimaryFeature | FEATURETYPE_IsGlobal);

			THROW_FAILED_HRESULT(Feat -> put_Parent (pIParent));
			THROW_FAILED_HRESULT(Feat -> put_Type (rgType));
			THROW_FAILED_HRESULT(Feat -> put_Name (CComBSTR(g_cbGeometry)));
			THROW_FAILED_HRESULT(SetPropertyBy (Feat, g_cbFeatureCursor, CComVariant(reinterpret_cast<INT_PTR>(pLayer -> GetSHPHandle()), VT_I4), true));
		}
		
	// das neu instantiierte/wiedergefundene Attribut zu dieser Attributsammlung hinzufügen
		THROW_FAILED_HRESULT(BaseFeats -> _Add (Feat, VARIANT_TRUE));

	} COM_CATCH;
	return S_OK;
}

