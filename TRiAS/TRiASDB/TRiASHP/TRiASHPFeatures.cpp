// $Header: $
// Copyright© 1998-2000 TRiAS GmbH Potsdam, All rights reserved
// Created: 10.05.2000 19:36:40 
//
// This file was generated by the TRiASDB Data Server Wizard V1.02.086 (#HK000510)
//
// @doc
// @module TRiASHPFeatures.cpp | Implementation of the <c CTRiASHPFeatures> class

#include "stdafx.h"

#include "Strings.h"

#include "TRiASHP.h"
#include "ShapeLayer.h"
#include "TRiASHPFeatures.h"

#if defined(_DEBUG)
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// SmartIF's
DefineSmartInterface(TRiASFeature);
DefineSmartInterface(TRiASFeatures);
DefineSmartInterface(TRiASObject);
DefineSmartInterface(TRiASObjects);
DefineSmartInterface(TRiASDatabase);
DefineSmartInterface(TRiASObjectHandleMap);

DefineSmartInterface(TRiASMDSMap);

DefineSmartInterface(Dispatch);
DefineSmartInterface(PersistStreamInit);

/////////////////////////////////////////////////////////////////////////////
// CTRiASHPFeatures

STDMETHODIMP CTRiASHPFeatures::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITRiASFeatures,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// ITRiASFeaturesCallback

STDMETHODIMP CTRiASHPFeatures::get_DefaultType (BSTR *pbstrType)
{
	CHECKOUTPOINTER(pbstrType);

CIID Guid (CLSID_TRiASHPFeature);			// DefaultType der _Elemente_ (hier Feature)!
CComBSTR bstrType (Guid.ProgID().c_str());

	*pbstrType = bstrType.Detach();
	return S_OK;
}

// eine neue Objekteigenschaft soll erzeugt werden
STDMETHODIMP CTRiASHPFeatures::OnCreate (VARIANT Name, BSTR Type, FEATURETYPE rgType, ITRiASFeature **ppIFeat)
{
#if defined(_READ_WRITE)
	CHECKOUTPOINTER(ppIFeat);
	COM_TRY {
	// jetzt wirklich erzeugen
	CIID ClsId (Type, CIID::INITCIID_InitFromProgId);

		if (!ClsId)	ClsId = CLSID_TRiASHPFeature;	// default ClsId
	
	WTRiASFeature Feat (ClsId);

		THROW_FAILED_HRESULT(WPersistStreamInit(Feat) -> InitNew());

	CComVariant vVal (Name);

		THROW_FAILED_HRESULT(vVal.ChangeType (VT_BSTR));

#pragma TODO("Neue Objekteigenschaft entsprechend Typ (rgType) in 'Feat' erzeugen und initialisieren.")

		THROW_FAILED_HRESULT(Feat -> put_Name(V_BSTR(&vVal)));
		THROW_FAILED_HRESULT(Feat -> put_Type(rgType));

	// wenn Feature bereits zu dieser Attributmenge gehört, dann liefert _Add den Wert S_FALSE
		THROW_FAILED_HRESULT(WTRiASFeatures(m_BaseUnk) -> _Add (Feat, VARIANT_TRUE));
		*ppIFeat = Feat.detach();	// neue Objekteigenschaft liefern

	} COM_CATCH;
	return S_OK;
#else
	return TRIASDB_E_OBJECTSNOTUPDATABLE;
#endif
}

STDMETHODIMP CTRiASHPFeatures::OnChanging(CHANGEDFEATURES rgWhat, VARIANT vNewValue, VARIANT_BOOL *pDisAllow)
{
	CHECKOUTPOINTER(pDisAllow);

#if defined(_READWRITE)
	*pDisAllow = VARIANT_FALSE;		// immer einverstanden sein
	return S_OK;
#else
	*pDisAllow = VARIANT_TRUE;		// nie einverstanden sein
	return TRIASDB_E_OBJECTSNOTUPDATABLE;
#endif
}

// Irgend was wurde modifiziert
STDMETHODIMP CTRiASHPFeatures::OnChanged(CHANGEDFEATURES rgWhat, VARIANT vOldValue)
{
	return S_OK;
}

// Objekt wird logisch freigegeben
STDMETHODIMP CTRiASHPFeatures::OnFinalRelease()
{
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Eine Objekteigenschaftsbeschreibung soll gelöscht werden
STDMETHODIMP CTRiASHPFeatures::OnDelete (VARIANT vWhich)
{
#if defined(_READWRITE)
#pragma TODO("Gegebenenfalls Objekteigenschaft aus Datenquelle löschen.")

	// S_OK:	Objekteigenschaft wurde gelöscht
	// ansonsten Fehlercode
	return S_OK;
#else
	return TRIASDB_E_OBJECTSNOTUPDATABLE;
#endif
}

STDMETHODIMP CTRiASHPFeatures::SetupFeatures(IDispatch *pIParent, SETUPFEATURESMODE rgSetupMode)
{
// Der Parameter pIParent enthält einen Zeiger auf das Bezugsobjekt (Objektklasse oder Objekt) für 
// welches die Objekteigenschaften erzeugt werden sollen
	COM_TRY {
	WTRiASFeatures BaseFeats;

		THROW_FAILED_HRESULT(m_BaseUnk -> QueryInterface (BaseFeats.ppi()));

	// Diese Funktion wird sowohl für Objektklassen als auch für Einzelobjekte gerufen
	// (je nach Kontext).
	WTRiASObjects Objs;

		if (SUCCEEDED(pIParent -> QueryInterface (Objs.ppi()))) {
		// pIParent ist eine Objektklasse
		CShapeLayer *pLayer = reinterpret_cast<CShapeLayer *>(GetPropertyFrom (Objs, g_cbObjectsCursor, 0L));

			_ASSERTE(NULL != pLayer);

		CFieldIterator it (*pLayer);
		CShapeFieldBase *pField = it.GetFirstField();

			while (NULL != pField) {
			// ein Attribut instantiieren und zur Menge aller Attribute hinzufügen
				THROW_FAILED_HRESULT(SetupFeature (pIParent, BaseFeats, pField));
				pField = it.GetNextField();
			}

		} else {
			THROW_FAILED_HRESULT(E_UNEXPECTED);
		}

	} COM_CATCH;
	return S_OK;
}

// ein Attribut instantiieren und zur Menge aller Attribute hinzufügen
HRESULT CTRiASHPFeatures::SetupFeature (IDispatch *pIParent, ITRiASFeatures *pIBaseFeats, CShapeFieldBase *pField)
{
	_ASSERTE(NULL != pField && pField -> IsValid());
	if (!(NULL != pField && pField -> IsValid()))
		return E_INVALIDARG;

	COM_TRY {
	// zuerst versuchen, dieses Feature in der Map wiederzufinden
	WTRiASDatabase DBase;

		THROW_FAILED_HRESULT(FindSpecificParent (pIParent, DBase.ppi()));

	WTRiASObjectHandleMap Map (GetPropertyFrom (DBase, g_cbFeatureMap, (IDispatch *)NULL), false);
	WTRiASFeature Feat;

		if (!Map.IsValid() || S_OK != Map -> GetObject (reinterpret_cast<INT_PTR>(pField), Feat.ppu())) {
		// jetzt wirklich neu erzeugen und fertig initialisieren
			Feat = WTRiASFeature(CLSID_TRiASHPFeature);		// Feature erzeugen
			THROW_FAILED_HRESULT(WPersistStreamInit(Feat) -> InitNew());

		// Parent etc. stzen
			THROW_FAILED_HRESULT(Feat -> put_Parent (pIParent));
			THROW_FAILED_HRESULT(Feat -> put_Type (pField -> GetType()));
			THROW_FAILED_HRESULT(Feat -> put_Length (pField -> GetLen()));

		// an dem erzeugten Attribut seine Nummer (cursor) speichern
			THROW_FAILED_HRESULT(SetPropertyBy (Feat, g_cbFeatureCursor, CComVariant(reinterpret_cast<INT_PTR>(pField), VT_I4), true));

		// nachsehen, ob für dieses Attribut bereits Beschreibungsdaten existieren
		WTRiASObjects BaseObjs;

			THROW_FAILED_HRESULT(FindSpecificParent(m_BaseUnk, BaseObjs.ppi()));

		WTRiASMDSMap FeatsTable (GetPropertyFrom (BaseObjs, g_cbMetaDataMap, (IDispatch *)NULL), false);
		CComBSTR bstrAttr, bstrName, bstrDesc;

			_ASSERTE(FeatsTable.IsValid());
			THROW_FAILED_HRESULT(pField -> GetName(&bstrAttr));
			FeatsTable -> GetAt (bstrAttr, &bstrName, &bstrDesc, NULL, NULL);

		// Namen setzen
			if (!bstrName || 0 == bstrName.Length()) 
				bstrName = bstrAttr;
			THROW_FAILED_HRESULT(Feat -> put_Name (bstrName));

		// Beschreibung setzen
			if (!!bstrDesc && 0 < bstrDesc.Length()) {
				THROW_FAILED_HRESULT(Feat -> put_Description (bstrDesc));
			}
		}

	// das neu instantiierte/wiedergefundene Attribut zu dieser Attributsammlung hinzufügen
		THROW_FAILED_HRESULT(pIBaseFeats -> _Add (Feat, VARIANT_TRUE));

	} COM_CATCH;
	return S_OK;
}
