// $Header: $
// Copyright© 1998-2000 TRiAS GmbH Potsdam, All rights reserved
// Created: 14.09.2000 21:21:48
//
// This file was generated by the TRiASDB Data Server Wizard V1.02.103 (#HK000729)
//
// @doc 
// @module TRiASMIDBEngine.cpp |  Databaseengine für TRiASDB Data Server TRiASMI

#include "stdafx.h"

#include "Version.h"
#include "Strings.h"

#include "TRiASMI.h"
#include "TRiASMIDBEngine.h"
#include "TRiASMIDatabase.h"

#if defined(_DEBUG)
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// globale Instanz der DBEngine
CTRiASMIDBEngine *g_pDBEngine = NULL;
STARTMODE g_rgStartMode = STARTMODE_Normal;

///////////////////////////////////////////////////////////////////////////////
// CTRiASMIDBEngine

STDMETHODIMP CTRiASMIDBEngine::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITRiASDBEngine,
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

HRESULT CTRiASMIDBEngine::FinalConstruct (void)
{
	return S_OK;
}

void CTRiASMIDBEngine::FinalRelease()
{
	ASSERT(NULL == g_pDBEngine);	// existiert nicht mehr (sollte jedenfalls)
}

///////////////////////////////////////////////////////////////////////////////
// ITRiASDBEngine
STDMETHODIMP CTRiASMIDBEngine::get_Version (BSTR *pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	CHECKOUTPOINTER(pVal);	

CString strVersion;

	strVersion.Format (_T("%d.%02d.%03d"), TRIASMI_VERSION, TRIASMI_RELEASE, TRIASMI_BUILD);

CComBSTR bstrVersion (strVersion);

	*pVal = bstrVersion.Detach();
	return S_OK;
}

STDMETHODIMP CTRiASMIDBEngine::put_Password (BSTR bstrPwd)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	CHECKINPOINTER(bstrPwd);	

	m_bstrPassword = bstrPwd;
	return S_OK;
}

STDMETHODIMP CTRiASMIDBEngine::put_UserName (BSTR bstrUser)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	CHECKINPOINTER(bstrUser);

	m_bstrUserName = bstrUser;
	return S_OK;
}

STDMETHODIMP CTRiASMIDBEngine::get_Description (BSTR * pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	CHECKOUTPOINTER(pVal);	

CComBSTR bstr;

	if (!bstr.LoadString (IDS_DBENGINE_DESC))
		return E_OUTOFMEMORY;

	*pVal = bstr.Detach();
	return S_OK;
}

STDMETHODIMP CTRiASMIDBEngine::Start (STARTMODE rgMode)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	ASSERT(NULL == g_pDBEngine);	// darf nur einmal gerufen werden

	COM_TRY {
	// singletions instantiieren
		m_Service = WTRiASCSStorageService(CLSID_TRiASCSStorageService);

	// fertig initialisieren
		g_pDBEngine = this;
		g_rgStartMode = rgMode;
		m_fIsStarted = true;

	} COM_CATCH;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// Liefert Enumerator, der alle bekannten Projekttypen enthält

const LPCOLESTR s_poleTypesNormal[] = 
{
	g_cbDatabase,		// ProgID des Database-Objektes (s. TRiASMIDatabase.h)
};

typedef CComEnum<IEnumString, &IID_IEnumString, LPOLESTR, _Copy<LPOLESTR> > CEnumString;

STDMETHODIMP CTRiASMIDBEngine::EnumDataBaseTypes (IUnknown **ppIEnum)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	CHECKOUTPOINTER(ppIEnum);	

CComObject<CEnumString> *pIEnum = NULL;

	ATLTRY(pIEnum = new CComObject<CEnumString>());
	if (NULL == pIEnum) return E_OUTOFMEMORY;

// die Funktion Init des EnumTemplates erwartet die Adressen des ersten und 
// letzten+1 Elementes eines Vektors
LPOLESTR *ppStringsStart = (LPOLESTR *)&s_poleTypesNormal[0];
LPOLESTR *ppStringsEnd = (LPOLESTR *)&s_poleTypesNormal[_countof(s_poleTypesNormal)];

HRESULT hr = pIEnum -> Init (ppStringsStart, ppStringsEnd, static_cast<ITRiASDBEngine *>(this), AtlFlagCopy);

	if (SUCCEEDED(hr))
		hr = pIEnum -> QueryInterface(IID_IEnumString, (LPVOID *)ppIEnum);

	if (FAILED(hr))		// bei Fehler alles freigeben
		delete pIEnum;

	return hr;
}

STDMETHODIMP CTRiASMIDBEngine::Stop()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	ERROR_EXPR_TRUE(!m_fIsStarted, TRIASDB_E_NOT_STARTED);

	g_pDBEngine = NULL;				// das letzte vom Tage
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// Lizensierung für diesen Modul
#include <Esnecil.h>
#include <EsnecilExt.h>

#if _TRiAS_VER < 0x0400
extern DWORD g_dwVer4;
#endif // _TRiAS_VER < 0x0400

BOOL GetLicenseKey (LPWSTR pwKey, size_t iLen)
{
#if _TRiAS_VER < 0x0400
	if (0 == g_dwVer4) 
		return TRUE;
#endif // _TRiAS_VER < 0x0400

VERIFYLICENSE VL;

	INITSTRUCT(VL, VERIFYLICENSE);
	VL.iMode = VERIFYMODE_DontShowDialog;
	VL.lLevelOrOption = CKIOPTION_MAPINFO;
	if (!DEX_VerifyLicenseOption(VL))
		return FALSE;

CEsnecilExt Lic;
LPCSTR pcSiteCode = Lic.GetSiteCode();

	if (NULL != pwKey && NULL != pcSiteCode) 		// Key kopieren
		mbstowcs (pwKey, pcSiteCode, min(iLen, strlen(pcSiteCode)));

	return (NULL != pcSiteCode) ? TRUE : FALSE;
}

BOOL GetLicensed (void)
{
#if _TRiAS_VER < 0x0400
	if (0 == g_dwVer4) 
		return TRUE;
#endif // _TRiAS_VER < 0x0400

VERIFYLICENSE VL;
CComBSTR bstrLicCap;

	USES_CONVERSION;
	bstrLicCap.LoadString(IDS_DBENGINE_DESC);
	
	INITSTRUCT(VL, VERIFYLICENSE);
	VL.iMode = VERIFYMODE_ShowDialogSync;	// Dialog jetzt anzeigen
	VL.lLevelOrOption = CKIOPTION_MAPINFO;
	VL.pcCaption = OLE2A(bstrLicCap);
	return DEX_VerifyLicenseOption(VL);
}

BOOL SetLicensed (LPCSTR lpNewKey)		// Lizensierung ist erfolgt
{
#if _TRiAS_VER < 0x0400
	if (0 == g_dwVer4) 
		return TRUE;
#endif // _TRiAS_VER < 0x0400

CEsnecilExt Lic;

	return Lic.Authorize(lpNewKey);
}

