// $Header: $
// Copyright© 1998-2000 TRiAS GmbH Potsdam, All rights reserved
// Created: 14.09.2000 21:21:48 
//
// This file was generated by the TRiASDB Data Server Wizard V1.02.103 (#HK000729)
//
// @doc
// @module TRiASMIFeature.cpp | Implementation of the <c CTRiASMIFeature> class

#include "stdafx.h"

#include "Strings.h"

#include "TRiASMI.h"
#include "TRiASMIFeature.h"
#include "TRiASMIPropertySupport.h"
#include "MiTabLayer.h"

#if defined(_DEBUG)
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// CTRiASMIFeature

STDMETHODIMP CTRiASMIFeature::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITRiASFeature,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// ITRiASFeatureCallback
STDMETHODIMP CTRiASMIFeature::get_DefaultType (BSTR *pbstrType)
{
	CHECKOUTPOINTER(pbstrType);

CIID Guid (GetObjectCLSID());
CComBSTR bstrType (Guid.ProgID().c_str());

	*pbstrType = bstrType.Detach();
	return S_OK;
}

STDMETHODIMP CTRiASMIFeature::SetupFeature (SETUPFEATUREMODE rgMode)
{
	_ASSERTE(SETUPFEATUREMODE_InitOrLoad == rgMode);		// z.Zt nur dieses
	COM_TRY {
	// Properties zum aggregierten Objekt hinzufügen
	WTRiASPropertyMapHandler MapHandler(m_BaseUnk);

		THROW_FAILED_HRESULT(MapHandler -> AddMapEntry (
			CComBSTR(g_cbFeatureCursor), (INT_PTR)&CLSID_TRiASMICursorProperty, PROPERTYSUPPORT_NOFLAGS, vtMissing));

	} COM_CATCH;
	return S_OK;
}

STDMETHODIMP CTRiASMIFeature::OnChanging(CHANGEDFEATURE rgWhat, VARIANT vNewValue, VARIANT_BOOL *pDisAllow)
{
	CHECKOUTPOINTER(pDisAllow);
	switch (rgWhat) {
	case CHANGEDFEATURE_Name:
	case CHANGEDFEATURE_Description:
	case CHANGEDFEATURE_Length:
		*pDisAllow = VARIANT_FALSE;		// immer einverstanden sein
		return S_OK;
		
	case CHANGEDFEATURE_Handle:
	case CHANGEDFEATURE_ROMode:
	case CHANGEDFEATURE_Value:
	case CHANGEDFEATURE_Type:
		*pDisAllow = VARIANT_TRUE;		// verhindert Modifikation (rgWhat siehe OnChanged)
		return TRIASDB_E_OBJECTSNOTUPDATABLE;

	default:
		_ASSERTE(SUCCEEDED(E_INVALIDARG));
		break;
	}
	return E_INVALIDARG;
}

STDMETHODIMP CTRiASMIFeature::OnChanged(CHANGEDFEATURE rgWhat, VARIANT vOldValue)
{
	switch (rgWhat) {
	case CHANGEDFEATURE_Name:
		return OnChangedName(vOldValue);

	case CHANGEDFEATURE_Description:
		return OnChangedDescription(vOldValue);

#if defined(_READWRITE)
	case CHANGEDFEATURE_Handle:
		return OnChangedHandle(vOldValue);

	case CHANGEDFEATURE_ROMode:
		return OnChangedROMode(vOldValue);

	case CHANGEDFEATURE_Value:
		break;

	case CHANGEDFEATURE_Type:
		return OnChangedType(vOldValue);
#else
	case CHANGEDFEATURE_Handle:
	case CHANGEDFEATURE_ROMode:
	case CHANGEDFEATURE_Value:
	case CHANGEDFEATURE_Type:
		return TRIASDB_E_OBJECTSNOTUPDATABLE;
#endif // defined(_READWRITE)

	case CHANGEDFEATURE_Length:
		return S_OK;		// should be ok

	default:
		_ASSERTE(SUCCEEDED(E_INVALIDARG));
		break;
	}
	return E_INVALIDARG;
}

HRESULT CTRiASMIFeature::OnChangedName(VARIANT vOldValue)
{
	COM_TRY {
	// wenns die Erstinistialisierung ist, dann nichts machen
	CComVariant vOldVal;

		THROW_FAILED_HRESULT(vOldVal.ChangeType(VT_BSTR, &vOldValue));
		if (NULL == V_BSTR(&vOldVal) || 0 == ::SysStringLen(V_BSTR(&vOldVal)))
			return S_OK;

	// neuen Namen vom Bezugsobjekt besorgen
	CComBSTR bstrAttr, bstrName, bstrDesc;
	WTRiASObjects BaseObjs;
	WTRiASFeature BaseFeat (m_BaseUnk);
	
		THROW_FAILED_HRESULT(FindSpecificParent(m_BaseUnk, BaseObjs.ppi()));
		THROW_FAILED_HRESULT(WTRiASFeature(m_BaseUnk) -> get_Name (CLEARED(&bstrName)));

	CMiTabField *pField = reinterpret_cast<CMiTabField *>(GetPropertyFrom (BaseFeat, g_cbFeatureCursor, 0L));

		_ASSERTE(NULL !=  pField);
		THROW_FAILED_HRESULT(pField -> GetName(&bstrAttr));

	// in Feature-Beschreibungstabelle der zugehörigen Objektklasse den Namen modifizieren
	WTRiASMDSMap FeatsTable (GetPropertyFrom (BaseObjs, g_cbMetaDataMap, (IDispatch *)NULL), false);
	
		_ASSERTE(FeatsTable.IsValid());
		FeatsTable -> GetAt (bstrAttr, NULL, &bstrDesc, NULL, NULL);

	// korrigierten Eintrag in Tabelle ablegen
		THROW_FAILED_HRESULT(FeatsTable -> SetAt (bstrAttr, bstrName, bstrDesc, NULL, vtMissing));

	} COM_CATCH;
	return S_OK;
}

HRESULT CTRiASMIFeature::OnChangedDescription(VARIANT vOldValue)
{
	COM_TRY {
	// neue Beschreibung vom Bezugsobjekt besorgen
	CComBSTR bstrAttr, bstrName, bstrDesc;
	WTRiASObjects BaseObjs;
	WTRiASFeature BaseFeat (m_BaseUnk);
	
		THROW_FAILED_HRESULT(FindSpecificParent(m_BaseUnk, BaseObjs.ppi()));
		THROW_FAILED_HRESULT(WTRiASFeature(m_BaseUnk) -> get_Description (CLEARED(&bstrDesc)));

	CMiTabField *pField = reinterpret_cast<CMiTabField *>(GetPropertyFrom (BaseFeat, g_cbFeatureCursor, 0L));

		_ASSERTE(NULL != pField);
		THROW_FAILED_HRESULT(pField -> GetName(&bstrAttr));

	// in Feature-Beschreibungstabelle der zugehörigen Objektklasse die Beschreibung modifizieren
	WTRiASMDSMap FeatsTable (GetPropertyFrom (BaseObjs, g_cbMetaDataMap, (IDispatch *)NULL), false);
	
		_ASSERTE(FeatsTable.IsValid());
		FeatsTable -> GetAt (bstrAttr, &bstrName, NULL, NULL, NULL);

	// korrigierten Eintrag in Tabelle ablegen
		THROW_FAILED_HRESULT(FeatsTable -> SetAt (bstrAttr, bstrName, bstrDesc, NULL, vtMissing));

	} COM_CATCH;
	return S_OK;
}

#if defined(_READWRITE)
HRESULT CTRiASMIFeature::OnChangedHandle(VARIANT vOldValue)
{
	return S_OK;
}

HRESULT CTRiASMIFeature::OnChangedType(VARIANT vOldValue)
{
// neuen Typ vom Bezugsobjekt besorgen
FEATURETYPE rgType = FEATURETYPE_Unknown;
WTRiASFeature BaseFeat;

	RETURN_FAILED_HRESULT(m_BaseUnk -> QueryInterface (BaseFeat.ppi()));
	RETURN_FAILED_HRESULT(BaseFeat -> get_Type(&rgType))

#pragma TODO("Neuen Typ der Objekteigenschaft ggf. auswerten.")
	return S_OK;
}

HRESULT CTRiASMIFeature::OnChangedROMode(VARIANT vOldValue)
{
// neuen Schreibschutzmode vom Bezugsobjekt besorgen
VARIANT_BOOL fUpdatable = VARIANT_FALSE;
WTRiASFeature BaseFeat;

	RETURN_FAILED_HRESULT(m_BaseUnk -> QueryInterface (BaseFeat.ppi()));
	RETURN_FAILED_HRESULT(BaseFeat -> get_Updatable(&fUpdatable))

#pragma TODO("Neuen Schreibschutzmode der Objekteigenschaft ggf. auswerten.")
	return S_OK;
}
#endif // defined(_READWRITE)

/////////////////////////////////////////////////////////////////////////////
// Eval: Das, worum es eigentlich geht: Wert der Objekteigenschaft abfragen
STDMETHODIMP CTRiASMIFeature::Eval(ITRiASObject *pIObj, VARIANT *pVal)
{
HRESULT hr = TRIASDB_E_NOSUCHFEATURE;

	COM_TRY {
	WTRiASFeature BaseFeat;

		THROW_FAILED_HRESULT(m_BaseUnk -> QueryInterface (BaseFeat.ppi()));

	LONG lObjCursor = GetPropertyFrom (pIObj, g_cbObjectCursor, 0);
	CMiTabField *pField = reinterpret_cast<CMiTabField *>(GetPropertyFrom (BaseFeat, g_cbFeatureCursor, 0L));

		_ASSERTE(0 != lObjCursor);
		_ASSERTE(NULL !=  pField);

	// Objektdaten zuordnen und Attribut lesen
	CComBSTR bstrVal;

		hr = pField -> Eval (lObjCursor, &bstrVal);
		if (SUCCEEDED(hr)) {
		CComVariant vResult (bstrVal);

			THROW_FAILED_HRESULT(vResult.Detach(pVal));
		}

	} COM_CATCH;
	return S_OK;
}

STDMETHODIMP CTRiASMIFeature::EvalEx(ITRiASObject *pIObj, SAFEARRAY **ppConstraints, VARIANT *pVal)
{
	return Eval (pIObj, pVal);		// ignore constraints	
}

// Wert der Objekteigenschaft modifizieren
STDMETHODIMP CTRiASMIFeature::Update(ITRiASObject *pIObj, VARIANT Val)
{
#if defined(_READWRITE)
HRESULT hr = TRIASDB_E_NOSUCHFEATURE;

	COM_TRY {
	WTRiASFeature BaseFeat;

		THROW_FAILED_HRESULT(m_BaseUnk -> QueryInterface (BaseFeat.ppi()));

	CComBSTR bstrVal;
	LONG lObjCursor = GetPropertyFrom (pIObj, g_cbObjectCursor, 0);
	CMiTabField *pField = reinterpret_cast<CMiTabField *>(GetPropertyFrom (BaseFeat, g_cbFeatureCursor, 0L));

		_ASSERTE(0 != lObjCursor);
		_ASSERTE(NULL !=  pField);

	// Attribut schreiben
	CComVariant vArg;

		THROW_FAILED_HRESULT(vArg.ChangeType (VT_BSTR, &Val));
		THROW_FAILED_HRESULT(pField -> Eval (lObjCursor, V_BSTR(&vArg)));

	} COM_CATCH;
	return S_OK;
#else
	return TRIASDB_E_FEATURENOTUPDATABLE;
#endif // defined(_READWRITE)
}

// Kopie der Objekteigenschaft erzeugen
STDMETHODIMP CTRiASMIFeature::Clone (ITRiASFeature **ppIFeat)
{
	return E_NOTIMPL;
}

// Objekt wird logisch freigegeben
STDMETHODIMP CTRiASMIFeature::OnFinalRelease()
{
	COM_TRY {
	// unsere Nummer (Cursor) freigeben und damit dieses Objekt aus der Handlemap herauslöschen
		THROW_FAILED_HRESULT(DelPropertyBy (WDispatch(m_BaseUnk), g_cbFeatureCursor));
	} COM_CATCH;
	return S_OK;
}


