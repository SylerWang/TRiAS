// $Header: $
// Copyright© 1998-2000 TRiAS GmbH Potsdam, All rights reserved
// Created: 14.09.2000 21:21:48 
//
// This file was generated by the TRiASDB Data Server Wizard V1.02.103 (#HK000729)
//
// @doc
// @module TRiASMIObjectsCollection.cpp | Implementation of <c CTRiASMIObjectsCollection> class

#include "stdafx.h"

#include "Strings.h"

#include "TRiASMI.h"
#include "TRiASMIDBEngine.h"
#include "TRiASMIObjectsCollection.h"

#if defined(_DEBUG)
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// CTRiASMIObjectsCollection

STDMETHODIMP CTRiASMIObjectsCollection::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITRiASObjectsCollection,
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// ITRiASObjectsCollectionCallback

STDMETHODIMP CTRiASMIObjectsCollection::get_DefaultType (BSTR *pbstrType)
{
	CHECKOUTPOINTER(pbstrType);

CIID Guid (CLSID_TRiASMIObjects);		// DefaultType der _Elemente_ (hier: Objektklasse)!
CComBSTR bstrType (Guid.ProgID().c_str());

	*pbstrType = bstrType.Detach();
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// Erzeugen einer neuen Objektklasse
STDMETHODIMP CTRiASMIObjectsCollection::OnCreate (
	VARIANT NameOrHandle, BSTR Type, OBJECTSCOLLECTIONTYPE rgType, ITRiASObjects **ppIObjs)
{
	CHECKOUTPOINTER(ppIObjs);

#if defined(_READWRITE)
// jetzt wirklich erzeugen
CIID ClsId (Type, CIID::INITCIID_InitFromProgId);

	if (!ClsId)	ClsId = CLSID_TRiASHPObjects;	// default ClsId

	RETURN_FAILED_HRESULT(CreateObject (NameOrHandle, rgType, &ClsId, ppIObjs));
	return S_OK;
#else
	return TRIASDB_E_DATABASENOTUPDATABLE;
#endif // defined(_READWRITE)
}

///////////////////////////////////////////////////////////////////////////////
// Löschen einer Objektklasse aus der Datenquelle
STDMETHODIMP CTRiASMIObjectsCollection::OnDelete (VARIANT vWhich)
{
#if defined(_READWRITE)
#pragma TODO("Löschen einer Objektklasse (darf nur was machen, wenn keine Objekte enthalten sind).")
	return S_OK;
#else
	return TRIASDB_E_DATABASENOTUPDATABLE;
#endif // defined(_READWRITE)
}

///////////////////////////////////////////////////////////////////////////////
// Objekt wird logisch freigegeben
STDMETHODIMP CTRiASMIObjectsCollection::OnFinalRelease()
{
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// Objekt neu erzeugen/wiederverwenden und zur Collection hinzufügen
#if defined(_READ_WRITE)
HRESULT CTRiASMIObjectsCollection::CreateObject (
	VARIANT NameOrHandle, DWORD dwType, const CLSID *pClsId, ITRiASObjects **ppIObjs)
{
	_ASSERTE(NULL != pClsId);
	if (NULL == pClsId) 
		return E_POINTER;

// diverse Vorbereitungen treffen
WDispatch App;
WDispatch Parent;
WTRiASObjectsCollection BaseObjs;

	RETURN_FAILED_HRESULT(m_BaseUnk -> QueryInterface (BaseObjs.ppi()));

	RETURN_FAILED_HRESULT(BaseObjs -> get_Application (App.ppi()));		// für neue Objektklasse
	RETURN_FAILED_HRESULT(BaseObjs -> get_Parent(Parent.ppi()));

// ZugriffsHandle/Namen oder OKS aus NameOrHandle bestimmen
LONG lHandle = 0;
CComVariant v;
bool fHasName = false;
bool fHasOKS = false;
CComBSTR bstrApp, bstrOKS;

	if (VT_BSTR != V_VT(&NameOrHandle) && SUCCEEDED(v.ChangeType (VT_I4, &NameOrHandle)))
		lHandle = V_I4(&v);
	else if (SUCCEEDED(v.ChangeType(VT_BSTR, &NameOrHandle))) {
	// feststellen, ob es ein OKS ist, evtl. Namen isolieren
		if (StringIsOKS(V_BSTR(&v), CLEARED(&bstrOKS), CLEARED(&bstrApp))) {
			if (bstrOKS.Length() > 0)
				fHasOKS = true;
		} else 
			bstrApp = V_BSTR(&v);

		if (bstrApp.Length() > 0)
			fHasName = true;
	} else
		return E_INVALIDARG;

// Objektklasse aus Handle/Name/OKS erzeugen
HRESULT hr = S_OK;

	COM_TRY {
	WTRiASObjects Objs (*pClsId);		// zu liefernde Objektklasse erzeugen

		THROW_FAILED_HRESULT(Objs -> put_Parent (Parent));

#pragma TODO("Neue Objektklasse in Datenbank erzeugen.")

		if (fHasName) 	// S_FALSE heißt: Objekt existiert bereits
			RETURN_FAILED_HRESULT(Objs -> put_Name (bstrApp));
		if (fHasOKS)
			RETURN_FAILED_HRESULT(Objs -> put_OKS (bstrOKS));

	// wenn Objektklasse bereits zu dieser Menge von Objektklassen gehört, dann liefert _Add den Wert S_FALSE
		hr = BaseObjs -> _Add (Objs, VARIANT_TRUE);
		if (SUCCEEDED(hr) && NULL != ppIObjs)
			*ppIObjs = Objs.detach();			// evtl. neue/gefundene Objektklasse liefern

	} COM_CATCH;
	return hr;
}
#endif // defined(_READ_WRITE)

