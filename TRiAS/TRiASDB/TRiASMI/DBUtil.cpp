// $Header: $
// Copyright© 1998-2000 TRiAS GmbH Potsdam, All rights reserved
// Created: 14.09.2000 21:21:48 
//
// This file was generated by the TRiASDB Data Server Wizard V1.02.103 (#HK000729)
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY 
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR 
// PURPOSE.
//
// @doc
// @module DBUtil.cpp | Definition Helperfunktionen

#include "stdafx.h"

#include <io.h>
#include <ospace/string/src/regex.h>	// GNU regular expression matcher
#include <ospace/string/regexp.h>

#include "Strings.h"

/////////////////////////////////////////////////////////////////////////////
// OKS behandeln (globale Funktionen)

namespace {

// eigentlich passiert ja alles hier in der folgenden Klasse
	class COKSRegExpr :
		public os_regexp
	{
	public:
		COKSRegExpr() { pattern (g_cbOKS); }

	// feststellen, ob die gegebene Zeichenkette einen Objektklassenschlüssel enthält
		bool StringIsOKS (BSTR bstrToTest, BSTR *pbstrStripped = NULL, BSTR *pbstrAppendix = NULL)
		{ 
			USES_CONVERSION;

		// Eingabezeichenkette analysieren
		os_string strToTest (OLE2A(bstrToTest));
		int iMatched = match(strToTest);

			if (iMatched <= 0) 
				return false; 

		os_string strT;

			if (group(7).size() > 0) {
			// vierter Fall gefunden (Monikerformat)
				strT = group(7);
				if (NULL != pbstrAppendix) {
					_ASSERTE(group(8).size() > 0);

				CComBSTR bstrApp (os_string(group(8)).c_str());

					*pbstrAppendix = bstrApp.Detach();
				}

			} else if (group(4).size() > 0) {
			// dritter Fall gefunden ('[hexdigits]...')
				strT = group(4);
				if (NULL != pbstrAppendix) {
					_ASSERTE(group(5).size() > 0);

				CComBSTR bstrApp (os_string(group(5)).c_str());

					*pbstrAppendix = bstrApp.Detach();
				}
			} else if (group(1).size() > 0) {
			// ersten Fall gefunden ('[hexdigits]')
				strT = group(1);
			} else if (group(3).size() > 0) {
			// zweiten Fall gefunden ('hexdigits:...')
				strT = group(3);
			} else
				return false;

			if (0 == strT.size()) 
				return false;

		// Resultat liefern, wenn gewünscht
			if (NULL != pbstrStripped) {
			CComBSTR bstrRes (strT.c_str());

				*pbstrStripped = bstrRes.Detach();
			}
			return true;
		}
	};

	COKSRegExpr g_TestOKS;

}; // namespace

bool StringIsOKS (BSTR bstrToStrip, BSTR *pStripped, BSTR *pbstrAppendix)
{
	return g_TestOKS.StringIsOKS (bstrToStrip, pStripped, pbstrAppendix);
}

/**
 * Read names in a directory.
 *
 * This function abstracts access to directory contains.  It returns a
 * list of strings containing the names of files, and directories in this
 * directory.  The resulting string list becomes the responsibility of the
 * application and should be freed with CSLDestroy() when no longer needed.
 *
 * Note that no error is issued via CPLError() if the directory path is
 * invalid, though NULL is returned.
 *
 * @param pszPath the relative, or absolute path of a directory to read.
 * @return The list of entries in the directory, or NULL if the directory
 * doesn't exist.
 */
HRESULT ReadDir (const char *pszPath, vector<os_string> &rFiles)
{
struct _finddata_t c_file;
int hFile = -1;

	if (0 == strlen(pszPath))
		pszPath = ".";

char cbBuffer[_MAX_PATH];

	wsprintf (cbBuffer, "%s\\*.*", pszPath);
	if (-1L != (hFile = _findfirst (cbBuffer, &c_file)))
	{
		do {
			rFiles.push_back(os_string(c_file.name));
		} while (0 == _findnext (hFile, &c_file));
		_findclose(hFile);
		return S_OK;
	}
	return S_FALSE;
}

