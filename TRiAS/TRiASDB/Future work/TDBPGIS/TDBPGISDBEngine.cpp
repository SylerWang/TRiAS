// $Header: $
// Copyright© 1998-2002 GEOPunkt GmbH & Co. KG, NL Potsdam, All rights reserved
// Created: 25.02.2002 16:45:45
//
// This file was generated by the TRiASDB Data Server Wizard V1.02.117 (#HK010502)
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY 
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR 
// PURPOSE.
//
// @doc 
// @module TDBPGISDBEngine.cpp |  Databaseengine für TRiASDB Data Server TDBPGIS

#include "stdafx.h"

#include "Version.h"
#include "Strings.h"

#include "TDBPGIS.h"
#include "TDBPGISDBEngine.h"
#include "TDBPGISDatabase.h"

#if defined(_DEBUG)
#if defined(_MFC_VER)
#define new DEBUG_NEW
#endif // defined(_MFC_VER)
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// globale Instanz der DBEngine
CTDBPGISDBEngine *g_pDBEngine = NULL;
STARTMODE g_rgStartMode = STARTMODE_Normal;

///////////////////////////////////////////////////////////////////////////////
// CTDBPGISDBEngine

STDMETHODIMP CTDBPGISDBEngine::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITRiASDBEngine,
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

HRESULT CTDBPGISDBEngine::FinalConstruct (void)
{
	return S_OK;
}

void CTDBPGISDBEngine::FinalRelease()
{
	_ASSERTE(NULL == g_pDBEngine);	// existiert nicht mehr (sollte jedenfalls)
}

///////////////////////////////////////////////////////////////////////////////
// ITRiASDBEngine
STDMETHODIMP CTDBPGISDBEngine::get_Version (BSTR *pVal)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	CHECKOUTPOINTER(pVal);	

CString strVersion;

	strVersion.Format (_T("%d.%02d.%03d"), TDBPGIS_VERSION, TDBPGIS_RELEASE, TDBPGIS_BUILD);

CComBSTR bstrVersion (strVersion);

	*pVal = bstrVersion.Detach();
	return S_OK;
}

STDMETHODIMP CTDBPGISDBEngine::put_Password (BSTR bstrPwd)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	CHECKINPOINTER(bstrPwd);	

	m_bstrPassword = bstrPwd;
	return S_OK;
}

STDMETHODIMP CTDBPGISDBEngine::put_UserName (BSTR bstrUser)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	CHECKINPOINTER(bstrUser);

	m_bstrUserName = bstrUser;
	return S_OK;
}

STDMETHODIMP CTDBPGISDBEngine::get_Description (BSTR * pVal)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	CHECKOUTPOINTER(pVal);	

CComBSTR bstr;

	if (!bstr.LoadString (IDS_DBENGINE_DESC))
		return E_OUTOFMEMORY;

	*pVal = bstr.Detach();
	return S_OK;
}

STDMETHODIMP CTDBPGISDBEngine::Start (STARTMODE rgMode)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)
	_ASSERTE(NULL == g_pDBEngine);	// darf nur einmal gerufen werden

	COM_TRY {
	// singletions instantiieren
		m_Service = WTRiASCSStorageService(CLSID_TRiASCSStorageService);

	// fertig initialisieren
		g_pDBEngine = this;
		g_rgStartMode = rgMode;
		m_fIsStarted = true;
	} COM_CATCH;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// Liefert Enumerator, der alle bekannten Projekttypen enthält
const LPCOLESTR s_poleTypesNormal[] = 
{
	g_cbDatabase,		// ProgID des Database-Objektes (s. TDBPGISDatabase.h)
};

typedef CComEnum<IEnumString, &IID_IEnumString, LPOLESTR, _Copy<LPOLESTR> > CEnumString;

STDMETHODIMP CTDBPGISDBEngine::EnumDataBaseTypes (IUnknown **ppIEnum)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	CHECKOUTPOINTER(ppIEnum);	

CComObject<CEnumString> *pIEnum = NULL;

	ATLTRY(pIEnum = new CComObject<CEnumString>());
	if (NULL == pIEnum) return E_OUTOFMEMORY;

// die Funktion Init des EnumTemplates erwartet die Adressen des ersten und 
// letzten+1 Elementes eines Vektors
LPOLESTR *ppStringsStart = (LPOLESTR *)&s_poleTypesNormal[0];
LPOLESTR *ppStringsEnd = (LPOLESTR *)&s_poleTypesNormal[_countof(s_poleTypesNormal)];

HRESULT hr = pIEnum -> Init (ppStringsStart, ppStringsEnd, static_cast<ITRiASDBEngine *>(this), AtlFlagCopy);

	if (SUCCEEDED(hr))
		hr = pIEnum -> QueryInterface(IID_IEnumString, (LPVOID *)ppIEnum);

	if (FAILED(hr))		// bei Fehler alles freigeben
		delete pIEnum;

	return hr;
}

STDMETHODIMP CTDBPGISDBEngine::Stop()
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	ERROR_EXPR_TRUE(!m_fIsStarted, TRIASDB_E_NOT_STARTED);

	g_pDBEngine = NULL;				// das letzte vom Tage
	return S_OK;
}
