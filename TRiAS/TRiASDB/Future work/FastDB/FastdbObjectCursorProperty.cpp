// $Header: $
// Copyright© 1998-2000 TRiAS GmbH Potsdam, All rights reserved
// Created: 25.02.2000 11:15:18 
//
// This file was generated by the TRiASDB Data Server Wizard V1.01.076 (#HK000225)
//
// @doc
// @module FastdbObjectCursorProperty.cpp | Implementation of the <c CFastdbObjectCursorProperty> class

#include "stdafx.h"

#include "Strings.h"

#include "Fastdb.h"
#include "FastdbObjectCursorProperty.h"

#if defined(_DEBUG)
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// Die vorliegende Klasse implementiert eine spezielle Property 'ObjectCursor'
// eines Objektes (CFastdbObject), die dafür sorgt, daß in dem Moment, 
// wenn ein Objektcursor für ein Objekt definiert bzw. freigegeben wird, dieses
// Objekt mit seinem Cursor in einer speziellen Tabelle gespeichert bzw. 
// freigegeben wird. 
// Diese Zuordnungstabelle wird für die Recherchen benötigt, um den gefundenen
// Objekten in der Datenbank (Cursor) die zugeordneten C++ Objekte 
// (CFastdbObject) zuordnen zu können.
// Diese Tabelle ist im vorliegenden Beispiel als Property ('ObjectCursorMap')
// an der Datenbank (CFastdbDatabase) abgelegt. 
// Für andere Datenquellen ist es u.U. notwendig die einzelnen Objekte in Bezug 
// zu ihrer Objektklasse zu speichern, dann sollte die Zuordnungstabelle 
// von Cursor zu Objekt auch an der zugehörigen Objektklasse abgelegt werden.)
// 
// Die Verwendung einer GenObjectMap (s. FastdbDatabase.h: BEGIN_PROPERTYSUPPORT_MAP)
// beschränkt den CursorTyp auf VT_I4.

/////////////////////////////////////////////////////////////////////////////
// SmartIF's
DefineSmartInterface(TRiASObjectHandleMap);
DefineSmartInterface(TRiASDatabase);

/////////////////////////////////////////////////////////////////////////////
// CFastdbObjectCursorProperty

void CFastdbObjectCursorProperty::FinalRelease()
{
	ResetCursor();		// Cursor wieder freigeben
}

/////////////////////////////////////////////////////////////////////////////
// PropertySupport
// Callback-interface, welches für die Konkretheit der Properties zuständig ist

STDMETHODIMP CFastdbObjectCursorProperty::PutValue (BSTR Name, VARIANT Value)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	_ASSERTE(NULL != Name);
	_ASSERTE(!wcscmp (Name, g_cbObjectCursor));	// muß "ObjectCursor" sein

	RETURN_FAILED_HRESULT(m_Value.Copy(&Value));	// Wert setzen
	RETURN_FAILED_HRESULT(SetCursor());				// Zuordnung in Map setzen bzw. entfernen
	return S_OK;
}

STDMETHODIMP CFastdbObjectCursorProperty::GetValue (BSTR Name, VARIANT *pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	
	_ASSERTE(NULL != Name || NULL != pVal);
	_ASSERTE(!wcscmp (Name, g_cbObjectCursor));	// muß "ObjectCursor" sein
	if (NULL == pVal) return E_POINTER;

CComVariant val (m_Value);

	RETURN_FAILED_HRESULT(val.Detach (pVal));
	return S_OK;
}

STDMETHODIMP CFastdbObjectCursorProperty::PutType (BSTR Name, PROPERTY_TYPE newVla)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	_ASSERTE(NULL != Name);
	_ASSERTE(!wcscmp (Name, g_cbObjectCursor));	// muß "ObjectCursor" sein

	return E_NOTIMPL;
}

STDMETHODIMP CFastdbObjectCursorProperty::GetType (BSTR Name, PROPERTY_TYPE *pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	_ASSERTE(NULL != Name || NULL != pVal);
	_ASSERTE(!wcscmp (Name, g_cbObjectCursor));	// muß "ObjectCursor" sein

	if (NULL == pVal) return E_POINTER;

	*pVal = PROPERTY_TYPE(PROPERTY_TYPE_Dynamic);
	return S_OK;
}

STDMETHODIMP CFastdbObjectCursorProperty::PutValueAndType(BSTR Name, VARIANT Value, PROPERTY_TYPE Type)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	_ASSERTE(NULL != Name);
	_ASSERTE(!wcscmp (Name, g_cbObjectCursor));	// muß "ObjectCursor" sein

// Wert setzen
	RETURN_FAILED_HRESULT(m_Value.Copy(&Value));
	return S_OK;		// Typ wird nicht bearbeitet
}

STDMETHODIMP CFastdbObjectCursorProperty::GetValueAndType(BSTR Name, VARIANT * pVal, PROPERTY_TYPE * pType)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	_ASSERTE(NULL != Name || NULL != pVal || NULL != pType);
	_ASSERTE(!wcscmp (Name, g_cbObjectCursor));	// muß "ObjectCursor" sein
	if (NULL != pVal) return E_POINTER;
	if (NULL != pType) return E_POINTER;

CComVariant val (m_Value);

	RETURN_FAILED_HRESULT(val.Detach (pVal));
	*pType = PROPERTY_TYPE(PROPERTY_TYPE_Dynamic);
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// IObjectWithSite
STDMETHODIMP CFastdbObjectCursorProperty::SetSite (IUnknown *pISite)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	if (NULL != pISite)
		return pISite -> QueryInterface(IID_ITRiASObject, m_Obj.ppv());
	else {
		ResetCursor();
		m_Obj.Assign(NULL);
		return S_OK;
	}
}

STDMETHODIMP CFastdbObjectCursorProperty::GetSite (REFIID riid, void **ppvSite)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	if (!m_Obj) 
		return TRIASDB_E_PROPERTY_NOT_INITIALIZED;
	return m_Obj -> QueryInterface (riid, ppvSite);
}

STDMETHODIMP CFastdbObjectCursorProperty::Refresh(BSTR bstrName)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////////
// Helper
HRESULT CFastdbObjectCursorProperty::GetObjectCursorMap (ITRiASObjectHandleMap **ppIMap)
{
	if (!m_Obj.IsValid())
		return TRIASDB_E_PROPERTY_NOT_INITIALIZED;

	COM_TRY {
	WTRiASDatabase Parent;

		THROW_FAILED_HRESULT(FindSpecificParent (m_Obj, Parent.ppi()));

	WTRiASObjectHandleMap Map (GetPropertyFrom (Parent, g_cbObjectMap, (IDispatch *)NULL), false);	// GetProperty liefert AddRef'ed ab

		*ppIMap = Map.detach();

	} COM_CATCH;
	return S_OK;
}

HRESULT CFastdbObjectCursorProperty::SetCursor()
{
	COM_TRY {
	WTRiASObjectHandleMap Map;
	CComVariant vVal;
	HRESULT hr = S_OK;

		THROW_FAILED_HRESULT(GetObjectCursorMap (Map.ppi()));
		THROW_FAILED_HRESULT(vVal.ChangeType (VT_I4, &m_Value));
		Map -> RemoveObject (V_I4(&vVal), OBJECTMAPMODE_RemoveAllReferences);

	OBJECTMAPMODE rgMode = OBJECTMAPMODE(OBJECTMAPMODE_CreateObjectHandle|OBJECTMAPMODE_DoNotRegisterNativeHandle);

		THROW_FAILED_HRESULT(hr = Map -> GetObjectHandle (vtMissing, m_Obj, rgMode, (INT_PTR *)&V_I4(&vVal)));
		_ASSERTE(S_OK == hr);		// Handle darf sich nicht geändert haben

	} COM_CATCH;
	return S_OK;
}

HRESULT CFastdbObjectCursorProperty::ResetCursor()
{
	if (!m_Obj)
		return S_FALSE;		// nicht das erste mal

	COM_TRY {
	WTRiASObjectHandleMap Map;
	CComVariant vVal;

		THROW_FAILED_HRESULT(GetObjectCursorMap (Map.ppi()));
		THROW_FAILED_HRESULT(vVal.ChangeType (VT_I4, &m_Value));
		THROW_FAILED_HRESULT(Map -> RemoveObject (V_I4(&vVal), OBJECTMAPMODE_RemoveAllReferences));

	} COM_CATCH;
	return S_OK;
}
