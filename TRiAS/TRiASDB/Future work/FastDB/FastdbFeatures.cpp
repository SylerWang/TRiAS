// $Header: $
// Copyright© 1998-2000 TRiAS GmbH Potsdam, All rights reserved
// Created: 25.02.2000 11:15:18 
//
// This file was generated by the TRiASDB Data Server Wizard V1.01.076 (#HK000225)
//
// @doc
// @module FastdbFeatures.cpp | Implementation of the <c CFastdbFeatures> class

#include "stdafx.h"

#include "Strings.h"

#include "Fastdb.h"
#include "FastdbDatabase.h"
#include "FastdbFeatures.h"

#if defined(_DEBUG)
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// SmartIF's
DefineSmartInterface(TRiASFeature);
DefineSmartInterface(TRiASFeatures);
DefineSmartInterface(TRiASObject);
DefineSmartInterface(TRiASObjects);

DefineSmartInterface(Dispatch);
DefineSmartInterface(PersistStreamInit);

/////////////////////////////////////////////////////////////////////////////
// CFastdbFeatures

STDMETHODIMP CFastdbFeatures::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITRiASFeatures,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// ITRiASFeaturesCallback

STDMETHODIMP CFastdbFeatures::get_DefaultType (BSTR *pbstrType)
{
	CHECKOUTPOINTER(pbstrType);

CIID Guid (CLSID_FastdbFeature);			// DefaultType der _Elemente_ (hier Feature)!
CComBSTR bstrType (Guid.ProgID().c_str());

	*pbstrType = bstrType.Detach();
	return S_OK;
}

// eine neue Objekteigenschaft soll erzeugt werden
STDMETHODIMP CFastdbFeatures::OnCreate (VARIANT Name, BSTR Type, FEATURETYPE rgType, ITRiASFeature **ppIFeat)
{
	CHECKOUTPOINTER(ppIFeat);

	USES_CONVERSION;
	COM_TRY {
	// jetzt wirklich erzeugen
	CIID ClsId (Type, CIID::INITCIID_InitFromProgId);

		if (!ClsId)	ClsId = CLSID_FastdbFeature;	// default ClsId

	WTRiASFeatures BaseFeats;
	WDispatch Parent;

		THROW_FAILED_HRESULT(m_BaseUnk -> QueryInterface (BaseFeats.ppi()));
		THROW_FAILED_HRESULT(BaseFeats -> get_Parent (Parent.ppi()));

	// Parent muß hier Objektklasse sein
	WTRiASObjects Objs;

		THROW_FAILED_HRESULT(Parent -> QueryInterface (Objs.ppi()));

	// neuen Satz erzeugen und zu der Objektklasse hinzufügen
	LONG lCursor (GetPropertyFrom (Objs, g_cbObjectsCursor, 0L));

		_ASSERTE(0 != lCursor);

	dbDatabase *pdb = GetRelatedDatabase(GetUnknown());
	dbCursor<CDBClass> cursor (pdb);
	CDBClass *pClass = cursor.at (dbReference<CDBClass>(oid_t(lCursor)));

		if (NULL == pClass || cursor.isEmpty())
			THROW_FAILED_HRESULT(FASTDB_E_OBJECTS_BADREFERENCE);

	CComVariant vVal;
	CDBFeatureDesc FDesc;

		THROW_FAILED_HRESULT(vVal.ChangeType (VT_BSTR, &Name));
	
		FDesc.m_pName = OLE2A(V_BSTR(&vVal));
		FDesc.m_rgType = rgType;
		FDesc.objclass = cursor.currentId();
	
	dbCursor<CDBFeatureDesc> featuredesc (GetRelatedDatabase(GetUnknown()));

		featuredesc.at (pdb -> insert (FDesc));
		THROW_FAILED_HRESULT(SetupFeature (ClsId, BaseFeats, featuredesc, Parent, ppIFeat));

	} COM_CATCH;
	return S_OK;
}

STDMETHODIMP CFastdbFeatures::OnChanging(CHANGEDFEATURES rgWhat, VARIANT vNewValue, VARIANT_BOOL *pDisAllow)
{
	CHECKOUTPOINTER(pDisAllow);

	*pDisAllow = VARIANT_FALSE;		// immer einverstanden sein
	return S_OK;
}

// Irgend was wurde modifiziert
STDMETHODIMP CFastdbFeatures::OnChanged(CHANGEDFEATURES rgWhat, VARIANT vOldValue)
{
	return S_OK;
}

// Objekt wird logisch freigegeben
STDMETHODIMP CFastdbFeatures::OnFinalRelease()
{
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Eine Objekteigenschaftsbeschreibung soll gelöscht werden
STDMETHODIMP CFastdbFeatures::OnDelete (VARIANT vWhich)
{
#pragma TODO("Gegebenenfalls Objekteigenschaft aus Datenquelle löschen.")

	// S_OK:	Objekteigenschaft wurde gelöscht
	// ansonsten Fehlercode
	return S_OK;
}

STDMETHODIMP CFastdbFeatures::SetupFeatures(IDispatch *pIParent, SETUPFEATURESMODE rgSetupMode)
{
// Der Parameter pIParent enthält einen Zeiger auf das Bezugsobjekt (Objektklasse oder Objekt) für 
// welches die Objekteigenschaften erzeugt werden sollen
	COM_TRY {
	WTRiASFeatures BaseFeats;
	WDispatch Parent;

		THROW_FAILED_HRESULT(m_BaseUnk -> QueryInterface (BaseFeats.ppi()));
		THROW_FAILED_HRESULT(BaseFeats -> get_Parent (Parent.ppi()));

	// Diese Funktion wird sowohl für Objektklassen als auch für Einzelobjekte gerufen
	// (je nach Kontext).
	WTRiASObjects Objs;

		if (SUCCEEDED(pIParent -> QueryInterface (Objs.ppi()))) {
		// pIParent ist eine Objektklasse
		LONG lCursor (GetPropertyFrom (Objs, g_cbObjectsCursor, 0L));

			_ASSERTE(0 != lCursor);

		dbDatabase *pDB = GetRelatedDatabase(GetUnknown());
		dbCursor<CDBClass> cursor (pDB);
		CDBClass *pClass = cursor.at (dbReference<CDBClass>(oid_t(lCursor)));

			if (NULL == pClass || cursor.isEmpty())
				THROW_FAILED_HRESULT(FASTDB_E_OBJECTS_BADREFERENCE);

		int iFeatCnt = pClass -> featuredescs.length();
		dbCursor<CDBFeatureDesc> featuredesc (pDB);

			for (int i = 0; i < iFeatCnt; i++) {
			CDBFeatureDesc *pFeat = featuredesc.at (pClass -> featuredescs[i]);

				_ASSERTE(NULL != pFeat && !featuredesc.isEmpty());

			// ein Attribut instantiieren und zur Menge aller Attribute hinzufügen
				THROW_FAILED_HRESULT(SetupFeature (CLSID_FastdbFeature, BaseFeats, featuredesc, Parent));
			}

		} else {
//		// pIParent muß ein Objekt sein
//		WTRiASObject Obj;
//
//			THROW_FAILED_HRESULT(pIParent -> QueryInterface (Obj.ppi()));
//
//		// Objektnummer besorgen
//		LONG lCursor (GetPropertyFrom (Objs, g_cbObjectsCursor, 0L));
//
//			_ASSERTE(0 != lCursor);
//
//		// auf Objektinfo zugreifen
//		const OBJECT *pObject = g_Objects[lCursor-1];
//
//			for (int i = 0; i < pObject -> m_iFeatureCount; i++) {
//			// ein Attribut instantiieren und zur Menge aller Attribute hinzufügen
//				THROW_FAILED_HRESULT(SetupFeature (BaseFeats, ...));
//			}
			THROW_FAILED_HRESULT(E_UNEXPECTED);		// snh
		}
	} COM_CATCH;
	return S_OK;
}

// ein Attribut instantiieren und zur Menge aller Attribute hinzufügen
HRESULT CFastdbFeatures::SetupFeature (
	REFCLSID rClsId, ITRiASFeatures *pIBaseFeats, dbCursor<CDBFeatureDesc> &rFeatDesc, 
	IDispatch *pIParent, ITRiASFeature **ppIFeat)
{
	COM_TRY {
	WTRiASFeature Feat (CLSID_FastdbFeature);		// Feature erzeugen

	// fertig initialisieren
		THROW_FAILED_HRESULT(WPersistStreamInit(Feat) -> InitNew());
		THROW_FAILED_HRESULT(Feat -> put_Parent (pIParent));

	// Namen etc. stzen
		THROW_FAILED_HRESULT(Feat -> put_Type ((FEATURETYPE)rFeatDesc -> m_rgType));
		THROW_FAILED_HRESULT(Feat -> put_Name (CComBSTR(rFeatDesc -> m_pName)));
		THROW_FAILED_HRESULT(Feat -> put_Description (CComBSTR(rFeatDesc -> m_pDesc)));

	// an dem erzeugten Attribut seine Nummer (cursor) speichern
		THROW_FAILED_HRESULT(SetPropertyBy (Feat, g_cbFeatureCursor, CComVariant(rFeatDesc.currentId().getOid(), VT_I4), true));

	// das neu instantiierte Attribut zu dieser Attributsammlung hinzufügen
		THROW_FAILED_HRESULT(pIBaseFeats -> _Add (Feat, VARIANT_TRUE));

		if (NULL != ppIFeat)
			*ppIFeat = Feat.detach();

	} COM_CATCH;
	return S_OK;
}
