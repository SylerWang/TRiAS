<HTML>
<HEAD>
<TITLE>FastDB Main Memory Database Management System</TITLE>
<UL>
<LI> <A HREF = "#introduction">Introduction</A>
<LI> <A HREF = "#sql">Query language</A>
  <UL>
  <LI> <A HREF = "#structure">Structures</A>
  <LI> <A HREF = "#array">Arrays</A>
  <LI> <A HREF = "#string">Strings</A>
  <LI> <A HREF = "#reference">References</A>
  <LI> <A HREF = "#function">Functions</A>
  </UL>
<LI> <A HREF = "#cpp">C++ interface</A>
  <UL>
  <LI> <A HREF = "#table">Table</A>
  <LI> <A HREF = "#query">Query</A>
  <LI> <A HREF = "#cursor">Cursor</A>
  <LI> <A HREF = "#database">Database</A>
  </UL>
<LI> <A HREF = "#cli">CLI - call level interface</A>
  <UL>
  <LI> <A HREF = "#cli_errors">CLI error codes</A>
  <LI> <A HREF = "#cli_types">CLI supported types</A>
  <LI> <A HREF = "#cli_open">cli_open</A>
  <LI> <A HREF = "#cli_close">cli_close</A>
  <LI> <A HREF = "#cli_statement">cli_statement</A>
  <LI> <A HREF = "#cli_parameter">cli_parameter</A>
  <LI> <A HREF = "#cli_column">cli_colunm</A>
  <LI> <A HREF = "#cli_array_column">cli_array_column</A>
  <LI> <A HREF = "#cli_fetch">cli_fetch</A>
  <LI> <A HREF = "#cli_insert">cli_insert</A>
  <LI> <A HREF = "#cli_get_first">cli_get_first</A>
  <LI> <A HREF = "#cli_get_last">cli_get_last</A>
  <LI> <A HREF = "#cli_get_next">cli_get_next</A>
  <LI> <A HREF = "#cli_get_prev">cli_get_prev</A>
  <LI> <A HREF = "#cli_get_oid">cli_get_oid</A>
  <LI> <A HREF = "#cli_update">cli_update</A>
  <LI> <A HREF = "#cli_remove">cli_remove</A>
  <LI> <A HREF = "#cli_free">cli_free</A>
  <LI> <A HREF = "#cli_commit">cli_commit</A>
  <LI> <A HREF = "#cli_abort">cli_abort</A>
  </UL>
<LI> <A HREF = "#optimization">Query optimization</A>
  <UL>
  <LI> <A HREF = "#indices">Using indices in queries</A>
  <LI> <A HREF = "#inverse">Inverse references</A>
  <LI> <A HREF = "#realtime">Realtime issues</A>
  <LI> <A HREF = "#par">Parallel query execution</A>
  </UL>
<LI> <A HREF = "#implementation">FastDB implementation issues</A>
  <UL>
  <LI> <A HREF = "#memory">Memory allocation</A>
  <LI> <A HREF = "#transaction">Transactions</A>
  <LI> <A HREF = "#recovery">Recovery</A>
  <LI> <A HREF = "#hashtable">Hash table</A>
  <LI> <A HREF = "#ttree">T-tree</A>
  </UL>
<LI> <A HREF = "#subsql">Interactive SQL</A>
<LI> <A HREF = "#www">API for development Web applications</A>
<LI> <A HREF = "#examples">Examples of FastDB applications</A>
  <UL>
  <LI> <A HREF = "#guess">Example: game "Guess an animal"</A>
  <LI> <A HREF = "#testdb">Example: various types of queries</A>
  <LI> <A HREF = "#testperf">Performance test</A>
  <LI> <A HREF = "#bugdb">Bug tracking database</A>
  <LI> <A HREF = "#clidb">Clients-Managers database</A>
  </UL>
<LI> <A HREF = "#quick">Quick start</A>
<LI> <A HREF = "#distribution">Distribution terms</A>
</UL>

<BODY>
<HR>
<H2><A NAME = "introduction">Introduction</A></H2>

FastDB is a highly efficient main memory database system 
with realtime capabilities and convenient C++ interface.
FastDB doesn't support a client-server architecture and all applications
using a FastDB database should run at the same host. FastDB is optimized 
for applications with dominated read access pattern. High speed of query 
execution is provided by the elimination of data transfer overhead and
a very effective locking implementation. The Database file is mapped to the virtual
memory space of each application working with the database. So the query is executed in
the context of the application, requiring no context switching and data transfer.
Synchronization of concurrent database access is implemented in FastDB 
by means of atomic instructions, adding almost 
no overhead to query processing. FastDB assumes that the whole database is 
present in RAM and optimizes the search algorithms and structures according to this
assumption. Moreover, FastDB has no overhead caused by database buffer management
and needs no data transfer between a database file and buffer pool. 
That is why FastDB 
will work significantly faster than a traditional database with all data cached 
in buffers pool.<P>

FastDB supports transactions, online backup and automatic recovery 
after system crash. The transaction commit protocol is based on
a shadow root pages algorithm, performing atomic update of the database.
Recovery can be done very fast, providing 
high availability for critical applications. Moreover, the elimination
of transaction logs improves the total system performance and leads to a more 
effective usage of system resources.<P>

FastDB is an application-oriented database. Database tables are constructed using
information about application classes. FastDB supports automatic scheme 
evaluation, allowing you to do changes only in one place - in your
application classes. FastDB provides a flexible and convenient interface
for retrieving data from the database. A SQL-like query language is used
to specify queries. Such post-relational capabilities as non-atomic
fields, nested arrays, user-defined types and methods, direct interobject 
references simplifies the design of database applications and makes them more
efficient.<P>

Although FastDB is optimized in the assumption that database as a whole fits
into the physical memory of the computer, it is also possible to use it with databases,
the size of which exceeds the size of the physical memory in the system. In the last 
case, standard operating system swapping mechanisms will work. But 
all FastDB search algorithms and structures are optimized under the assumption of
residence of all data in memory, so the efficiency for swapped 
out data will not be very high.<P> 


<H2><A NAME = "sql">Query language</A></H2>

FastDB supports a query language with SQL-like syntax. FastDB uses a notation more
popular for object-oriented programming then for a relational database. 
Table rows are considered as object instances, the table is the class of these
objects. Unlike SQL, FastDB is oriented on work with objects instead of SQL
tuples. So the result of each query execution  is a set of objects of one 
class. The main differences of the FastDB query language from standard SQL are:<P>

<OL>
<LI> There are no joins of several tables and nested subqueries. The query always
returns a set of objects from one table. 
<LI> Standard C types are used for atomic table columns.
<LI> There are no NULL values, except null references. 
I completely agree with C.J. Date's criticism of three-value logic and his 
proposal to use default values instead. 
<LI> Structures and arrays can be used as record components. A special 
<B>exists</B> quantor is provided for locating elements in arrays. 
<LI> Parameterless user methods can be defined for table records (objects) as well as
for record components.
<LI> User functions with (only) one single string or numeric argument can be defined by
the application. 
<LI> References between objects are supported including automatic support
for inverse references. 
<LI>Construction of <code>start from follow by</code> performs a recursive records
traversal using references.
<LI> Because the query language is deeply integrated into C++ classes, a case
sensitive mode is used for language identifiers as well as for keywords. 
<LI> No implicit conversion of integer and floating types to string
representation is done. If such conversion is needed, it must be done explicitly. 
</OL><P>

The following rules in BNF-like notation specify the grammar of the
FastDB query language search predicates:<P>

<TABLE BORDER ALIGN="center">
<CAPTION>Grammar conventions</CAPTION>
<TR><TH>Example</TH><TH>Meaning</TH></TR>
<TR><TD><I>expression</I></TD><TD>non-terminals</TD></TR>
<TR><TD><B>not</B></TD><TD>terminals</TD></TR>
<TR><TD ALIGN="center">|</TD><TD>disjoint alternatives</TD></TR>
<TR><TD>(<B>not</B>)</TD><TD>optional part</TD></TR>
<TR><TD>{<B>1</B>..<B>9</B>}</TD><TD>repeat zero or more times</TD></TR>
</TABLE><P>

<PRE>
<I>select-condition</I> ::= ( <I>expression</I> ) ( <I>traverse</I> ) ( <I>order</I> )
<I>expression</I> ::= <I>disjunction</I>
<I>disjunction</I> ::= <I>conjunction</I> 
        | <I>conjunction</I> <B>or</B> <I>disjunction</I>
<I>conjunction</I> ::= <I>comparison</I> 
        | <I>comparison</I> <B>and</B> <I>conjunction</I>
<I>comparison</I> ::= <I>operand</I> <B>=</B> <I>operand</I> 
        | <I>operand</I> <B>!=</B> <I>operand</I> 
        | <I>operand</I> <B>&lt;&gt;</B> <I>operand</I> 
        | <I>operand</I> <B>&lt;</B> <I>operand</I> 
        | <I>operand</I> <B>&lt;=</B> <I>operand</I> 
        | <I>operand</I> <B>&gt;</B> <I>operand</I> 
        | <I>operand</I> <B>&gt;=</B> <I>operand</I> 
        | <I>operand</I> (<B>not</B>) <B>like</B> <I>operand</I> 
        | <I>operand</I> (<B>not</B>) <B>like</B> <I>operand</I> <B>escape</B> <I>string</I>
        | <I>operand</I> (<B>not</B>) <B>in</B> <I>operand</I>
        | <I>operand</I> (<B>not</B>) <B>in</B> <I>expressions-list</I>
        | <I>operand</I> (<B>not</B>) <B>between</B> <I>operand</I> <B>and</B> <I>operand</I>
	| <I>operand</I> <B>is</B> (<B>not</B>) <B>null</B>
<I>operand</I> ::= <I>addition</I>
<I>additions</I> ::= <I>multiplication</I> 
        | <I>addition</I> <B>+</B>  <I>multiplication</I>
        | <I>addition</I> <B>||</B> <I>multiplication</I>
        | <I>addition</I> <B>-</B>  <I>multiplication</I>
<I>multiplication</I> ::= <I>power</I> 
        | <I>multiplication</I> <B>*</B> <I>power</I>
        | <I>multiplication</I> <B>/</B> <I>power</I>
<I>power</I> ::= <I>term</I>
        | <I>term</I> <B>^</B> <I>power</I>
<I>term</I> ::= <I>identifier</I> | <I>number</I> | <I>string</I> 
        | <B>true</B> | <B>false</B> | <B>null</B> 
	| <B>current</B> | <B>first</B> | <B>last</B>
	| <B>(</B> expression <B>)</B> 
        | <B>not</B> <I>comparison</I>
	| <B>-</B> term
	| <I>term</I> <B>[</B> expression <B>]</B> 
	| <I>identifier</I> <B>.</B> <I>term</I> 
	| <I>function</I> <I>term</I>
        | <B>exists</B> <I>identifier</I> <B>:</B> <I>term</I>
<I>function</I> ::= <B>abs</B> | <B>length</B> | <B>lower</B> | <B>upper</B>
        | <B>integer</B> | <B>real</B> | <B>string</B> | <I>user-function</I>
<I>string</I> ::= <B>'</B> { { <I>any-character-except-quote</I> } (<B>''</B>) } <B>'</B>
<I>expressions-list</I> ::= <B>(</B> <I>expression</I> { <B>,</B> <I>expression</I> } <B>)</B>
<I>order</I> ::= <B>order by</B> <I>sort-list</I>
<I>sort-list</I> ::= <I>field-order</I> { <B>,</B> <I>field-order</I> }
<I>field-order</I> ::= [<B>length</B>] <I>field</I> (<B>asc</B> | <B>desc</B>)
<I>field</I> ::= <I>identifier</I> { <B>.</B> <I>identifier</I> }
<I>traverse</I> ::= <B>start from</B> <I>field</I> ( <B>follow by</B> <I>fields-list</I> )
<I>fields-list</I> ::=  <I>field</I> { <B>,</B> <I>field</I> }
<I>user-function</I> ::= <I>identifier</I>
</PRE><P>

Identifiers are case sensitive, begin with a  a-z, A-Z, '_' or '$' 
character, contain only a-z, A-Z, 0-9, '_' or '$' characters, and
do not duplicate a SQL reserved word.<P>

<TABLE WIDTH=100%>
<CAPTION>List of reserved words</CAPTION>
<TR><TD>abs</TD><TD>and</TD><TD>asc</TD><TD>between</TD><TD>by</TD></TR>
<TR><TD>current</TD><TD>desc</TD><TD>escape</TD><TD>exists</TD><TD>false</TD></TR>
<TR><TD>first</TD><TD>follow</TD><TD>from</TD><TD>in</TD><TD>integer</TD></TR>
<TR><TD>is</TD><TD>length</TD><TD>like</TD><TD>last</TD><TD>lower</TD></TR>
<TR><TD>not</TD><TD>null</TD><TD>or</TD><TD>real</TD><TD>start</TD></TR>
<TR><TD>string</TD><TD>true</TD><TD>upper</TD></TR>
</TABLE><P>

ANSI-standard comments may also be used. All characters after a double-hyphen up to
the end of the line are ignored.<P>

FastDB extends ANSI standard SQL operations by supporting bit manipulation 
operations. Operators <code>and</code>/<code>or</code> can be applied not only 
to boolean operands but also to operands of integer type. The result of applying the
<code>and</code>/<code>or</code> operator to integer operands is an integer
value with bits set by the bit-AND/bit-OR operation. Bit operations can be used
for efficient implementation of small sets. Also the rasing to a power
operation (x<B>^</B>y) is supported by FastDB for integer and floating point
types.<P> 


<H3><A NAME = "structure">Structures</A></H3>

FastDB accepts structures as components of records. Fields of the structure
can be accessed using the standard dot notation: <code>company.address.city</code>
<P>

Structure fields can be indexed and used in an <code>order by</code> 
specification. Structures can contain other structures as their components;
there are no limitations on the nesting level.<P>

The programmer can define methods for structures, which can be used
in queries with the same syntax as normal structure components. 
Such a method should have no arguments except a pointer to the object to which
it belongs (the <code>this</code> pointer in C++), and should return
an atomic value (of boolean, numeric, string or reference type).
Also the method should not change the object instance (immutable method).
If the method returns a string, this string should be allocated using the
<code>new char</code> operator, because it will be deleted after copying of 
its value.<P>

So user-defined methods can be used for 
the creation of <I>virtual</I> components - 
components which are not stored in the database, 
but instead are calculated
using values of other components. 
For example, the FastDB <code>dbDateTime</code>
type contains only integer timestamp components and such methods
as <code>dbDateTime::year()</code>, <code>dbDateTime::month()</code>...
So it is possible to specify queries like: "<code>delivery.year = 1999</code>"
in an application, where the <code>delivery</code> record field has 
<code>dbDateTime</code> type. Methods are executed in the context of the
application, where they are defined, and are not available to other 
applications and interactive SQL.<P>

<H3><A NAME = "array">Arrays</A></H3>
FastDB accepts arrays with dynamic length as components of records. 
Multidimensional arrays are not supported, but it is possible to
define an array of arrays. It is possible to sort records in the result set
by length of array field.
FastDB provides a set of special constructions for dealing with arrays:<P>

<OL>
<LI>It is possible to get the number of elements in the array by 
the <code>length()</code> function. 

<LI>Array elements can be fetched by the<code>[]</code> operator.
If an index expression is out of array range, an exception will be raised.

<LI>The operator <code>in</code> can be used to check if an array contains
a value specified by the left operand. This operation can be used only for arrays of
atomic type: with boolean, numeric, reference or string components.

<LI>Iteration through array elements is performed by the <code>exists</code> 
operator. A variable specified after the <code>exists</code> keyword can be used
as an index in arrays in the expression preceeded by the <code>exists</code>
quantor. This index variable will iterate through all possible array
index values, until the value of the expression will become <code>true</code> or
the index runs out of range. The condition

<PRE>
        exists i: (contract[i].company.location = 'US')
</PRE>

will select all details which are shipped by companies 
located in 'US', while the query

<PRE>
        not exists i: (contract[i].company.location = 'US')
</PRE>

will select all details which are shipped from companies outside 'US'.<P>

Nested <code>exists</code> clauses are allowed. Using nested 
<code>exists</code>
quantors is equivalent to nested loops using the correspondent
index variables. For example the query

<PRE>
        exists column: (exists row: (matrix[column][row] = 0))
</PRE>

will select all records, containing 0 in elements of a <code>matrix</code> 
field, which has type array of array of integer.
This construction is equivalent to the following
two nested loops:

<PRE>
       bool result = false;
       for (int column = 0; column < matrix.length(); column++) { 
            for (int row = 0; row < matrix[column].length(); row++) { 
	         if (matrix[column][row] == 0) { 
                     result = true;
		     break;
                 }
            }
       }
</PRE>

The order of using indices is essential! 
The result of the following query execution
<PRE>
        <code>exists row: (exists column: (matrix[column][row] = 0))</code>
</PRE>

will be completely different from the result of the previous query.
In the last case, the program simply hangs due to an infinite loop
in case of empty matrices. 
</OL>


<H3><A NAME = "string">Strings</A></H3>

All strings in FastDB have varying length and the programmer should not
worry about specification of maximal length for character fields. 
All operations acceptable for arrays are also applicable to strings. 
In addition to them, strings have a set of own operations.
First of all, strings can be compared with each other using standard
relation operators. At present, FastDB supports only the
ASCII character set (corresponds to type <code>char</code> in C) and
byte-by-byte comparison of strings ignoring locality settings.<P>

The operator <code>like</code> can be used for 
matching a string with a pattern containing special wildcard characters
'%' and '_'. The character '_' matches any single character, 
while the character '%' matches zero or more characters.
An extended form of the <code>like</code> operator together with
the <code>escape</code> keyword can be used to handle the
characters '%' and '_' in the pattern as normal characters if 
they are preceded by a special escape character, specified after
the <code>escape</code> keyword.<P> 

It is possible to search substrings within a string by the <code>in</code>
operator. The expression <code>('blue' in color)</code> will be true
for all records which <code>color</code> field contains 'blue'. 
If the length of the searched string is greater than some threshold value 
(currently 512), a Boyer-Moore substring search algorithm is used instead 
of a straightforward search implementation.<P>

Strings can be concatenated by <code>+</code> or <code>||</code> operators.
The last one was added for compatibility with the ANSI SQL standard.
As far as FastDB doesn't support the implicit conversion to string type in 
expressions, the semantic of the operator <code>+</code> can be redefined for
strings.<P>


<H3><A NAME = "reference">References</A></H3>

References can be dereferenced using the same dot notation as used for
accessing structure components. For example the following query

<PRE>
        company.address.city = 'Chicago'
</PRE>

will access records referenced by the <code>company</code> component of
a <code>Contract</code> record and extract the city component of the
<code>address</code> field of the referenced record from 
the <code>Supplier</code> table.<P>

References can be checked for <code>null</code> by <code>is null</code>
or <code>is not null</code> predicates. Also references can be compared for 
equality with each other as well as with the special <code>null</code>
keyword. When a null reference is dereferenced, an exception is raised
by FastDB.<P>

There is a special keyword <code>current</code>, which
during a table search can be used to refer to the current record.
Usually , the <code>current</code>
keyword is used for comparison of the current record identifier with
other references or locating it within an array of references. 
For example, the following query will search in the <code>Contract</code> 
table for all active contracts
(assuming that the field <code>canceledContracts</code> has a
<code>dbArray&lt; dbReference&lt;Contract&gt; &gt;</code> type): 

<PRE>
        current not in supplier.canceledContracts
</PRE><P>

FastDB provides special operators for recursive traverse of records by 
references:

<PRE>
     <code>start from</code> <I>root-references</I>
     ( <code>follow by</code> <I>list-of-reference-fields</I> )
</PRE>

The first part of this construction is used to specify root objects. 
The nonterminal <I>root-references</I> should be a variable of reference or
of array of reference type. The two special keywords <code>first</code> and
<code>last</code> can be used here, locating the first/last record in the table
correspondingly. 
If you want to check all records
referenced by an array of references or a single reference field
 for some condition, then this
construction can be used without the <code>follow by</code> part.<P>

If you specify the follow by part, then FastDB will recursively traverse 
the table of records, starting from the root
references and using a 
<I>list-of-reference-fields</I> for transition between records.
The <I>list-of-reference-fields</I> should consist of fields of
reference or of array of reference type. The traverse is done in depth first
top-left-right order (first we visit the parent node and then the siblings in 
left-to-right order).
The recursion terminates when a null reference is accessed
or an already visited record is referenced. For example the following
query will search a tree of  records with weight larger than 1 in TLR order:<P>

<PRE>
        "weight > 1 start from first follow by left, right"
</PRE><P>

For the following tree:

<PRE>
                              A:1.1
              B:2.0                             C:1.5
      D:1.3         E:1.8                F:1.2         G:0.8
</PRE>

the result of the query execution will be: 

<PRE>
('A', 1.1), ('B', 2.0), ('D', 1.3), ('E', 1.8), ('C', 1.5), ('F', 1.2)
</PRE>



<H3><A NAME = "function">Functions</A></H3>
<TABLE BORDER ALIGN="center">
<CAPTION>Predefined functions</CAPTION>
<TR><TH>Name</TH><TH>Argument type</TH><TH>Return type</TH><TH>Description</TH></TR>
<TR><TD>abs</TD><TD>integer</TD><TD>integer</TD><TD>absolute value of the argument</TD</TR>
<TR><TD>abs</TD><TD>real</TD><TD>real</TD><TD>absolute value of the argument</TD</TR>
<TR><TD>integer</TD><TD>real</TD><TD>integer</TD><TD>conversion of real to integer</TD</TR>
<TR><TD>length</TD><TD>array</TD><TD>integer</TD><TD>number of elements in array</TD</TR>
<TR><TD>lower</TD><TD>string</TD><TD>string</TD><TD>lowercase string</TD</TR><TR><TD>real</TD><TD>integer</TD><TD>real</TD><TD>conversion of integer to real</TD</TR>
<TR><TD>string</TD><TD>integer</TD><TD>string</TD><TD>conversion of integer to string</TD</TR>
<TR><TD>string</TD><TD>real</TD><TD>string</TD><TD>conversion of real to string</TD</TR>
<TR><TD>upper</TD><TD>string</TD><TD>string</TD><TD>uppercase string</TD</TR>
</TABLE><P>

A FastDB application can define its own functions. 
The function should have only a single
argument of <code>int8, real8</code> or <code>char const*</code> type and 
return a value of <code>bool, int8, real8</code> or <code>char*</code> type. 
User functions should be registered by the <code>USER_FUNC(f)</code> macro, 
which creates a static object of the <code>dbUserFunction</code> class, binding 
the function pointer and the function name. For example the following
statements make it possible to use the <code>sin</code> function in SQL
statements:

<PRE>
        #include &lt;math.h&gt;
	...
        USER_FUNC(sin);
</PRE>

Functions can be used only
within the application, where they are defined. Functions are not accessible
from other applications and interactive SQL. If a function returns a string
type , the returned string should be copied by means of the operator
<code>new</code>, because
FastDB will call the destructor after copying the returned value.<P>

In FastDB, the function argument can (but not necessarily must) be enclosed in 
parentheses. So both of the following expressions are valid:

<PRE>
        '$' + string(abs(x))
	length string y
</PRE> 
	



<H2><A NAME = "cpp">C++ interface</A></H2>
One of the primary goals of FastDB is to provide a flexible and convenient
application language interface. Anyone who has  to use 
ODBC or similar SQL interfaces will understand what I am speaking about.
In FastDB, a query can be written in C++ in the following way:<P>

<PRE>
    dbQuery q; 
    dbCursor&lt;Contract&gt; contracts;
    dbCursor&lt;Supplier&gt; suppliers;
    int price, quantity;
    q = "(price >=",price,"or quantity >=",quantity,
        ") and delivery.year=1999";
    // input price and quantity values
    if (contracts.select(q) != 0) { 
        do { 
            printf("%s\n", suppliers.at(contracts->supplier)->company);
        } while (contracts.next());
    } 
</PRE>

<H3><A NAME = "table">Table</A></H3>

Data in FastDB is stored in tables which correspond to C++ classes
whereas the table records correspond to class instances. 
The following C++ types are accepted as atomic components of
FastDB records:<P>

<TABLE BORDER ALIGN="center">
<TR><TH>Type</TH><TH>Description</TH></TR>
<TR><TD>bool</TD><TD>boolean type (<code>true,false</code>)</TD></TR>
<TR><TD>int1</TD><TD>one byte signed integer (-128..127)</TD></TR>
<TR><TD>int2</TD><TD>two bytes signed integer (-65536..65536)</TD></TR>
<TR><TD>int4</TD><TD>four bytes signed integer (-2147483647..2147483647)</TD></TR>
<TR><TD>int8</TD><TD>eight bytes signed integer (-2**63..2**63-1)</TD></TR>
<TR><TD>real4</TD><TD>four bytes ANSI floating point type</TD></TR>
<TR><TD>real8</TD><TD>eight bytes ANSI double precision floating point type</TD></TR>
<TR><TD>char const*</TD><TD>zero terminated string</TD></TR>
<TR><TD>dbReference&lt;T&gt;</TD><TD>reference to class T</TD></TR>
<TR><TD>dbArray&lt;T&gt;</TD><TD>dynamic array of elements of type T</TD></TR>
</TABLE><P>

In addition to types specified in the table above, FastDB records can
also contain nested structures of these components. 
FastDB doesn't support unsigned types to simplify the query language,
to  eliminate bugs caused by signed/unsigned comparison
and to reduce the size of the database engine.<P>

Unfortunately C++ provides no way
to get metainformation about a class at runtime (RTTI is not supported by all 
compilers and also doesn't provide enough information).
Therefore the programmer 
has to explicitly enumerate class fields to be included in the database table 
(it also makes mapping between classes and tables more flexible). 
FastDB provides a set of macros and classes to make such mapping as simple as 
possible.<P>

Each C++ class or structure, which will be used in the database, should 
contain a special method describing its fields. The macro 
<code>TYPE_DESCRIPTOR(</code><I>field_list</I><code>)</code> will construct 
this method. The single argument of this macro is - enclosed in parentheses -
a list of class field descriptors.
If you want to define some methods for the class
and make them available for the database, then the macro 
<code>CLASS_DESCRIPTOR(</code><I>name, field_list</I><code>)</code>
should be used instead of <code>TYPE_DESCRIPTOR</code>. The class name is
needed to get references to member functions.<P>

The following macros can be used for the construction of field
descriptors:

<DL>
<DT><B>FIELD(</B>name<B>)</B><DD>Non-indexed field with specified name.
<DT><B>RAWFIELD(</B>name<B>)</B><DD>Field of raw binary type. Database knows 
nothing about format of this field and treats it as sequence of bytes. 
Raw binary fields could not be indexed. 
<DT><B>KEY(</B>name, index_type<B>)</B><DD>Indexed field. <I>index_type</I> 
should be a combination of <code>HASHED</code> and <code>INDEXED</code> flags.
When the <code>HASHED</code> flag is specified, FastDB will create a hash table
for the table using this field as a key. When the <code>INDEXED</code> flag is 
specified, FastDB will create a (special kind of index) T-tree for the table 
using this field as a key. 
<DT><B>SUPERCLASS(</B>name<B>)</B><DD>Specifies information about the base class
(parent) of the current class.
<DT><B>RELATION(</B>reference, inverse_reference<B>)</B>
<DD>Specifies <I>one-to-one, one-to-many</I> or <I>many-to-many</I>
relationships between classes (tables). Both <I>reference</I>
and <I>inverse_reference</I>
fields should be of reference or of array of reference type.
<code>inverse_reference</code> is a field of the referenced table
containing the inverse reference(s) to the current table. Inverse references
are automatically updated by FastDB and are used for query optimization
(see <A HREF="#inverse">Inverse references</A>).
<DT><B>OWNER(</B>reference, inverse_reference<B>)</B>
<DD>Specifies <I>one-to-many</I> or <I>many-to-many</I>
relationship between classes (tables) of owner-member type. 
When owner record is removed all referenced member records are also removed
(cascade delete). If member record has reference to owner class, it should be 
declared with RELATION macro.
<DT><B>METHOD(</B>name<B>)</B><DD>Specifies a method of the class.
The method should be a parameterless instance member function
returning a
boolean, numeric, reference or string type. Methods should be specified after 
all other attributes of the class. 
</DL><P>

Although only atomic fields can be indexed, an index type can be specified 
for structures. The index will be created for components of the structure
only if such type of index is specified in the index type mask of the 
structure. This allows the programmers to enable or disable indices for 
structure fields depending on the role of the structure in the record.<P>

The following example illustrates the creation of a type descriptor 
in the header file:<P>

<PRE>
class dbDateTime { 
    int4 stamp;
  public:
 
    int year() { 
	return localtime((time_t*)&stamp)-&gt;tm_year + 1900;
    }
    ...

    CLASS_DESCRIPTOR(dbDateTime, 
		     (KEY(stamp,INDEXED|HASHED), 
		      METHOD(year), METHOD(month), METHOD(day),
		      METHOD(dayOfYear), METHOD(dayOfWeek),
		      METHOD(hour), METHOD(minute), METHOD(second)));
};    

class Detail { 
  public:
    char const* name;
    char const* material;
    char const* color;
    real4       weight;

    dbArray&lt; dbReference&lt;Contract&gt; &gt; contracts;

    TYPE_DESCRIPTOR((KEY(name, INDEXED|HASHED), 
		     KEY(material, HASHED), 
		     KEY(color, HASHED),
		     KEY(weight, INDEXED),
		     RELATION(contracts, detail)));
};

class Contract { 
  public:
    dbDateTime            delivery;
    int4                  quantity;
    int8                  price;
    dbReference&lt;Detail&gt;   detail;
    dbReference&lt;Supplier&gt; supplier;

    TYPE_DESCRIPTOR((KEY(delivery, HASHED|INDEXED), 
		     KEY(quantity, INDEXED), 
		     KEY(price, INDEXED),
		     RELATION(detail, contracts),
		     RELATION(supplier, contracts)));
};
</PRE>

Type descriptors should be defined for all classes used in the database.
In addition to defining type descriptors, it is necessary to establish
a mapping between C++ classes and database tables. The macro 
<code>REGISTER(</code>name<code>)</code> will do it. Unlike the
<code>TYPE_DESCRIPTOR</code> macro, the <code>REGISTER</code> macro should
be used in the implementation file and not in the header file. It constructs
a descriptor of the table associated with the class. If you are going to work
with multiple databases from one application, it is possible to register
a table in a concrete database by means of the
<code>REGISTER_IN(</code>name,database</code<code>)</code> macro. 
The parameter <code>database</code> of this macro should be a pointer to the
<code>dbDatabase</code> object. You can register tables
in the database as follows:<P>

<PRE>
REGISTER(Detail);
REGISTER(Supplier);
REGISTER(Contract);
</PRE>

The table (and correspondent class) can be used only with one database 
at each moment of time. When you open a database, FastDB imports into
the database all classes defined in the application.
If a class with the same name already exists 
in the database, its descriptor stored in the database is compared with the
descriptor of this class in the application. If the class definitions
differ, FastDB tries to convert records from the table to the new 
format. Any kind of conversion between numeric types (integer to
real, real to integer, with extension or truncation) is allowed. Also,
addition of new fields can be easily handled. But removal of fields
is only possible for empty tables (to avoid accidental data destruction).<P>

After loading all class descriptors, FastDB checks if all indices specified 
in the application class descriptor are already present in the database, 
constructs new indices and
removes indices, which are no more used. Reformatting the table and 
adding/removing indices is only possible when no more than one
application accesses the database. So when the first application is attached
to the database, it can perform table conversion. All other applications
can only add new classes to the database.<P>

There is one special internal database  <code>Metatable</code>, which
contains information about other tables in the database. C++ programmers
need not access this table, because the format of database tables is specified
by C++ classes. But in an interactive SQL program, it may be necessary to
examine this table to get information about record fields.<P>


<H3><A NAME = "query">Query</A></H3>
The class query is used to serve two purposes: 

<OL>
<LI>to construct a query and bind query parameters
<LI>to cache compiled queries
</OL>

FastDB provides overloaded '<code>=</code>' and '<code>,</code>' C++ operators
to construct query statements with parameters. Parameters can be specified  
directly in places where they are used, eliminating any mapping between
parameter placeholders and C variables. In the following sample query,
pointers to the parameters <code>price</code> and <code>quantity</code> 
are stored in the query, so that the query can be executed several times
with different parameter values. C++ overloaded functions make it possible
to automatically determine the type of the parameter, 
requiring no extra information
to be supplied by the programmer (such reducing the possibility of a bug). 

<PRE>
        dbQuery q;
        int price, quantity;
        q = "price >=",price,"or quantity >=",quantity;
</PRE> 

Since the  <code>char*</code> type can be used both for specifying a fraction
of a query (such as "price >=") and for a parameter of string type,
FastDB uses a special rule to resolve this ambiguity. This rule is based on the
assumption that there is no reason for splitting a query text into two strings
like ("price ",">=") or specifying more than one parameter sequentially
("color=",color,color). So FastDB assumes the first string to be a fraction
of the query text and switches to <I>operand mode</I>
after it. In <I>operand mode</I>, FastDB treats the <code>char*</code> argument
as a query parameter and switches back to query <I>text mode</I>, and so on...
It is also possible not to use this "syntax sugar" and construct
query elements explicitly by the 
<code>dbQuery::append(dbQueryElement::ElementType type, void const* ptr)</code>
method. Before appending elements to the query,
it is necessary to reset the query by the <code>dbQuery::reset()</code> method
('<code>operator=</code>' does it automatically).<P>

It is not possible to use C++ numeric constants as query parameters, because
parameters are accessed by reference. But it is possible to use string
constants, because strings are passed by value. There two possible ways of 
specifying string parameters in a query: using a string buffer or a
pointer to pointer to string:<P>

<PRE>
     dbQuery q;
     char* type;
     char name[256];
     q = "name=",name,"and type=",&type;

     scanf("%s", name);
     type = "A";     
     cursor.select(q);
     ...
     scanf("%s", name);
     type = "B";     
     cursor.select(q);
     ...
</PRE><P>


Query variables can neither be passed to a function as a parameter
nor be assigned to another variable.
When FastDB compiles the query, it saves the compiled tree in this object. 
The next time the query will be used, 
no compilation is needed and the already compiled
tree can be used. It saves some time needed for query compilation.<P>

FastDB provides two approaches to integrate user-defined types in databases.
The first - the definition of class methods - was already mentioned. 
The other approach deals only with query construction. Programmers should
define methods, which will not do actual calculations, but instead
return an expression (in terms of predefined database types), which
performs the necessary calculation. It is better to describe it by example.
FastDB has no builtin datetime type. Instead of this, a normal C++
class <code>dbDateTime</code> can be used by the programmer. This class defines
methods allowing to specify datetime fields in ordered lists and
to compare two dates using normal relational operators:<P>

<PRE>
class dbDateTime { 
    int4 stamp;
  public:
    ...
    dbQueryExpression operator == (char const* field) { 
	dbQueryExpression expr;
	expr = dbComponent(field,"stamp"),"=",stamp;
	return expr;
    }
    dbQueryExpression operator != (char const* field) { 
	dbQueryExpression expr;
	expr = dbComponent(field,"stamp"),"<>",stamp;
	return expr;
    }
    dbQueryExpression operator &lt; (char const* field) { 
	dbQueryExpression expr;
	expr = dbComponent(field,"stamp"),"<",stamp;
	return expr;
    }
    dbQueryExpression operator &lt;= (char const* field) { 
	dbQueryExpression expr;
	expr = dbComponent(field,"stamp"),"<=",stamp;
	return expr;
    }
    dbQueryExpression operator &gt; (char const* field) { 
	dbQueryExpression expr;
	expr = dbComponent(field,"stamp"),">",stamp;
	return expr;
    }
    dbQueryExpression operator &gt;= (char const* field) { 
	dbQueryExpression expr;
	expr = dbComponent(field,"stamp"),">=",stamp;
	return expr;
    }
    friend dbQueryExpression between(char const* field, dbDateTime& from,
				     dbDateTime& till)
    { 
	dbQueryExpression expr;
	expr=dbComponent(field,"stamp"),"between",from.stamp,"and",till.stamp;
	return expr;
    }

    friend dbQueryExpression ascent(char const* field) { 
	dbQueryExpression expr;
	expr=dbComponent(field,"stamp");
	return expr;
    }	
    friend dbQueryExpression descent(char const* field) { 
	dbQueryExpression expr;
	expr=dbComponent(field,"stamp"),"desc";
	return expr;
    }	
};
</PRE>

All these methods receive as their parameter a name of a field in the record.
This name is used to contract the full name of the record's component.
This  can be done by class <code>dbComponent</code>, which constructor takes
the name of the structure field and the name of the component of the structure
and returns a compound name separated by a '.' symbol.
The class <code>dbQueryExpression</code> is used to collect expression items.
The expression is automatically enclosed in parentheses, eliminating conflicts
with operator precedence.<P>

So, assuming a record containing a field <code>delivery</code>
of dbDateTime type, it is possible
to construct queries like these:

<PRE>
        dbDateTime from, till;
        q1 = between("delivery", from, till),"order by",ascent("delivery");
        q2 = till &gt;= "delivery"; 
</PRE>

In addition to these methods, some class specific method can be defined
in such way, for example the method <code>overlaps</code> for a region type.
The benefit of this approach is that a database engine will work
with predefined types and is able to apply indices and other optimizations
to proceed such query. And from the other side, the encapsulation of the class
implementation is preserved, so programmers should not rewrite all queries
when a class representation is changed.<P>

Variables of the following C++ types can be used as query parameters:<P>

<TABLE BORDER ALIGN="center">
<TR><TD WIDTH=50%>int1</TD><TD WIDTH=50%>bool</TD></TR>
<TR><TD>int2</TD><TD>char const*</TD></TR>
<TR><TD>int4</TD><TD>char **</TD></TR>
<TR><TD>int8</TD><TD>char const**</TD></TR>
<TR><TD>real4</TD><TD>dbReference&lt;T&gt;</TD></TR>
<TR><TD>real8</TD><TD>dbArray&lt; dbReference&lt;T&gt; &gt;</TD></TR>
</TABLE><P>



<H3><A NAME = "cursor">Cursor</A></H3>
Cursors are used to access records returned by a select statement. 
FastDB provides typed cursors, i.e. cursors associated with concrete tables.
There are two kinds of cursors in FastDB: readonly cursors and cursors for 
update. Cursors in FastDB are represented by the  C++ template class 
<code>dbCursor&lt;T&gt;</code>, 
where <code>T</code> is the name of a C++ class associated with
the database table. The cursor type should be specified in the constructor
of the cursor. By default, a read-only cursor is created.
To create a cursor for update, you should pass a parameter 
<code>dbCursorForUpdate</code> to the constructor.<P>

A query is executed either by the cursor
<code>select(dbQuery& q)</code> method.
Or by the <code>select()</code> method, 
which can be used to iterate through
all records in the table. Both methods return the number of selected records
and set the current position to the first record (if available).
A cursor can be scrolled in forward or backward direction.
The methods <code>next(), prev(), first(), last()</code> can be used to 
change the current position of the cursor. 
If no operation can be performed as there are no (more) records
available, these methods return <code>NULL</code>
and the cursor position is not changed.<P>

A cursor for class T contains an instance of class T, used for fetching the
current record. That is why table classes should have a default constructor
(constructor without parameters), which has no side effects. 
FastDB optimizes fetching records from the database, copying only data from
fixed parts of the object. String bodies are not copied, instead
of this  the correspondent field points directly into the database. The same is
true for arrays: their components have the same representation in the
database as in the application (arrays of scalar types or arrays of nested 
structures of scalar components).<P>

An application should not change
elements of strings and arrays in a database directly.
When an array method needs to update an array body,
it creates an in-memory copy of the array and updates this 
copy. If the programmer wants to update a string field, she/he should assign
to the pointer a new value, 
but don't change the string directly in the database.
It is recommended to use the <code>char const*</code> type instead of the
<code>char*</code> type for string components, 
to enable the compiler to detect the illegal usage of strings.<P>

The cursor class provides the 
<code>get()</code> method for obtaining a pointer to 
the current record (stored inside the cursor). Also the overloaded 
'<code>operator-&gt;</code>'
can be used to access components of the current record.
If a cursor is opened for update,
the current record can be changed and stored in the database
by the <code>update()</code> method or can be removed.
If the current record is removed, the next record becomes the
current. If there is no next record, then the previous record
(if it exists)  becomes the current. The method <code>removeAll()</code>
removes all records in the table.
Whereas the method <code>removeAllSelected</code> only removes 
all records selected by the cursor.<P>

When records are updated, the size of the database may increase.
Thus an extension of the database section in the virtual memory 
is needed. As a result of such remapping, base addresses of the section can be
changed and all pointers to database fields kept by applications will become 
invalid. FastDB automatically updates current records in all opened 
cursors when a database section is remapped. So, when a database is updated, 
the programmer should access record fields only through the cursor 
<code>-&gt;</code> method. She/he should  not use pointer variables.<P>

Memory used for the current selection can be released by the
<code>reset()</code> method.
This method is automatically called by the <code>select(), 
dbDatabase::commit(), dbDatabase::rollback()</code> methods
and the cursor destructor, so in most cases there is no need to
call the <code>reset()</code> method explicitly.<P>

Cursors can also be used to access records by reference. The method
<code>at(dbReference<T> const& ref)</code> sets the cursor to the record
pointed to by the reference. In this case, the selection consists exactly of
one record and the <code>next(), prev()</code> methods will always return 
<code>NULL</code>. Since cursors and references in FastDB are strictly 
typed, all necessary checking can be done statically by the compiler and 
no dynamic type checking is needed. The only kind of checking,
which is done at runtime, is checking for null references.
The object identifier of the current record in the cursor can be obtained by
the <code>currentId()</code> method.<P> 

It is possible to restrict the number of records returned by a select statement.
The cursor class has the two methods
<code>setSelectionLimit(size_t lim)</code> and
<code>unsetSelectionLimit()</code>,
which can be used to set/unset the limit
of numbers of records returned by the query. In some situations,
a  programmer may want to receive
only one record or only few first records;  so the query execution
time and size of consumed memory can be reduced by limiting the size of 
selection. But if you specify an order for selected records, 
the query with the restriction to 
<I>k</I> records will not return the first <I>k</I> records
with the smallest value of the key. Instead of this, arbitrary <I>k</I>
records will be taken and then sorted.<P>

So all operations with database data can be performed by means of
cursors. The only exception is the insert operation, for which 
FastDB provides an overloaded insert function:

<PRE>
        template&lt;class T&gt;
        dbReference<T> insert(T const& record);
</PRE>

This function will insert a record at the end of the table and return
a reference of the created object.
The order of insertion is strictly specified in FastDB
and applications can use this assumption about the record order in the
table. For applications widely using references for navigation between
objects, it is necessary to have some <I>root</I> object, from which a
traversal by references can be made. A good candidate for such root object
is the first record in the table (it is also the oldest record in the 
table). This record can be accessed by execution of the <code>select()</code>
method without parameter. The current record in the cursor will
be the first record in the table.<P>


The C++ API of FastDB defines a special <code>null</code> variable
of reference type.
It is possible to compare the <code>null</code> variable with references 
or assign it to the reference:<P>

<PRE>
        void update(dbReference&lt;Contract&gt; c) {
            if (c != null) { 
	        dbCursor&lt;Contract&gt; contract(dbCursorForUpdate);
		contract.at(c);
		contract-&gt;supplier = null;
            }
        }
</PRE>



<H3><A NAME = "database">Database</A></H3>
The class <code>dbDatabase</code> controls the application interactions
with the database. It performs synchronization of concurrent accesses to the
database, transaction management, memory allocation, error handling,...<P>

The constructor of <code>dbDatabase</code> objects allows programmers to specify
some database parameters:

<PRE>
    dbDatabase(dbAccessType type = dbAllAccess,
	       size_t dbInitSize = dbDefaultInitDatabaseSize,
	       size_t dbExtensionQuantum = dbDefaultExtensionQuantum,
	       size_t dbInitIndexSize = dbDefaultInitIndexSize,
	       int nThreads = 1);
</PRE>

A database can be opened in readonly mode (<code>dbDatabase::dbReadOnly</code>
access type) or in normal mode, allowing modification of the database 
(<code>dbDatabase::dbAllAccess</code>). When the database is opened in readonly 
mode, no new class definitions can be added to the database and definitions
of existing classes and indices can not be altered.<P>

The parameter
<code>dbInitSize</code> specifies the initial size of the database file.
The database file increases on demand; setting the initial size can only 
reduce the number of reallocations (which can take a lot of time).
In the current implementation of the FastDB database
the size is at least doubled at each extension.
The default value of this parameter is 4 megabytes.<P>

The parameter <code>dbExtensionQuantum</code>
specifies the quantum of extension of the
memory allocation bitmap. 
Briefly speaking, the value of this parameter specifies how much memory
will be allocated sequentially without attempt to reuse space of
deallocated objects. The default value of this parameter is 4 Mb.
See section <A HREF="#memory">Memory allocation</A> for more details.<P> 

The parameter <code>dbInitIndexSize</code> specifies the initial index size. 
All objects in FastDB are accessed through an object index.
There are two copies of this object index:
current and committed. Object indices are reallocated on 
demand; setting an initial index size can only reduce (or increase)
the number of reallocations. The default value of this parameter is 64K object 
identifiers.<P>

And the last parameter <code>nThreads</code> controls the level of query
parallelization. If it is greater than 1, then FastDB can start the parallel
execution of some queries (including sorting the result). 
The specified number of parallel threads will
be spawned by the FastDB engine in this case. Usually it does not make
sense to specify the value of this parameter to be greater than the
number of online CPUs in the system. It is also possible to pass zero
as the value of this parameter. In this case, FastDB will automatically detect
the number of online CPUs in the system. The number of threads also can be set 
by the <code>dbDatabase::setConcurrency</code> method at any moment of time.<P>

The class <code>dbDatabase</code> contains a static field 
<code>dbParallelScanThreshold</code>, which specifies a threshold for the
number of records in the table after which query parallelization
is used. The default value of this parameter is 1000.<P>

The database can be opened by the
<code>open(char const* databaseName, char const* fileName = NULL)</code> method.
If the file name parameter is omitted, it is constructed from
the database name by appending the ".fdb" suffix. The database name should
be an arbitrary identifier consisting of any symbols except '\'.
The method&nbsp;<code>open</code> returns <code>true</code> if the database was
successfully opened; or <code>false</code> if the open operation failed. 
In the last case, the database <code>handleError</code> method is called with a
<code>DatabaseOpenError</code> error code. A database session can be terminated
by the <code>close</code> method, which implicitly commits current transactions.<P>

In a multithreaded application each thread, which wants to access the database,
should first be attached to it. The method <code>dbDatabase::attach()</code>
allocates thread specific data and attaches the thread to the database.
This method is automatically called by the <code>open()</code> method, so
there is no reason to call the <code>attach()</code> method for the thread,
which opens the database. When the thread finishes work with the database, it should
call the <code>dbDatabase::detach()</code> method. The method 
<code>close</code> automatically invokes the <code>detach()</code> method. 
The method <code>detach()</code> implicitly commits current transactions.
An attempt to access a database by a detached thread causes an assertion failure.<P>

FastDB is able to perform compilation and execution of queries in parallel, 
providing significant increase of performance in multiprocessor systems.
But concurrent updates of the database are not possible (this is the price
for the efficient log-less transaction mechanism and zero time recovery).
When an application wants to modify the database (open a cursor for update or
insert a new record in the table), it first locks the database in exclusive mode, 
prohibiting accesses to the database by other applications, even for
read-only queries. So to avoid blocking of database applications for a long 
time, the modification transaction should be as short as possible. 
No blocking operations (like waiting for input from the user) should be
done within this transaction.<P>

Using only shared and exclusive locks on the database
level, allows FastDB to almost eliminate overhead of locking and 
to optimize the speed of execution of non-conflicting operations. But if many 
applications simultaneously update different parts of the database, then the
approach used in FastDB will be very inefficient. That is why FastDB is most
suitable for a single-application database access model or for
multiple applications with a read-dominated access pattern model.<P>
 
Both cursor and query objects should be used only by one thread in a
multithreaded application. If there are more than one threads in your
application, use local variables for cursors and queries objects 
in each thread. The <code>dbDatabase</code> object is shared between all
threads and uses thread specific data to perform query
compilation and execution in parallel with minimal synchronization overhead.
There are few global things, which require synchronization: symbol table,
pool of tree node,... But scanning, parsing and execution of the query can
be done without any synchronization, providing high level of concurrency
at multiprocessor systems.<P>

A database transaction is started by the first select or an insert operation.
If a cursor for update is used, then the database is locked in exclusive
mode, prohibiting access to the database by other applications and threads.
If a read-only cursor is used, then the database is locked in shared mode, preventing 
other applications and threads from modifying the database,
but allowing the execution of concurrent read requests.
A transaction should be explicitly terminated
either by the <code>dbDatabase::commit()</code> method, which fixes all 
changes done by the transaction in the database; or by the
<code>dbDatabase::rollback()</code> method to undo all modifications 
done by transactions. The method <code>dbDatabase::close()</code> automatically 
commits current transactions.<P>

If you start a transaction by performing selection using a read-only cursor and
then use a cursor for update to perform some modifications of the database, 
the database will be first locked in shared mode; then the lock will be upgraded
to exclusive mode. This can cause a deadlock problem if the database is simultaneously 
accessed by several applications. Imagine that application A starts
a read transaction and application B also starts a read transaction. Both
of them hold shared locks on the database. If both of them want to
upgrade their locks to exclusive mode, they will forever block each other
(exclusive lock can not be granted until a shared lock of another process exists).
To avoid such situations try to use a cursor for update at the beginning of the
transaction; or explicitly use the <code>dbdatabase::lock()</code> method.
More information about the implementation of transactions in FastDB can be found 
in section <A HREF="#transaction">Transactions</A>.<P>

It is possible to explicitly lock the database by the <code>lock()</code> method. 
Locking is usually done automatically -  there are only few cases when
you will want to use this method. It will lock the database in exclusive
mode until the end of the current transaction.<P>

A backup of the database can be done by the 
<code>dbDatabase::backup(char const* file)</code>
method. A backup locks the database in shared mode and flushes an image of the
database from main memory to the specified file. Because of using a shadow object index, 
the database file is always in a consistent state, so recovery from the backup can
be performed just by renaming the backup file (if backup was performed on tape, it
should be first restored to the disk).<P>

The class <code>dbDatabase</code> is also responsible for handling various 
application errors, such as syntax errors during query compilation,
out of range index or null reference access during query execution.
There is a virtual method <code>dbDatabase::handleError</code>, which handles
these errors:


<PRE>
        virtual void handleError(dbErrorClass error, 
                                 char const*  msg = NULL, 
                                 int          arg = 0);
</PRE>

A programmer can derive her/his own subclass from the <code>dbDatabase</code>
class and redefine the default reaction on errors.<P>




<TABLE BORDER ALIGN="center">
<CAPTION>Error classes and default handling</CAPTION>
<TR><TH>Class</TH><TH>Description</TH><TH>Argument</TH><TH>Default reaction</TH></TR>
<TR><TD>QueryError</TD><TD>query compilation error</TD><TD>position in query string</TD><TD>abort compilation</TD></TR> 
<TR><TD>ArithmeticError</TD><TD>arithmetic error during division or power operations</TD><TD ALIGN="center">-</TD><TD>terminate application</TD></TR>
<TR><TD>IndexOutOfRangeError</TD><TD>index is out if array bounds</TD><TD>value of index</TD><TD>terminate application</TD></TR>
<TR><TD>DatabaseOpenError</TD><TD>error while database opening</TD><TD ALIGN="center">-</TD><TD>open method will return <code>false</code></TD></TR>
<TR><TD>FileError</TD><TD>failure of file IO operation</TD><TD>error code</TD><TD>terminate application</TD></TR>
<TR><TD>OutOfMemoryError</TD><TD>not enough memory for object allocation</TD><TD>requested allocation size</TD><TD>terminate application</TD></TR>
<TR><TD>Deadlock</TD><TD>upgrading lock causes deadlock</TD><TD ALIGN="center">-</TD><TD>terminate application</TD></TR>
<TR><TD>NullReferenceError</TD><TD>null reference is accessed during query execution<TD ALIGN="center">-</TD><TD>terminate application</TD></TR>
</TABLE><P>


<H2><A NAME = "cli">Call level interface</A></H2>

Interface described in previous section provides convenient and reliable mechanism for
accessing data from C++. It has two drawbacks:

<OL>
<LI>It is very C++ specific and can not be used with other programming languages
<LI>It is suitable only for local connections to the database (within one system).
</OL>

Interface described below outcomes these two restrictions. It consists of the set of
pure ANSI C functions and using it mapping of any programming language to the FastDB
database can be easily implemented. Connection between client and serves is performed by 
sockets (either local, either standard TCP/IP sockets). Certainly this interface is
less convenient and more error prone than C++ interface, but this is a cost of its 
flexibility. All types, constants and functions are declared in <A HREF="cli.h">cli.h</A>
file.<P>

FastDB provides multithreaded server for handling client CLI sessions. This server can be 
started from <A HREF="#subsql">SubSQL</A> utility by 
<code>start server 'HOST:PORT' &lt;number-of-threads&gt;</code> command. 
This server will accept local (within one system) and global clients connections and 
attach one thread from the threads pool to each connection. The size of thread's pool
is controlled by <i>number-of-threads</i> parameters. But the server can spawn more
than specified number of threads if there are many active connections. A thread is attached
to the client until the end of the session. If session is abnormally terminated, all
changes made by the client are rollbacked. The server can be stopped by correspondent
<code>stop server 'HOST:PORT'</code> command.<P>


<A NAME="cli_errors">
<TABLE><CAPTION><FONT SIZE=+1><B><U>CLI functions return codes</U></B></FONT></CAPTION>
<TR><TH>Error code</TH><TH>Description</TH></TR>
<TR><TD>cli_ok</TD><TD>Succeful completion</TD></TR>
<TR><TD>cli_bad_address</TD><TD>Invalid format of server URL</TD></TR>
<TR><TD>cli_connection_refused</TD><TD>Conenction with server could not be established</TD></TR>
<TR><TD>cli_bad_statement</TD><TD>Text of SQL statement is not correct</TD></TR>
<TR><TD>cli_parameter_not_found</TD><TD>Parameter was not found in statement</TD></TR>
<TR><TD>cli_unbound_parameter</TD><TD>Parameter was not specified</TD></TR>
<TR><TD>cli_column_not_found</TD><TD>No sucj colunm in the table</TD></TR>
<TR><TD>cli_incompatible_type</TD><TD>Conversion between application and database type is not possible</TD></TR>
<TR><TD>cli_network_error</TD><TD>Connection with server is broken</TD></TR>
<TR><TD>cli_runtime_error</TD><TD>Error during query execution</TD></TR>
<TR><TD>cli_bad_descriptor</TD><TD>Invalid statement/session description</TD></TR>
<TR><TD>cli_unsupported_type</TD><TD>Unsupported type for parameter or colunm</TD></TR>
<TR><TD>cli_not_found</TD><TD>Record was not found</TD></TR>
<TR><TD>cli_not_update_mode</TD><TD>Attempt to update records selected by view only cursor</TD></TR> 
<TR><TD>cli_table_not_found</TD><TD>There is no table with specified name in the database</TD></TR>
<TR><TD>cli_not_all_columns_specified</TD><TD>Insert statement doesn't specify values for all table columns</TD></TR>
<TR><TD>cli_not_fetched</TD><TD><A HREF="#cli_fetch"><code>cli_fetch</code></A> method was not called</TD></TR>
</TABLE></A>
    
<P>

<A NAME = "cli_types">
<TABLE><CAPTION><FONT SIZE=+1><B><U>Supported types</U></B></FONT></CAPTION>
<TR><TH>Type</TH><TH>Description</TH><TH>Size</TH></TR>
<TR><TD>cli_oid</TD><TD>Object identifier</TD><TD>4</TD></TR>
<TR><TD>cli_bool</TD><TD>Boolean type</TD><TD>1</TD></TR>
<TR><TD>cli_int1</TD><TD>Timy interger type</TD><TD>1</TD></TR>
<TR><TD>cli_int2</TD><TD>Small interger type</TD><TD>2</TD></TR>
<TR><TD>cli_int4</TD><TD>Interger type</TD><TD>4</TD></TR>
<TR><TD>cli_int8</TD><TD>Big interger type</TD><TD>8</TD></TR>
<TR><TD>cli_real4</TD><TD>Single precision floating point type</TD><TD>4</TD></TR>
<TR><TD>cli_real8</TD><TD>Double precision floating point type</TD><TD>8</TD></TR>
<TR><TD>cli_asciiz</TD><TD>Zero terminated string of bytes</TD><TD>1*N</TD></TR>
<TR><TD>cli_pasciiz</TD><TD>Pointer to zero terminated string</TD><TD>1*N</TD></TR>
<TR><TD>cli_array_of_oid</TD><TD>Array of references</TD><TD>4*N</TD></TR>
<TR><TD>cli_array_of_bool</TD><TD>Array of booleans</TD><TD>1*N</TD></TR>
<TR><TD>cli_array_of_int1</TD><TD>Array of tiny integers</TD><TD>1*N</TD></TR>
<TR><TD>cli_array_of_int2</TD><TD>Array of small integers</TD><TD>2*N</TD></TR>
<TR><TD>cli_array_of_int4</TD><TD>Array of integers</TD><TD>4*N</TD></TR>
<TR><TD>cli_array_of_int8</TD><TD>Array of big integers</TD><TD>8*N</TD></TR>
<TR><TD>cli_array_of_real4</TD><TD>Array of reals</TD><TD>4*N</TD></TR>
<TR><TD>cli_array_of_real8</TD><TD>Array of long reals</TD><TD>8*N</TD></TR>
</TABLE></A><P>

<HR> 

<A NAME = "cli_open"><pre>
int cli_open(char const* server_url, 
	     int         max_connect_attempts,
	     int         reconnect_timeout_sec);
</pre></A>
<DL><DD>
Establish connection with the server 
<DL>
<DT><B>Parameters</B>
<DD><code>server_url</code> - zero terminated string with server address and port, 
for example "localhost:5101", "195.239.208.240:6100",...
<DD><code>max_connect_attempts</code>  - number of attempts to establish connection
<DD><code>reconnect_timeout_sec</code> - timeput in seconds between connection attempts
<DT><B>Returns</B>
<DD><code>&gt;= 0</code> - connectiondescriptor to be used in all other cli calls
<DD><code>&lt;  0</code> - error code as described in <A HREF="#cli_types"><code>cli_result_code</code></A> enum
</DL></DL>

<HR>

<A NAME = "cli_close"><pre>
int cli_close(int session);
</pre></A>
<DL><DD>
Close session
<DL>
<DT><B>Parameters</B>
<DD><code>session</code> - session descriptor returned by <A HREF="#cli_open"><code>cli_open</code></A>
<DT><B>Returns</B>
<DD>result code as described in <A HREF="#cli_types"><code>cli_result_code</code></A> enum
</DL></DL>

<HR>

<A NAME = "cli_statement"><pre>
int cli_statement(int session, char const* stmt);
</pre></A>
<DL><DD>
Specify SubSQL statement to be executed at server.
Binding to the parameters and columns can be established       
<DL>
<DT><B>Parameters</B>
<DD><code>session</code> - session descriptor returned by <A HREF="#cli_open"><code>cli_open</code></A>
<DD><code>stmt</code>    - zero terminated string with SubSQL statement  
<DT><B>Returns</B>
<DD><code>&gt;= 0</code> - statement descriptor
<DD><code>&lt;  0</code> - error code as described in <A HREF="#cli_types"><code>cli_result_code</code></A> enum
</DL></DL>

<HR>

<A NAME = "cli_parameter"><pre>
int cli_parameter(int         statement,
		  char const* param_name, 
		  int         var_type,
		  void*       var_ptr);
</pre></A>
<DL><DD>
Bind parameter to the statement
<DL>
<DT><B>Parameters</B>
<DD><code>statement</code>  - statememt descriptor returned by <A HREF="#cli_statement"><code>cli_statement</code></A>
<DD><code>param_name</code> - zero terminated string with parameter name.  
Paramter name should start with '%'
<DD><code>var_type</code>   - type of variable as described in cli_var_type enum.
Only scalar and zero terminated string types are supported.
<DD><code>var_ptr</code>  - pointer to the variable
<DT><B>Returns</B>
<DD>result code as described in <A HREF="#cli_types"><code>cli_result_code</code></A> enum
</DL></DL>

<HR>

<A NAME = "cli_column"><pre>
int cli_column(int         statement,
	       char const* column_name, 
	       int         var_type, 
	       int*        var_len, 
	       void*       var_ptr);
</pre></A>
<DL><DD>
Bind extracted column of select or insert statement
<DL>
<DT><B>Parameters</B>
<DD><code>statement</code> - statememt descriptor returned by <A HREF="#cli_statement"><code>cli_statement</code></A>
<DD><code>column_name</code> - zero terminated string with column name  
<DD><code>var_type</code> - type of variable as described in cli_var_type enum
<DD><code>var_len</code> - pointer to the variable to hold length of array variable.
This variable should be assigned the maximal length of the array/string buffer, 
pointed by <code>var_ptr</code>. After the execution of the statement it is assigned the 
real length of the fetched array/string. If it is large than length of the buffer, 
then only part of the array will be placed in the buffer, but <code>var_len</code> 
still will contain the actual array length. 
<DD><code>var_ptr</code> - pointer to the variable
<DT><B>Returns</B>
<DD>result code as described in <A HREF="#cli_types"><code>cli_result_code</code></A> enum
</DL></DL>

<HR>

<A NAME = "cli_array_column"><pre>
typedef void* (*cli_column_set)(int var_type, void* var_ptr, int len);
typedef void* (*cli_column_get)(int var_type, void* var_ptr, int* len);

int cli_array_column(int            statement,
		     char const*    column_name, 
		     int            var_type,
		     void*          var_ptr,
		     cli_column_set set,
		     cli_column_get get);
</pre></A>
<DL><DD>
Specify get/set functions for the array column
<DL>
<DT><B>Parameters</B>
<DD><code>statement</code> - statememt descriptor returned by <A HREF="#cli_statement"><code>cli_statement</code></A>
<DD><code>column_name</code> - zero terminated string with column name  
<DD><code>var_type</code> - type of variable as described in cli_var_type enum
<DD><code>var_ptr</code> - pointer to the variable
<DD><code>set</code> - function which will be called to construct fetched field. 
It receives pointer to the variable, length of the fetched array and returns pointer 
to the array's elements.
<DD><code>get</code> - function which will be called to update the field in the 
database. Given pointer to the variable, it should return pointer to the array elements 
and store length of the array to the variable pointer by len parameter
<DT><B>Returns</B>
<DD>result code as described in <A HREF="#cli_types"><code>cli_result_code</code></A> enum
</DL></DL>

<HR>

    
<A NAME = "cli_fetch"><pre>
enum { 
    cli_view_only, 
    cli_for_update
};

int cli_fetch(int statement, int for_update);
</pre></A>
<DL><DD>
Execute select statement.
<DL>
<DT><B>Parameters</B>
<DD><code>statement</code> - statememt descriptor returned by <A HREF="#cli_statement"><code>cli_statement</code></A>
<DD><code>for_update</code> - not zero if fetched rows will be updated 
<DT><B>Returns</B>
<DD><code>&gt;= 0</code> - success, for select statements number of fetched rows is returned
<DD><code>&lt;  0</code> - error code as described in <A HREF="#cli_types"><code>cli_result_code</code></A> enum
</DL></DL>

<HR>

<A NAME = "cli_insert"><pre>
int cli_insert(int statement, cli_oid_t* oid);
</pre></A>
<DL><DD>
Execute insert statement.
<DL>
<DT><B>Parameters</B>
<DD><code>statement</code> - statememt descriptor returned by <A HREF="#cli_statement"><code>cli_statement</code></A>
<DD><code>oid</code> - object identifier of created record. 
<DT><B>Returns</B>
<DD>status code as described in <A HREF="#cli_types"><code>cli_result_code</code></A> enum
</DL></DL>

<HR>


<A NAME = "cli_get_first"><pre>
int cli_get_first(int statement);
</pre></A>
<DL><DD>
Get first row of the selection.
<DL>
<DT><B>Parameters</B>
<DD><code>statement</code> - statememt descriptor returned by <A HREF="#cli_statement"><code>cli_statement</code></A>
<DT><B>Returns</B>
<DD>result code as described in <A HREF="#cli_types"><code>cli_result_code</code></A> enum
</DL></DL>

<HR>


<A NAME = "cli_get_last"><pre>
int cli_get_last(int statement);
</pre></A>
<DL><DD>
Get last row of the selection.
<DL>
<DT><B>Parameters</B>
<DD><code>statement</code> - statememt descriptor returned by <A HREF="#cli_statement"><code>cli_statement</code></A>
<DT><B>Returns</B>
<DD>result code as described in <A HREF="#cli_types"><code>cli_result_code</code></A> enum
</DL></DL>

<HR>


<A NAME = "cli_get_next"><pre>
int cli_get_next(int statement);
</pre></A>
<DL><DD>
Get next row of the selecteion. If get_next records is called exactly after 
<A HREF="#cli_fetch"><code>cli_fetch</code></A> function call, is will fetch the first record in selection.
<DL>
<DT><B>Parameters</B>
<DD><code>statement</code> - statememt descriptor returned by <A HREF="#cli_statement"><code>cli_statement</code></A>
<DT><B>Returns</B>
<DD>result code as described in <A HREF="#cli_types"><code>cli_result_code</code></A> enum
</DL></DL>

<HR>


<A NAME = "cli_get_prev"><pre>
int cli_get_prev(int statement);
</pre></A>
<DL><DD>
Get previous row of the selecteion. If get_next records is called exactly after 
<A HREF="#cli_fetch"><code>cli_fetch</code></A> function call, is will fetch the last record  in selection.
<DL>
<DT><B>Parameters</B>
<DD><code>statement</code> - statememt descriptor returned by <A HREF="#cli_statement"><code>cli_statement</code></A>
<DT><B>Returns</B>
<DD>result code as described in <A HREF="#cli_types"><code>cli_result_code</code></A> enum
</DL></DL>

<HR>


<A NAME = "cli_get_oid"><pre>
cli_oid_t cli_get_oid(int statement);
</pre></A>
<DL><DD>
Get object identifier of the current record
<DL>
<DT><B>Parameters</B>
<DD><code>statement</code> - statememt descriptor returned by <A HREF="#cli_statement"><code>cli_statement</code></A>
<DT><B>Returns</B>
<DD>object identifier or 0 if no object is seleected
</DL></DL>

<HR>


<A NAME = "cli_update"><pre>
int cli_update(int statement);
</pre></A>
<DL><DD>
Update the current row in the selection. You have to set
for_update parameter of <A HREF="#cli_fetch"><code>cli_fetch</code></A> to 1 in order to be able 
to perform updates. Updated value of row fields will be taken
from bound column variables. 
<DL>
<DT><B>Parameters</B>
<DD><code>statement</code> - statememt descriptor returned by <A HREF="#cli_statement"><code>cli_statement</code></A>
<DT><B>Returns</B>
<DD>result code as described in <A HREF="#cli_types"><code>cli_result_code</code></A> enum
</DL></DL>

<HR>


<A NAME = "cli_remove"><pre>
int cli_remove(int statement);
</pre></A>
<DL><DD>
Remove all selected records. You have to set <code>for_update</code> parameter of 
<A HREF="#cli_fetch"><code>cli_fetch</code></A> to 1 in order to be able to remove records. 
<DL>
<DT><B>Parameters</B>
<DD><code>statement</code> - statememt descriptor returned by <A HREF="#cli_statement"><code>cli_statement</code></A>
<DT><B>Returns</B>
<DD>result code as described in <A HREF="#cli_types"><code>cli_result_code</code></A> enum
</DL></DL>

<HR>

<A NAME = "cli_free"><pre>
int cli_free(int statement);
</pre></A>
<DL><DD>
Deallocate statement and all associated data
<DL>
<DT><B>Parameters</B>
<DD><code>statement</code> - statememt descriptor returned by <A HREF="#cli_statement"><code>cli_statement</code></A>  
<DT><B>Returns</B>
<DD>result code as described in <A HREF="#cli_types"><code>cli_result_code</code></A> enum
</DL></DL>

<HR>

<A NAME = "cli_commit"><pre>
int cli_commit(int session);
</pre></A>
<DL><DD>
Commit current database transaction
<DL>
<DT><B>Parameters</B>
<DD><code>session</code> - session descriptor as returned by <A HREF="#cli_open"><code>cli_open</code></A>
<DT><B>Returns</B>
<DD>result code as described in <A HREF="#cli_types"><code>cli_result_code</code></A> enum
</DL></DL>

<HR>

<A NAME = "cli_abort"><pre>
int cli_abort(int session);
</pre></A>
<DL><DD>
Abort current database transaction
<DL>
<DT><B>Parameters</B>
<DD><code>session</code> - session descriptor as returned by <A HREF="#cli_open"><code>cli_open</code></A>
<DT><B>Returns</B>
<DD>result code as described in <A HREF="#cli_types"><code>cli_result_code</code></A> enum
</DL></DL>

<HR>


<H2><A NAME = "optimization">Query optimization</A></H2>

The execution of queries, when all data is present in memory, is very fast,
compared with the time for query execution in a traditional RDBMS. But FastDB
even more increases the speed for query execution by applying several optimizations:
using indices, inverse references and query parallelization. The following 
sections supply more information about these optimizations.<P>

<H3><A NAME = "indices">Using indices in queries</A></H3>
Indices are a traditional approach for increasing RDBMS performance. FastDB
uses two types of indices: <A HREF="#hashtable">extensible hash table</A>
and <A HREF="#ttree">T-tree</A>. The first type provides the fastest way (with constant 
time in average) to access a record with a specified value of the key.
Whereas the T-tree, which is acombination of AVL-Tree and array, has the 
same role for a MMRDBMS as the B-Tree for a traditional RDBMS. It provides
search, insertion and deletion operations with guaranteed logarithmic
complexity (i.e.  the time for performing a search/insert/delete operation
for a table with <I>N</I> records is <I>C*log2(N)</I>, where <I>C</I> is
some constant). The T-tree is more suitable for a MMDBMS than a B-Tree, because the 
last one tries to minimize the number of page loads (which is an expensive 
operation in disk-based databases), while the T-tree tries to optimize the number of 
compare/move operations. The T-tree is the best type to use with range operations or 
when the order of records is significant.<P>

FastDB uses simple rules for applying indices, allowing a programmer to predict 
when an index and which one will be used. The check for 
index applicability is done during each query execution, so the decision 
can be made depending on the values of the operands. 
The following rules describe the algorithm of applying indices by FastDB:<P>

<UL>
<LI>The compiled condition expression is always inspected from left to right.
<LI>If the topmost expression is <B>AND</B> then try to apply an index to the
left part of the expression, using the right part as a filter.
<LI>If the topmost expression is <B>OR</B> and an index can be applied 
to the left part of the expression, then apply the index and test the right part
for the possibility to use indices. 
<LI>Otherwise, an index is applicable to the expression, when 
<OL>
   <LI> the topmost expression is a relational operation 
       (<code>= &lt; &gt; &lt;= &gt;= between like</code>)
   <LI> the type of operands is boolean, numeric or string
   <LI> the right operand(s) of the expression is either a constant literal 
        or a C++ variable, and
   <LI> the left part is an indexed field of the record 
   <LI> the index is compatible with a relational operation
</OL>
</UL><P>    

Now we should make clear what the phrase <I>"index is compatible with operation"</I>
means and which type of index is used in each case. A hash table can be used when:<P>

<UL>
<LI>a comparison for equality <code>=</code> is used. 
<LI>a <code>between</code> operation is used and the values of both bounds operands
are the same.
<LI>a <code>like</code> operation is used and the pattern string contains
no special characters ('%' or '_') and no escape characters (specified in an
<code>escape</code> part).
</UL><P>

A T-tree index can be applied if a hash table is not applicable (or a field
is not hashed) and:<P>

<UL>
<LI>a comparison operation (<code>= &lt; &gt; &lt;= &gt;= between</code>)
is used. 
<LI>a <code>like</code> operation is used and the pattern string contains
no empty prefix (i.e. the first character of the pattern is not '%' or '_').
</UL><P>

If an index is used to search the prefix of a <code>like</code> expression, and
the suffix is not just the '%' character, then an index search operation can return
more records than really match the pattern. In this case we should filter the
index search output by applying a pattern match operation.<P>

When the search condition is a disjunction of several subexpressions
(the expression contains several alternatives combined by the <code>or</code>
operator), then several indices can be used for the query execution. 
To avoid record duplicates in this case, a bitmap is used in the cursor
to mark records already selected.<P>

If the search condition requires a sequential table scan, the T-tree index 
still can be used if the <code>order by</code> clause contains the single 
record field for which the T-tree index is defined. As far as sorting is very 
expensive an operation, using an index instead of sorting significantly 
reduces the time for the query execution.<P>

It is possible to check which indices are used for the query execution,
and a number of probes can be done during index search, by compiling FastDB
with the option <code>-DDEBUG=DEBUG_TRACE</code>. In this case, FastDB will
dump trace information about database functionality including information
about indices.<P>

    
<H3><A NAME = "inverse">Inverse references</A></H3>
Inverse references provide an efficient and reliable way to establish
relations between tables. FastDB uses information about inverse references
when a record is inserted/updated/deleted and also for query optimization.
Relations between records can be of one of the following types:
<I>one-to-one, one-to-many</I> and <I>many-to-many</I>. 

<UL>
<LI>A <I>one-to-one</I> relation is represented by a reference field in the self and 
the target record.
<LI>A <I>one-to-many</I> relation is represented by a reference field in the self
record and an array of references field in the record of the target table.
<LI>A <I>many-to-one</I> relation is represented by an array of references field in 
the self record and a reference field in the record of the referenced table.
<LI>A <I>many-to-many</I> relation is represented by an array of references field in
the self and in the target record.
</OL><P>

When a record with declared relations is inserted in the table, the inverse
references in all tables, which are in relation with this record, are updated to
point to this record. When a record is updated and a field specifying the
record's relationship is changed, then the inverse references are also 
reconstructed automatically by removing references to the updated record
from those records which are no longer in relation with the updated record and by
setting inverse references to the updated record for new records included in the
relation. When a record is deleted from the table, references to it are 
removed from all inverse reference fields.<P>

Due to efficiency reasons, FastDB is not able to guarantee the consistency of 
all references. If you remove a record from the table, there still
can be references to the removed record in the database. Accessing these references 
can cause unpredictable behavior of the application and even database corruption.
Using inverse references allows to eliminate this problem, because
all references will be updated automatically and the consistency of references
is preserved.<P>


Let's use the following table definitions as an example:<P>

<PRE>
class Contract;

class Detail { 
  public:
    char const* name;
    char const* material;
    char const* color;
    real4       weight;

    dbArray&lt; dbReference&lt;Contract&gt; &gt; contracts;

    TYPE_DESCRIPTOR((KEY(name, INDEXED|HASHED), 
		     KEY(material, HASHED), 
		     KEY(color, HASHED),
		     KEY(weight, INDEXED),
		     RELATION(contracts, detail)));
};

class Supplier { 
  public:
    char const* company;
    char const* location;
    bool        foreign;

    dbArray&lt; dbReference&lt;Contract&gt; &gt; contracts;

    TYPE_DESCRIPTOR((KEY(company, INDEXED|HASHED), 
		     KEY(location, HASHED), 
		     FIELD(foreign),
		     RELATION(contracts, supplier)));
};


class Contract { 
  public:
    dbDateTime            delivery;
    int4                  quantity;
    int8                  price;
    dbReference&lt;Detail&gt;   detail;
    dbReference&lt;Supplier&gt; supplier;

    TYPE_DESCRIPTOR((KEY(delivery, HASHED|INDEXED), 
		     KEY(quantity, INDEXED), 
		     KEY(price, INDEXED),
		     RELATION(detail, contracts),
		     RELATION(supplier, contracts)));
};
</PRE><P>

In this example there are one-to-many relations between the tables
Detail-Contract and Supplier-Contract. When a <code>Contract</code>
record is inserted in the database, it is necessary only to set the references 
<code>detail</code> and <code>supplier</code> to the correspondent 
records of the <code>Detail</code> and the <code>Supplier</code> table. 
The inverse references <code>contracts</code> in these records will be updated 
automatically. The same happens when a <code>Contract</code> record is 
removed: references to the removed record will be automatically excluded
from the <code>contracts</code> field of the referenced <code>Detail</code> and 
<code>Supplier</code> records.<P>

Moreover, using inverse reference allows to choose more effective plans for query
execution. Consider the following query, selecting all details
shipped by some company:<P>

<PRE>
    q = "exists i:(contracts[i].supplier.company=",company,")";
</PRE>

The straightforward approach to execute this query is scanning the
<code>Detail</code> table and testing each record for this condition.
But using inverse references we can choose another approach: perform an
index search in the <code>Supplier</code> table for records with the specified
company name and then use the inverse references to locate records from the
<code>Detail</code> table, which are in transitive relation with the
selected supplier records. Certainly we should eliminate duplicates of
records, which can appear because the company can ship a number of different 
details. This is done by a bitmap in the cursor object.
As far as index search is significantly faster than sequential search
and accessing records by reference is very fast an operation, the total
time of such query execution is much shorter compared with the
straightforward approach.<P>

Starting from 1.20 version FastDB supports cascade deletes.
If field is declared using OWNER macro, the record is treated as owner of 
the hierarchical relation. When the owner records is removed all 
members of this relation (records referenced from the owner) will be 
automatically removed. If member record of the relation should contain
reference to the owner record, this field should be declared using
RELATION macro.<P>
  

<H3><A NAME = "realtime">Realtime issues</A></H3>
FastDB is not a true realtime system, because it is based on non-realtime 
operating systems (like NT or Unix), which mostly doesn't fit realtime 
requirements. 
But with some restrictions it is possible to give quite precise estimations
for query execution time in FastDB. Such restrictions include:<P>

<OL>
<LI>The whole database is in the physical memory and no swapping can take place
during application work.
<LI>Other applications should not consume much CPU time and system resources
(especially memory), to minimize the influence on the main application.
<LI>The required time of reaction is significantly longer than the quantum of 
processes rescheduling in the operating system. 
</OL><P>

Algorithms used in FastDB allow to quite precisely calculate the
average and maximal time of query execution depending on the number of records
in the table (assuming that the size of array fields in records is
significantly smaller than the table size; and the time of iteration through
array elements can be excluded from the estimation).
The following table shows the complexity of searching a table with
<I>N</I> records depending on the search condition:<P>

<TABLE BORDER ALIGN="center">
<TR><TH>Type of search</TH><TH>Average</TH><TH>Maximal</TH></TR>
<TR><TD>Sequential search</TD><TD ALIGN="center">O(N)</TD><TD ALIGN="center">O(N)</TD></TR>
<TR><TD>Sequential search with sorting</TD><TD ALIGN="center">O(N*log(N))</TD><TD ALIGN="center">O(N*log(N))</TD></TR>
<TR><TD>Search using hash table</TD><TD ALIGN="center">O(1)</TD><TD ALIGN="center">O(N)</TD></TR>
<TR><TD>Search using T-tree</TD><TD ALIGN="center">O(log(N))</TD><TD ALIGN="center">O(log(N))</TD></TR>
<TR><TD>Access by reference</TD><TD ALIGN="center">O(1)</TD><TD ALIGN="center">O(1)</TD></TR>
</TABLE><P>

FastDB uses the Heapsort algorithm for sorting selected records to provide
guaranteed log(N) complexity (quicksort is on the average a little bit faster,
but worst time is O(N*N)). A hash table also has different average and maximal
complexity. On the average, a hash table search is faster than a T-tree search, 
but in the worst case it is equivalent to a
sequential search while a T-tree search always guarantees log(N) complexity.<P>

The execution of update statements in FastDB is also fast, but this
time is less predictable, because the commit operation requires flushing of modified pages 
to disk which can cause unpredictable operating system delays.<P>



<H3><A NAME = "par">Parallel query execution</A></H3>

FastDB is able to split a query into several parallel jobs, which will be 
executed without any contention with each other. Parallelization of a query
is done by FastDB only for sequential scans of the table. In this case,
splitting jobs between <I>N</I> processors can reduce the query execution
time about <I>N</I> times (even more if the result shall be sorted).<P>

To split a table scan, FastDB starts <I>N</I> threads, each of them
tests <I>N</I>-s records of the table (i.e. thread number 0 tests records
<I>0,N,2*N</I>,... thread number 1 test records <I>1,1+N,1+2*N</I>,... and so on).
Each thread builds its own list 
of selected records. After termination of all threads, these lists
are concatenated to construct the single result list.<P>

If the result shall be sorted, then each thread, after finishing the table scan, 
sorts the records it selected. After termination of all threads,
their lists are merged (as it is done with an external sort).<P>

Parallel query execution is controlled by two parameters: the number of spawned
threads and a parallel search threshold. The first is specified in the
<code>dbDatabase</code> class constructor or set by the
<code>dbDatabase::setConcurrency</code> method. A zero value of this parameter 
asks FastDB to automatically detect the number of online CPUs in the system and 
spawns exactly this number of threads. By default, the number of threads is set to 1,
so no parallel query execution takes place.<P>

The parallel search threshold parameter specifies the minimal number of records in the 
table for which parallelization of the query can improve query performance 
(starting a thread has its own overhead). This parameter is a static
component of the <code>dbDatabase</code> class and can be changed by an application at
any moment of time.<P> 

Parallel query execution is not possible when:<P>

<OL>
<LI>Indices are used for query execution.
<LI>The number of records in the table is less than <code>dbDatabase::dbParallelScanThreshold</code>.
<LI>A selection limit is set for the cursor.
<LI>The query includes a <code>start from</code> part.
</OL><P>


<H2> <A NAME = "implementation">FastDB implementation issues</A></H2>

This section describes some aspects of the FastDB implementation. 
It is not necessary to read this section unless you want to know
more about FastDB internals.<P>

<H3> <A NAME = "memory">Memory allocation</A></H3>

Memory allocation is performed in FASTDB by bitmap. Memory is allocated in
chunks called allocation quantum. In the current version of FastDB, the size of an
allocation quantum is 16 byte, i.e. the size of all allocated objects is 
aligned on a 16 byte boundary. Each 16 byte quantum  of database memory is represented by 
one bit in the bitmap. To locate a hole of a requested size in the bitmap, FastDB 
sequentially searches the bitmap pages for a correspondent number of successively
cleared bits. FastDB use three arrays indexed by bitmap byte, which 
allows the fast calculation of the offset and the size of the hole within the byte.<P> 

FastDB performs a cyclic scan of bitmap pages. It saves the identifier
of the current bitmap page and the current position within the page. Each time 
an allocation request arrives, scanning the bitmap starts from the (saved)
current position.
When the last allocated bitmap page is scanned, scanning continues from the 
beginning (from the first bitmap page) upto the current position.
When no free space is found after a full cycle through all bitmap pages, 
a new bulk of memory is allocated. The size of the extension is the maximum of the size
of the allocated object and of the extension quantum. The extension quantum is a parameter
of the database, specified in the constructor. The bitmap is extended in order to map
the additional space. If the virtual space is exhausted and no more
bitmap pages can be allocated, then an <code>OutOfMemory</code> error
is reported.<P>

Allocating memory using a  bitmap provides high locality of references 
(objects are mostly allocated sequentially) and also minimizes
the number of modified pages. Minimizing the number of modified pages is 
significant when a commit operation is performed and all dirty pages should
be flushed onto the disk. When all cloned objects are placed sequentially,
the number of modified pages is minimal and the transaction commit time is
reduced. Using the extension quantum helps to
preserve sequential allocation. Once the bitmap is extended, objects will
be allocated sequentially until the extension quantum is completely consumed. 
Only after reaching the end of the bitmap, the scan restarts from the beginning,
searching for holes in previously allocated memory.<P>


To reduce the number of bitmap page scans, FastDB associates a descriptor with each
page, which is used to remember the maximal size of the hole in the page.
This calculation of the maximal hole size is performed in the following way:
if an  object of size <I>M</I> can not be allocated from this bitmap page, 
the maximal hole size is less than <I>M</I>, and <I>M</I>
is stored in the page descriptor if the previous size value of the descriptor is greater
than <I>M</I>. For the next allocation of an object of size
&gt;= <I>M</I>, we will skip this bitmap page. The page descriptor
is reset when some object is deallocated within this bitmap page.<P>

Some database objects 
(like hash table pages) should be aligned on the page boundary
to provide more efficient access. The FastDB memory  allocator checks the requested
size. If it is aligned on page boundary, the address of the
allocated memory segment is also aligned on page boundary. A search for a free hole
will be done faster in this case, because FastDB increases the step of the current 
position increment according to the value of the alignment.<P>

To be able to deallocate memory used by an object, FastDB needs to keep somewhere
information about the object size. There are two ways of getting the object size in 
FastDB. All table records are prepended by a record header, which contains the
record size and a (L2-list) pointer, linking all records in the table. 
Such the size of the table record object can be extracted from the record header.
Internal database objects (bitmap pages, T-tree and hash table nodes)
have known size and are allocated without any header. Instead of this,
handles for such objects contain special markers, which allow to determine the
class of the object and get its size from the table of builtin object sizes.
It is possible to use markers because allocation is always done in quanta of
16 bytes, so the low 4 bits of an object handle are not used.<P>

It is possible to create a database larger than 4Gb or containing more than 
4Gb of objects, if you pass values greater than 32 bit in the compiler command line
for the <code>dbDatabaseOffsetBits</code> or the
<code>dbDatabaseOidBits</code> parameter.
In this case, FastDB will use an 8 byte integer type to
represent an object handle/object identifier. It will work only at truly 
64-bit operating systems, like Digital Unix.<P>


<H3> <A NAME = "transaction">Transactions</A></H3>

Each record (object) in FastDB has a unique identifier (OID). Object identifiers 
are used to implement references between objects. To locate an object by 
reference, its OID is used as an index of an array (of object offsets within the file).
This array is called <I>object index</I>, an element of this array is a an
<I>object handle</I>. There exist two object 
indices in FastDB, one of which is the current and the other the shadow. 
The header of the database contains pointers to both object indices and an indicator
to decide which index is the current at this moment.<P>

When an object is modified the first time, it is cloned 
(a copy of the object is created) and the object handle in the current index is
changed to point to the newly created object copy. The shadow index still
contains a handle which points to the original version of the object. 
All changes are done with the object copy, leaving the original object unchanged. 
FastDB marks in a special bitmap page of the object index, which one contains 
the modified object handle.<P>

When a transaction is committed, FastDB first checks if the size of the object index
was increased during the commited transaction. If so, it also reallocates the shadow 
copy of the object index. Then FastDB frees memory for all "old objects", 
i.e. objects which has been cloned within the transaction. Memory can not be 
deallocated before commit, because we want to preserve the consistent 
state of the database by keeping cloned objects unchanged. 
If we deallocated memory immediately after cloning, a new object could be 
allocated at the place of the cloned object, and we would loose
consistency. As memory deallocation is done in FastDB by the bitmap
using the same transaction mechanism as for normal database objects, 
deallocation of object space will require clearing some bits in a bitmap page,
which also should be cloned before modification. Cloning a bitmap page will
require new space for allocation of the page copy, and we could reuse the space of 
deallocated objects. But this is not acceptable due to the reasons explained 
above - we will loose database consistency. That is why deallocation 
of object is done in two steps. When an object is cloned, all bitmap pages
used for marking the object space, are also cloned (if 
not cloned before). So when the transaction is committed, we only clear some bits in 
bitmap pages: no more requests for allocation of memory can be generated at 
this moment.<P>

After deallocation of old copies, FastDB flushes all modified pages onto the disk 
to synchronize the contents of the memory and the contents of the disk file.
After that, FastDB changes the current object index indicator in the database
header to switch the roles of the object indices. The current object index becomes the
shadow index and vice versa. Then FastDB again
flushes the modified page (i.e. the page with the database header) onto the disk, transferring 
the database to a new consistent state. 
After that, FastDB copies all modified handles from the new object index
to the object index which was previously shadow and now becomes current.
At this moment, the contents of both indices are synchronized and FastDB is ready 
to start a new transaction.<P>

The bitmap of the modified object index pages is used to minimize the duration of committing
a transaction. Not the whole object index, but only its modified pages should be 
copied. After the transaction commitment the bitmap is cleared.<P>

When a transaction is explicitly aborted by the <code>dbDatabase::rollback</code>
method, the shadow object index is copied back to the current index, eliminating
all changes done by the aborted transaction. After the end of copying,
both indices are identical again and the database state corresponds to the state
before the start of the aborted transaction.<P>

Allocation of object handles is done by a free handle list. The header of the list 
is also shadowed and the two instances of the list headers are stored in the database 
header. A switch between them is done in the same way as between the
object indices. When there are no more free elements in the list, FastDB 
allocates handles from the unused part of a new index. When there is no
more space in the index, it is reallocated. The object index is the only 
entity in the database which is not cloned on modification. Instead of this,
two copies of the object index are always used.<P>

There are some predefined OID values in FastDB. OID <I>0</I> is reserved
as an invalid object identifier. OID <I>1</I> is used as the identifier for the
metatable object -
the table containing descriptors of all other tables in the database. This table
is automatically constructed during the database initialization; descriptors of
all registered application classes are stored in this metatable.
OID starting from <I>2</I> are reserved for bitmap pages. 
The number of bitmap pages depends on the maximum virtual space of the database.
For 32 bit handles, the maximal virtual space is 4Gb. The number
of bitmap pages can be calculated, as this size divided by page size divided
by allocation quantum size divided by number of bits in the byte. For a
4 Gb virtual space, a 4 Kb page size and 16 byte allocation quantum, 8K
bitmap pages are required. So 8K handles are reserved in the object index for
bitmaps. Bitmap pages are allocated on demand, when the database size is extended. 
So the OID of the first user object will be 8194.<P>


<H3> <A NAME = "recovery">Recovery</A></H3>

The recovery procedure is trivial in FastDB. There are two instances of 
an object index, one of which is current and another corresponds to 
a consistent database state. When the database is opened, FastDB checks the database
header to detect if the database was normally closed. If not, 
i.e. if a <code>dirty</code> flag is set in the database header, FastDB performs a
database recovery. Recovery is very similar to rollback of transactions. 
The indicator of the current index in the database object header is used to 
determine the index corresponding to the consistent database state. Object handles 
from this index are copied to another object index, eliminating
all changes done by uncommitted transactions. As the only action
performed by the recovery procedure is copying the object index (really only
handles having different values in the current and the shadow index are copied to 
reduce the number of modified pages) and the size of the object index is small,
recovery can be done very fast. 
The fast recovery procedure reduces the "out-of-service" time for
an  application.<P>

There is one hack which is used in FastDB to increase the database performance. 
All records in the table are linked in an L2-list, allowing efficient traversal
through the list and insertion/removal of records. 
The header of the list is stored in a table object (which is the record of the
<code>Metatable</code>). L2-list pointers are 
stored at the beginning of the object together with the object size. 
New records are always appended in FastDB at the end of the list. 
To provide consistent inclusion into a database list, we should clone the last record
in the table and the table object itself. But if the record size is very big,
cloning the last record can cause significant space 
and time overhead.<P>

To eliminate this overhead, FastDB does not clone the last record but allows a
temporary inconsistency of the list. In which state will the list be if a
system fault happens before committing the transaction ? The consistent 
version of the table object will point to the record which was the last record in 
the previous consistent state of the database. But as this record was not 
cloned, it can contain pointers to a next record, which doesn't exist in this
consistent database state. To fix this inconsistency, FastDB checks all tables 
in the database during the recovery procedure: if the last record in the 
table contains a non-NULL <I>next</I> reference, <I>next</I> is changed to NULL to restore
consistency.<P>

If a database file was corrupted on the disk, the only way to recover the database
is to use a backup file (certainly if you do not forget to make it).
A backup file can be made by the interactive SQL utility using the <code>backup</code>
command; or by the  application using the  <code>dbDatabase::backup()</code> method.
Both create a snapshot of the database in a specified file (it can be the name of a 
device, a tape for example). As far as a database file is always in a consistent
state, the only action needed to perform recovery by means of the backup file
is to replace the original database file with the backup file.<P>

If some application starts a transaction, locks the database and then crashes, 
the database is left in a locked state and no other application can access it.
To restore from this situation, you should stop all applications working with 
the database. Then restart. The first application opening the database
will initialize the
database monitor and perform recovery after this type of crash.<P>


<H3> <A NAME = "hashtable">Hash table</A></H3>

Hash tables provide (in the average) the fastest way to locate a record in the table
by key. Depending on the hash table size and quality of the hash 
function, one or more probes will be needed to locate the record.
Hash tables are the best when most of the queries use equality comparison
for record fields.<P>

FastDB uses an extensible hash table with collision chains. 
The table is implemented as an array of object references with a pointer
to a collision chain. Collision chain elements form a L1-list:  each element 
contains a pointer to the next element, the hash function
value and the OID of the associated 
record. Hash tables can be created for boolean, numeric and string fields.<P> 

To prevent the growth of collision chains, the size of a hash table is
automatically increased when the table becomes full.
In the current implementation, the  hash table is extended when
both of the following two conditions are true:

<OL>
<LI>The number of records in the tables becomes greater than the hash table size.
<LI>The umber of used elements in the hash table (i.e. number of non-empty collision
chains) is greater than 2/3 of the hash table size. 
</OL>

The first condition allows to located each element in the hash table using one
probe in average (certainly it depends on the distribution of key values and
on the hash function). The second condition prevents the hash table from growing when
the capacity of the set of possible key values becomes smaller then the hash table size
(for example, it does not make sense to extend a hash table used for hashing
<code>char</code> field, because no more than 256 items of the hash table can be 
used). Each time the hash table is extended, its size is doubled. More precisely:
the hash table size is <I>2**n-1</I>. 
Using an odd or a prime number for the hash size allows to improve the
quality of hashing and efficiently
allocates space for hash table, the size of which is aligned on page 
boundary. If the hash table size is <I>2**n</I>, than we will always loose
the least <I>n</I> bits of the hash key.<P>

FastDB uses a very simple hash function, which despite of its simplicity can
provide good results (uniformal distribution of values within the hash table).
The hash code is calculated using all bytes of the key value by the following formula:

<PRE>
        h = h*31 + *key++;
</PRE>

The hash table index is the remainder of dividing the hash code by the hash table size.<P>



<H3> <A NAME = "ttree">T-tree</A></H3>

In the article "A study of index structures for main memory database management
systems", T.J. Lehman and M.J Carey proposed the T-trees as a storage efficient data
structure for main memory databases. T-trees are based on AVL trees proposed
by Adelson-Velsky and Landis. In this subsection, we provide an overview of 
T-trees as implemented in FastDB.<P> 

Like AVL trees, the
height of left and right subtrees of a T-tree may differ by at most one.
Unlike AVL trees, each node in a T-tree stores multiple key values in a sorted
order, rather than
a single key value. The left-most and the right-most key value in a node
define the range of key values contained in the node. Thus, the left subtree
of a node contains only key values less than the left-most key value, while the
right subtree contains key values greater than the right-most key value in the
node. A key value which falls between the smallest and largest key value in
a node is said to be <I>bounded</I> by that node. 
Note that keys equal to the smallest
or largest key in the node may or may not be considered to be bounded based on
whether the index is unique and based on the search condition (e.g.
"greater-than" versus "greater-than or equal-to").<P>

A node with both a left and
a right child is referred to as an <I>internal node</I>, 
a node with only one child is referred to as a <I>semi-leaf</I>, 
and a node with no children is referred to as a <I>leaf</I>. 
In order to keep the occupancy high, every internal node must contain a minimum number
of key values (typically <I>k-2</I>, if <I>k</I>
is the maximum number
of keys that can be stored in a node). However, there is no occupancy condition
on the leaves or semi-leaves.<P>

Searching for a key value in a T-tree is
relatively straightforward. For every node, a check is made to see if the key
value is bounded by the left-most and the right-most key value in the node; if
this is the case, then the key value is returned if it is contained in the node
(else, the key value is not contained in the tree). Otherwise, if the key value
is less than the left-most key value, then the left child node is searched;
else the right child node is searched. The process is repeated until either the
key is found or the node to be searched is null.<P>

Insertions and deletions into
the T-tree are a bit more complicated. For insertions, first a variant of the
search described above is used to find the node that bounds the key value to
be inserted. If such a node exists, then if there is room in the node, the key
value is inserted into the node. If there is no room in the node, then the key
value is inserted into the node and the left-most key value in the node is
inserted into the left subtree of the node (if the left subtree is empty, then
a new node is allocated and the left-most key value is inserted into it). If no
bounding node is found, then let <I>N</I> be the last node encountered by the 
failed search and proceed as follows: If <I>N</I>
has room, the key value is inserted into <I>N</I>;
else, it is inserted into a new node that is either the right or left child of
<I>N</I>, depending on the key value and the left-most and right-most key 
values in 
<I>N</I>.<P>

Deletion of a key value begins by determining the node containing the key
value, and the key value is deleted from the node. If deleting the key value
results in an empty leaf node, then the node is deleted. If the deletion
results in an internal node or semi-leaf containing fewer than the minimum
number of key values, then the deficit is made up by moving the largest key in
the left subtree into the node, or by merging the node with its right child.
<P> 

In both insert and delete, allocation/deallocation of a node may cause the 
tree
to become unbalanced and rotations (RR, RL, LL, LR) may be necessary.
The heights of subtrees in the following description include
the effects of the insert or delete operation. In case of an insert, nodes along
the path from the newly allocated node to the root are examined until

<OL>
<LI>either a node for which the two subtrees have equal heights is found 
(in this case no rotation needs to be performed),
<LI>or a node for which the difference in
heights between the left and the right subtrees is more than one is found and a
single rotation involving the node is performed. 
</OL><P>

In the case of delete, nodes
along the path from the de-allocated node's parent to the root are examined
until a node is found whose subtrees' heights now differ by one. Furthermore,
every time a node whose subtrees' heights differ by more than one is
encountered, a rotation is performed. Note that de-allocation of a node may
result in multiple rotations.<P>


<H2> <A NAME = "subsql">Interactive SQL</A></H2>

The interactive SUBSQL utility allows to browse any FastDB database and to perform
some administration functions with it. Also import/export of data
from the database can be done by SUBSQL utility. The name SUBSQL was chosen
to express that only a subset of SQL is implemented by this utility.
It is not possible to create new tables and update records in the table, using the
SUBSQL utility. This restriction is mostly caused by the complex format
of a FastDB table (nested records, arrays,...) and positioning of FastDB
mostly as embedded in an application database engine. So SUBSQL is used best for
inspecting databases and doing some administrative work, such as performing 
database backups.<P>

The following rules in BNF-like notation specifies the grammar of the
SUBSQL directives:<P>

<PRE>
<I>directive</I> ::= 
    <B>select</B> (<B>*</B>) <B>from</B> <I>table-name</I> <I>select-condition</I> <B>;</B>
  | <B>insert into</B> <I>table-name</I> <B>values</B> <I>values-list</I> <B>;</B>
  | <B>create</B> <I>index</I> <B>on</B> <I>field-name</I> <B>;</B>
  | <B>drop</B> <I>index</I> <I>field-name</I> <B>;</B>
  | <B>drop</B> <I>table-name</I>
  | <B>open</B> <I>database-name</I> ( <I>database-file-name</I> ) <B>;</B>
  | <B>delete from</B> <I>table-name</I>
  | <B>backup</B> <I>file-name</I>
  | <B>start server</B> <I>server-URL</I> <I>number-of-threads</I>
  | <B>stop server</B> <I>server-URL</I>
  | <B>commit</B>
  | <B>rollback</B>
  | <B>exit</B>
  | <B>show</B>
  | <B>help</B>

<I>table-name</I> ::= <I>identifier</I>
<I>values-list</I> ::= <I>tuple</I> { <B>,</B><I> tuple</I> }
<I>tuple</I> ::= <B>(</B> <I>value</I> { <B>,</B> value } <B>)</B>
<I>value</I> ::= <I>number</I> | <I>string</I> | <B>true</B> | <B>false</B> 
               | <I>tuple</I>
<I>index</I> ::= <B>index</B> | <B>hash</B>
<I>field-name</I> ::= <I>identifier</I> { <B>.</B> <I>identifier</I> }
<I>database-name</I> ::= <I>string</I>
<I>database-file-name</I> ::= <I>string</I>
<I>file-name</I> ::= <I>string</I>
<I>server-URL</I> ::= <code>'HOST:PORT'</code>
</PRE><P>

SUBSQL automatically commits a read-only transaction after each 
select statement in order to release a shared database lock as soon as possible.
But all database modification operations should be explicitly committed
by a <code>commit</code> statement or undone by a <code>rollback</code>
statement. <code>open</code> opens a new database, wherase <code>exit</code> closes 
an open database (if it was opened), and so implicitly commits the last transaction. 
If a database file name was not
specified in the <code>open</code> statement, then a file name is constructed from
the database name by appending the <code>".fdb"</code> suffix.<P>

The <code>select</code> statement always prints all record fields. FastDB doesn't support
tuples: the result of the selection is always a set of objects (records).
The format of the select statement output is similar with the one accepted by the insert
statement (with the exception of reference fields). So it is possible to 
export/import a database table without references by means of the
<code>select/insert</code> directives of SUBSQL.<P>

The <code>select</code> statement prints references in the format 
<code>"#hexadecimal-number"</code>. But it is not possible to use this format
in the <code>insert</code> statement. As object references are represented 
in FastDB by internal object identifiers, a reference field can not be set in an
<code>insert</code> statement (an object inserted into the database will
be assigned a new OID, so it does not make sense to specify a reference field
in the <code>insert</code> statement). To ensure database reference consistency,
FastDB just ignores reference fields when new records are inserted into the table
with references. You should specify the value 0 at the place of reference fields.
If you omit the '*' symbol in the select statement, FastDB will output object 
identifiers of each selected record.<P>

It is mandatory to provide values for all record fields in an <code>insert</code>
statement; default values are not supported. Components of structures and
arrays should be enclosed in parentheses.<P>

It is not possible to create or drop indices and tables while other 
applications are working with the database. Such operations change 
the database scheme: after such modifications the state of other applications
will become incorrect. But the <code>delete</code> operation
doesn't change the database scheme. So it can be performed as a normal transaction,
when the database is concurrently used by several applications.
If SUBSQL hangs trying to execute some statement, then some other application
holds the lock on the database, preventing SUBSQL from accessing it.<P>


<H2><A NAME = "www">API for development Web applications</A></H2>

New version of FastDB provides API for developing WWW applications.
It is very easy to perform Web database publishing with FastDB.
FastDB  server can either communicate with standard WWW server by
means of CGI requests, or it can serve HTTP requests itself.<P>
Interaction with Web server is based on three-tier model:

<PRE>
    Web Server   -&gt;     CGI stub     -&gt;    FastDB application
             CGI call          local socket connection  
</PRE>

Using FastDB built-in HTTP server provides maximum performance, because in 
this no communication and process creation overhead takes place.
In both cases the same API for receiving and unpacking requests 
and constructing responses is used. So the same application 
can be used for interaction with external Web server as well as 
stand-alone HTTP server.<P>

FastDB application is request-driven program, receiving data from
HTML forms and dynamically generating result HTML page. Classes
<code>WWWapi</code> and <code>WWWconnection</code> provide simple and 
convenient interface for getting HTTP requests, constructing HTML page and 
sending reply back to WWW browser. Abstract class <code>WWWapi</code>
has two implementations: <code>CGIapi</code> and <code>HTTPapi</code>,
first of which implements protocol of interaction with Web server by means of 
CGI mechanism, and the second - protocol of direct serving HTTP requests.<P>

Built-in HTTP server is able to handle two types of requests - 
transfer HTML file find in place relative to the current working directory
in response to GET HTTP request and perform action specified by GET or POST
requests with parameters. Built-in HTTP server provides persistent connections -
server will not close connection with client immediately after sending 
response, instead of this connection will be kept during some specified 
interval of time. Also this built-in server supports concurrent requests 
processing by several threads of control. But starting of threads should
be performed by client application.<P>

Virtual method <code>WWWapi::connect(WWWconnection& con)</code>
accept clients connection (either from CGISTUB program of from WWW browser).
This method returns <code>true</code> if connection is established. 
In this case programmer should call 
<code>CGIapi::serve(WWWconnection& con)</code> to receive and handle client's
requests. This method return <code>false</code> if and only if handler
of request returns <code>false</code>. Even if request was not correctly
received or could not be handled, <code>true</code> is returned by 
<code>serve</code> method. The connection is always closed after return from
<code>serve</code> method. It is possible to start separate thread for 
exceution of each <code>server</code> method.<P>

To construct responce to the request special overloaded <code>&gt;&gt;</code>
operators are provided in <code>WWWconnection</code> class. First line of 
response should specify type of response body, for example:

<PRE>
Content-type: text/html\r\n\r\n
</PRE>

Two CR-LF character after this line separate HTTP header from the body.
Three encoding schemes can be used for constructing response body:

<OL>
<LI><B>TAG</B> - used for specifying HTML control elements. No conversion is
done for this encoding.
<LI><B>HTML</B> - with this encoding output characters which are special for 
HTML (&Ltd; &gt; &amp; &qout;) are replaced with special symbolic names 
(&qout;lt; &qout;gt; &qout;amp; &qout;qout;). 
<LI><B>URL</B> - used for specifying call parameters in URL format. 
Spaces are replaced with '+' character, all other special characters with
their hex code.
</OL>

To make switching between encoding more convenient, <code>WWWconeection</code>
class performs automatic switching between encodings. Initially <B>TAG</B>
encoding is always used. Then encodings are implicitly changed using the 
following rules:

<PRE>
              TAG  -&gt; HTML
              HTML -&gt; TAG
              URL  -&gt; TAG
</PRE>

It certainly possible to explicitly specify encoding for the next output 
operation by means of special <code>&lt;&lt;</code> operator, which accepts 
one of the following constants: <code>TAG, HTML, URL</code>.<P>

Information about HTML form slots values or request parameters can be obtained 
using <code>WWWconnection::get(char const* name, int n = 0)</code> method.
Optional second parameter is used only for getting value of selectors with
multiple selection allows option. If parameter with such name is not found, 
<code>NULL</code> is returned. There are some mandatory parameters 
which always should be present in all forms handled by FastDB:<P>

<TABLE BORDER>
<TR><TH>Parameter name</TH><TH>Parameter Description</TH></TR>
<TR><TD>socket</TD><TD>address of the server, used for constructing new links</TD></TR>
<TR><TD>page</TD><TD>symbolic name of the page, used for request dispatching</TD></TR>
<TR><TD>stub</TD><TD>name of CGI stub program always defined by API</TD></TR>
</TABLE><P>


<H2> <A NAME = "examples">Examples of FastDB applications</A></H2>

FastDB is shipped with some examples of database applications, which
can help you creating your own applications.<P>

<H3> <A NAME = "guess">Example: game "Guess an animal"</A></H3>
"Guess an animal" is very simple a program which uses a database to 
store the game tree. Having a very simple algorithm, this program shows some elements of "artificial intelligence". The more information you provide to this
game, the smarter will be its behavior.<P>  

This is an example of a "navigation-only" application - 
no queries are used in this application at all. All navigation between
records (objects) is done by means of references. Really, this application
is more suitable for object oriented databases, but I include it in FastDB 

<OL>
<LI>to illustrate how easy navigation by references can be done in FastDB,
<LI>because this program is some kind of "trade mark" which I use in all
my databases.
</OL><P>


<H3> <A NAME = "testdb">Example: various types of queries</A></H3>

This application illustrates the usage of various types of database queries
and the advantages of using inverse references. A classical Detail/Contract/Supplier
database schema is used in this example. Compare the number of lines in this 
file with the number of lines needed to implement this example using ODBC or 
other RDBMS C API.<P>

<H3> <A NAME = "testperf">Performance test</A></H3>

This test allows to receive some results about the FastDB performance for
all basic operations. This test inserts <I>N</I> records into a table, 
then performs searches using a T-tree and a hash table, then a sequential search and
a sequential search with sorting. It is possible to specify a level 
of query parallelization in the command line. By default no parallelization
is used. The following table contains results for some systems and
<I>N</I> = 1000000. Values in the table rows specify the number of milliseconds
consumed by the operation which is calculated by dividing the time returned
by the <code>testperf</code> program by the number of iterations.<P>

<TABLE BORDER>
<TR><TH>System</TH><TH>Number of CPUs</TH><TH>Number of threads</TH><TH>Insertion*)</TH><TH>Hash table search</TH><TH>T-tree search</TH><TH>Sequential search</TH><TH>Sequential search with sorting</TH></TR>
<TR><TD>Pentium-II 300, 128 Mb RAM, Windows NT</TD><TD>1</TD><TD>1</TD><TD>0.056</TD><TD>0.015</TD><TD>0.041</TD><TD>1 400</TD><TD>25 000</TD></TR>
<TR><TD>Pentium-II 333, 512 Mb RAM, Linux</TD><TD>1</TD><TD>1</TD><TD>0.052</TD><TD>0.016</TD><TD>0.045</TD><TD>1 600</TD><TD>33 000</TD></TR>
<TR><TD>Pentium-Pro 200, 128 Mb RAM, Windows NT</TD><TD>2</TD><TD>1</TD><TD>0.071</TD><TD>0.023</TD><TD>0.052</TD><TD>1 600</TD><TD>35 000</TD></TR>
<TR><TD>Pentium-Pro 200, 128 Mb RAM, Windows NT</TD><TD>2</TD><TD>2</TD><TD>0.071</TD><TD>0.023</TD><TD>0.052</TD><TD>1 800</TD><TD>23 000</TD></TR>
<TR><TD>AlphaServer 2100, 250 Mhz, 512 Mb RAM, Digital Unix</TD><TD>2</TD><TD>1</TD><TD>0.250</TD><TD>0.031</TD><TD>0.084</TD><TD>2 600</TD><TD>42 000</TD></TR>
<TR><TD>AlphaServer 2100, 250 Mhz, 512 Mb RAM, Digital Unix</TD><TD>2</TD><TD>2</TD><TD>0.250</TD><TD>0.031</TD><TD>0.084</TD><TD>1 600</TD><TD>23 000</TD></TR>
<TR><TD>AlphaStation, 500 Mhz, 256 Mb RAM, Digital Unix</TD><TD>2</TD><TD>1</TD><TD>0.128</TD><TD>0.010</TD><TD>0.039</TD><TD>1 300</TD><TD>36 000</TD></TR>
</TABLE><P>

*) doesn't include commit time<P>

It will be nice if you can run this test at some other platforms and send me
the results. I need to notice, that for <I>N</I> = 1000000 you need
at least 128Mb of memory, otherwise you will test the performance of your disk.


<H3><A NAME = "bugdb">Bug tracking database</A></H3>

Example "Bug tracking database" illustrates developing Web application
using GigaBASE and WWW API. It can be used either with any WWW server 
(for example Apache or Microsoft Personal Web Server) or with
built-in HTTP server. To compile BUGDB for interaction with external server, 
define macro <code>USE_EXTERNAL_HTTP_SERVER</code>. 
Database can be
accessed from any computer running some WWW browser. To build 
<code>bugdb</code> application in Unix you should specify <code>www</code>
target to make utility.<P>

To run this BUGDB with external WWW server you should first customize your 
WWW server.
It should be able to access <code>buglogin.htm</code> file and run
CGI script <code>cgistub</code>. Also user, under which CGI scripts will
be executed, should have enough permissions to establish connection with 
GigaBASE application (by sockets). It is better to run GigaBASE application and
GigaBASE CGI scripts under the same user. For example, I have changed the 
following variables in Apache configuration file:

<PRE>
httpd.conf:
        User konst
        Group users

access.conf:
        &lt;Directory /usr/konst/gigabase&gt;
        Options All
        AllowOverride All
        allow from all
        &lt;/Directory&gt;

        DocumentRoot /usr/konst/gigabase

srm.conf:
        ScriptAlias /cgi-bin/ /usr/konst/gigabase/
</PRE>

It is also possible not to change configuration of WWW server, but place 
<code>cgistub</code> and <code>bugdb</code> programs in standard CGI
script directory and change in the file <code>buglogin.htm</code> path to 
the <code>cgistub</code> program.
After preparing configuration files you should start WWW server.<P>

No configuration is needed when you are using built-in HTTP server.
Just make sure that user has enough permission to access port number 80
(default port for HTTP server). If some HTTP server is already started at your
computer, you should either stop it or specify another port for 
built-in HTTP server. In last case you also need to specify the same port
in the settings of WWW browser to make it possible to establish connection with
right HTTP server. Also do not forget to specify real name of your computer
in ACTION field of buglogin.htm file.<P>

After starting <code>bugdb</code> application itself you can visit
<code>buglogin.htm</code> page in WWW browser and start to work with 
BUGDB database. When database is initialized, "administrator" user is 
created in the database. First time you should login as administrator using
empty password. Than you can create some other users/engineers and 
change the password. BUGDB doesn't use secure protocol of passing passwords and
doesn't worry much about restricting access of users to the database.
So if you are going to use BUGDB in real life, you should first
think about protecting database from unauthorized access.<P>


<H3><A NAME = "clidb">Clients-Managers database</A></H3>

This yet another example of Web database publishing. This database
contains information about clients and managers. Each client and each manager belongs to 
some segment (department). Managers can make remarks on status of a client from the same 
segment to which manager belongs. Some managers has mini-administrator permissions and
they are allowed to edit/remove reports made by other managers. Information about 
segments and mangers is maintained by database administrator.<P>

As well as BUGDB, this Web database example can work either through CGI interface with
some external HTTP server or use built-in HTTP server (last one is significantly
more efficient than interaction through CGI scripts). Look 
<A HREF="#bugdb">previous section</A> for more information about configuration of 
HTTP server. Do not forget to specify real name of your computer
in ACTION field of clilogin.htm file.<P>

After starting <code>clidb</code> application itself you can visit
<code>clilogin.htm</code> page in WWW browser and start to work with 
CLIDB database. When database is initialized, "administrator" user is 
created in the database. This database allows to specify IP address for the manager from 
which this manager can login to the system. So user authentication is based on 
the name and host computer IP address. Value '*' allows user to login from any host.
If you specify wrong IP address for the administrator and so are not able to login to 
the database, you can invoke clidb as 

<PRE>
       clidb <socket-name> login_from_any_host       
</PRE>


CLIDB also can be considered as example of multithreaded Web database server.
There is special class QueueManager which can be used for maintaining pool of threads
and distributing user HTTP requests between these threads. If you recompile CLIDB 
application with USE_QUEUE_MANAGER option set (and PTHREADS and _RRENTRANT at Unix),
than CLIDB will spawn 8 threads for handling HTTP requests. In this case persistent
connection with client's WWW browsers are established (so there is no
extra overhead for establishing connecting for each HTTP request).<P>



<H2><A NAME = "quick">Quick start</A></H2>

When you are developing an application for FastDB, you should first decide
which data and which classes you want to store in the database. Then you
should describe the format of the database tables. Section 
<A HREF="#table">Table</A> describes how to create type and table descriptors.
Do not forget to register table descriptors by the <code>REGISTER</code> macro
(it should be done in some implementation module). If you are going
to redefine the default FastDB error handler (for example, if you want to use 
a message window for reporting instead of <code>stderr</code>), you should 
define your own database class and derive it from <code>dbDatabase</code>.
You should create an instance of the database class and make it accessible to
all application modules.<P>

Before you can do something with your database, you should open it.
Checking the <code>dbDatabase::open()</code> return code, you can
find out, if the database was successfully opened. Errors during database
opening do not terminate the  application (but they are reported)
even with the default error handler.<P>

Once you are certain that the database is normally opened, you can start
to work with the database. If your application is multithreaded and several threads
will work with the same database, you should attach each thread to the
database by the <code>dbDatabase::attach</code> method. Before thread termination,
it should detach itself from the database by invoking the
<code>dbDatabase::detach()</code> method. If your application uses navigation
through database objects by references, you need some kind of root object
which can be located without any references. The best candidate for the root
object is the first record of the table. FastDB guarantees that new
records are always inserted at the end of the table. So the first table record
is also the oldest record in the table.<P>

To access database data, you should create a number of <code>dbQuery</code>
and <code>dbCursor</code> objects. If several threads are working with the
database, each thread should have its own instances of query and
cursor objects. Usually it is enough to have one cursor for each table
(or two if your application also can update table records). But in case
of nested queries, using several cursors may be needed.
Query objects are usually created for each type of queries. Query objects are 
used also for caching compiled queries, so it will be a good idea to
extend the life span of query variables (may be make them static).<P>

There are four main operations with database: insert, select, update, remove.
The first is done without using cursors, by means of the global overloaded
template function <code>insert</code>. Selection, updating and deleting of 
records is performed using cursors. To be able to modify a table you should
use a cursor for update. A cursor in FastDB is typed and contains an instance
of an object of the table class. The overloaded '<code>operator-&gt;</code>'
of the cursor can be used to access components of the current record
and also to update these components. The method <code>update</code>
copies data from the cursor's object to the current table record.
The cursor's method <code>remove</code> will remove the current cursor record,
the method <code>removeAllSelected</code> will remove all selected records and
the method <code>removeAll</code> will remove all records in the table.
Each transaction should be either committed by
the <code>dbDatabase::commit()</code> or aborted by 
the <code>dbDatabase::rollback()</code> method. A transaction is started 
automatically when the first select, insert or remove operation is executed.<P>

Before exiting from your application do not forget to close the database.
Also remember, that the method <code>dbDatabase::close()</code> will automatically
commit the last transaction, so if this is not what you want, then explicitly perform
a <code>dbDatabase::rollback</code> before exit.<P>

So a template for a FastDB application can look like this:
<PRE>
//
// Header file
//
#include "fastdb.h"

extern dbDatabase db; // create database object

class MyTable { 
    char const* someField;
    ...
  public:
    TYPE_DESCRIPTOR((someField));
};

//
// Implementation
//
REGISTER(MyTable);

int main() 
{ 
    if (db.open("mydatabase")) { 
        dbCursor&lt;MyTable&gt; cursor;
        dbQuery q;

	char value[bufSize];

	q = "someField=",value;
	gets(value);
	if (cursor.select(q) &gt; 0) { 
	    do { 
	        printf("%s\n", cursor-&gt;someField);
	    } while (cursor.next());
        }
	db.close();
	return EXIT_SUCCESS;
    } else { 
        return EXIT_FAILURE;
    }
}
</PRE>	

To compile a FastDB application you have to include the header file
<code>"fastdb.h"</code>. This header file includes other FastDB header files,
so make sure that the FastDB directory is in the compiler's include path. To 
link a FastDB application, you need the FastDB library (<code>"fastdb.lib"</code>
for Windows or <code>"libfastdb.a"</code> for Unix). You can either
specify the full path to this library or place it in some default
library catalog (for example <code>/usr/lib</code> for Unix).<P>

To build the FastDB library, just type <code>make</code> in the FastDB directory. 
There is no autoconfiguration utility included 
in the FastDB distribution. Most system dependent parts of the code are compiled using
conditional compilation. There are two makefiles in the FastDB distribution. 
One for MS Windows with MS Visual C++ (<code>makefile.mvc</code>) 
and another one for generic Unix with a gcc compiler(<code>makefile</code>). 
If you want to use Posix threads or some other compiler, you
should edit this makefile. 
There is also a <code>make.bat</code> file, which just spawns a
<code>nmake -f makefile.mvc</code> command.
The <code>install</code> target in the
Unix makefile will copy FastDB header files, the FastDB library and the subsql utility
to directories specified by the <code>INCSPATH, LIBSPATH</code> and
</code>BINSPATH</code> makefile variables correspondingly.
Default values of these variables are the following:

<PRE>
        INCSPATH=/usr/include 
        LIBSPATH=/usr/lib
        BINSPATH=/usr/bin
</PRE><P>

Once your application starts to work, you will be busy with
support and extension of your application. FastDB is able to perform
automatic schema evaluation for such cases as adding a new field to the table and
changing the type of a field. The programmer can also add new indices or remove
rarely used indices. The database trace can be switched on (by (re-)compiling the
FastDB library with the <code>-DDEBUG=DEBUG_TRACE</code> option) to 
perform analysis of database functionality and efficiency of using indices.<P>

The SUBSQL utility can be used for database browsing and inspection, performing
online backups, importing data to and exporting data from the database.
FastDB will perform automatic recovery after system or application crash;
you should not worry about it. The only thing you perhaps have to do manually 
is stopping all database applications if one of them crashes, leaving the
database blocked.<P> 

<H2><A NAME = "distribution">Distribution terms</A></H2>
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the <A HREF="#Software">Software</A>), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:<P>

<A NAME="Software">
<B>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHOR OF THIS SOFTWARE BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR 
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</B>
</A><P>

I will provide e-mail support and help you with development of 
FastDB applications.<P>
<HR>
<P ALIGN="CENTER"><A HREF="http://www.ispras.ru/~knizhnik">
<B>Look for new version at my homepage</B></A><B> | </B>
<A HREF="mailto:knizhnik@altavista.net">
<B>E-Mail me about bugs and problems</B></A></P>
</BODY>
</HTML>
