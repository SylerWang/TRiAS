// $Header: $
// Copyright© 1998-2000 TRiAS GmbH Potsdam, All rights reserved
// Created: 25.02.2000 11:15:18 
//
// This file was generated by the TRiASDB Data Server Wizard V1.01.076 (#HK000225)
//
// @doc
// @module DBUtil.cpp | Definition Helperfunktionen

#include "stdafx.h"

#include <ospace/string/src/regex.h>	// GNU regular expression matcher
#include <ospace/string/regexp.h>

#include "Strings.h"

/////////////////////////////////////////////////////////////////////////////
// OKS behandeln (globale Funktionen)

namespace {

// eigentlich passiert ja alles hier in der folgenden Klasse
	class COKSRegExpr :
		public os_regexp
	{
	public:
		COKSRegExpr() { pattern (g_cbOKS); }

	// feststellen, ob die gegebene Zeichenkette einen Objektklassenschlüssel enthält
		bool StringIsOKS (BSTR bstrToTest, BSTR *pbstrStripped = NULL, BSTR *pbstrAppendix = NULL)
		{ 
			USES_CONVERSION;

		// Eingabezeichenkette analysieren
		os_string strToTest (OLE2A(bstrToTest));
		int iMatched = match(strToTest);

			if (iMatched <= 0) 
				return false; 

		os_string strT;

			if (group(7).size() > 0) {
			// vierter Fall gefunden (Monikerformat)
				strT = group(7);
				if (NULL != pbstrAppendix) {
					_ASSERTE(group(8).size() > 0);

				CComBSTR bstrApp (os_string(group(8)).c_str());

					*pbstrAppendix = bstrApp.Detach();
				}

			} else if (group(4).size() > 0) {
			// dritter Fall gefunden ('[hexdigits]...')
				strT = group(4);
				if (NULL != pbstrAppendix) {
					_ASSERTE(group(5).size() > 0);

				CComBSTR bstrApp (os_string(group(5)).c_str());

					*pbstrAppendix = bstrApp.Detach();
				}
			} else if (group(1).size() > 0) {
			// ersten Fall gefunden ('[hexdigits]')
				strT = group(1);
			} else if (group(3).size() > 0) {
			// zweiten Fall gefunden ('hexdigits:...')
				strT = group(3);
			} else
				return false;

			if (0 == strT.size()) 
				return false;

		// Resultat liefern, wenn gewünscht
			if (NULL != pbstrStripped) {
			CComBSTR bstrRes (strT.c_str());

				*pbstrStripped = bstrRes.Detach();
			}
			return true;
		}
	};

	COKSRegExpr g_TestOKS;

}; // namespace

bool StringIsOKS (BSTR bstrToStrip, BSTR *pStripped, BSTR *pbstrAppendix)
{
	return g_TestOKS.StringIsOKS (bstrToStrip, pStripped, pbstrAppendix);
}

///////////////////////////////////////////////////////////////////////////////
// Spezielle Messagebox mit Formatiermöglichkeiten
int __cdecl VMessageBox (UINT uiCaption, UINT uiType, UINT uiText, ...)
{
CString strCap, strText;

	VERIFY(strCap.LoadString (uiCaption));
	VERIFY(strText.LoadString (uiText));

CString strOut;
LPTSTR pcOut = NULL;

	ATLTRY(pcOut = strOut.GetBufferSetLength(_MAX_PATH*4));
	if (NULL != pcOut) {
	va_list params;

		va_start (params, uiText);
	//lint --e(534)
		wvsprintf (pcOut, strText, params);
		va_end (params);

		return AfxGetMainWnd() -> MessageBox (pcOut, strCap, uiType);
	}
	return AfxGetMainWnd() -> MessageBox (strText, strCap, uiType);
}

int __cdecl VMessageBox (LPCSTR pcCaption, UINT uiType, UINT uiText, ...)
{
CString strText;

	VERIFY(strText.LoadString (uiText));

CWnd Wnd;
CString strOut;
LPTSTR pcOut = NULL;

	ATLTRY(pcOut = strOut.GetBufferSetLength(_MAX_PATH*4));
	if (NULL != pcOut) {
	va_list params;

		va_start (params, uiText);
	//lint --e(534)
		wvsprintf (pcOut, strText, params);
		va_end (params);

		return AfxGetMainWnd() -> MessageBox (pcOut, pcCaption, uiType);
	}
	return AfxGetMainWnd() -> MessageBox (strText, pcCaption, uiType);
}

