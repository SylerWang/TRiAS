// $Header: $
// Copyright© 1998-2000 TRiAS GmbH Potsdam, All rights reserved
// Created: 25.02.2000 11:15:18 
//
// This file was generated by the TRiASDB Data Server Wizard V1.01.076 (#HK000225)
//
// @doc
// @module FastdbObjectsCollection.cpp | Implementation of <c CFastdbObjectsCollection> class

#include "stdafx.h"

#include "Strings.h"

#include "Fastdb.h"
#include "FastdbDBEngine.h"
#include "FastdbDatabase.h"
#include "FastdbObjectsCollection.h"

#if defined(_DEBUG)
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// SmartIF's
DefineSmartInterface(Dispatch);
DefineSmartInterface(PersistStreamInit);

DefineSmartInterface(TRiASObjects);
DefineSmartInterface(TRiASObjectsCollection);

/////////////////////////////////////////////////////////////////////////////
// CFastdbObjectsCollection

STDMETHODIMP CFastdbObjectsCollection::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITRiASObjectsCollection,
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// ITRiASObjectsCollectionCallback

STDMETHODIMP CFastdbObjectsCollection::get_DefaultType (BSTR *pbstrType)
{
	CHECKOUTPOINTER(pbstrType);

CIID Guid (CLSID_FastdbObjects);		// DefaultType der _Elemente_ (hier: Objektklasse)!
CComBSTR bstrType (Guid.ProgID().c_str());

	*pbstrType = bstrType.Detach();
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// Erzeugen einer neuen Objektklasse
STDMETHODIMP CFastdbObjectsCollection::OnCreate (
	VARIANT NameOrHandle, BSTR Type, OBJECTSCOLLECTIONTYPE rgType, ITRiASObjects **ppIObjs)
{
	CHECKOUTPOINTER(ppIObjs);

// jetzt wirklich erzeugen
CIID ClsId (Type, CIID::INITCIID_InitFromProgId);

	if (!ClsId)	ClsId = CLSID_FastdbObjects;	// default ClsId

	RETURN_FAILED_HRESULT(CreateObject (NameOrHandle, rgType, &ClsId, ppIObjs));
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// Löschen einer Objektklasse aus der Datenquelle
STDMETHODIMP CFastdbObjectsCollection::OnDelete (VARIANT vWhich)
{
#pragma TODO("Löschen einer Objektklasse (darf nur was machen, wenn keine Objekte enthalten sind).")
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// Objekt wird logisch freigegeben
STDMETHODIMP CFastdbObjectsCollection::OnFinalRelease()
{
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// Objekt neu erzeugen/wiederverwenden und zur Collection hinzufügen
HRESULT CFastdbObjectsCollection::CreateObject (
	VARIANT NameOrHandle, DWORD dwType, const CLSID *pClsId, ITRiASObjects **ppIObjs)
{
// diverse Vorbereitungen treffen
WTRiASObjectsCollection BaseObjs;
WDispatch Parent;

	RETURN_FAILED_HRESULT(m_BaseUnk -> QueryInterface (BaseObjs.ppi()));
	RETURN_FAILED_HRESULT(BaseObjs -> get_Parent (Parent.ppi()));

// ZugriffsHandle/Namen oder OKS aus NameOrHandle bestimmen
LONG lHandle = 0;
CComVariant v;
bool fHasName = false;
bool fHasOKS = false;
CComBSTR bstrApp, bstrOKS;

	if (VT_BSTR != V_VT(&NameOrHandle) && SUCCEEDED(v.ChangeType (VT_I4, &NameOrHandle)))
		lHandle = V_I4(&v);
	else if (SUCCEEDED(v.ChangeType(VT_BSTR, &NameOrHandle))) {
	// feststellen, obs ein OKS ist, evtl. Namen isolieren
		if (StringIsOKS(V_BSTR(&v), CLEARED(&bstrOKS), CLEARED(&bstrApp))) {
			if (bstrOKS.Length() > 0)
				fHasOKS = true;
		} else 
			bstrApp = V_BSTR(&v);

		if (bstrApp.Length() > 0)
			fHasName = true;
	} else
		return E_INVALIDARG;

HRESULT hr = S_OK;

	USES_CONVERSION;
	COM_TRY {
	// Objektklasse aus Name/OKS erzeugen
	WTRiASObjects Objs (*pClsId);

	// Objektklasse fertig initialisieren
		THROW_FAILED_HRESULT(WPersistStreamInit(Objs) -> InitNew());
		THROW_FAILED_HRESULT(Objs -> put_Parent (Parent));

	// an der erzeugten Objektklasse unsere Nummer (cursor) speichern
	CDBClass Objects;
	
		Objects.m_pGeometryName = g_cbGeometry;
		Objects.m_pPrimaryKey = g_cbObjektname;

	// Namen etc. dieser Objektklasse festlegen
		if (fHasName) {
			THROW_FAILED_HRESULT(Objs -> put_Name (bstrApp));
			Objects.m_pName = OLE2A(bstrApp);
		}
		if (fHasOKS) {
			THROW_FAILED_HRESULT(Objs -> put_OKS (bstrOKS));
			Objects.m_pOKS = OLE2A(bstrOKS);
		}

	// Typen der Objektklasse setzen
		THROW_FAILED_HRESULT(Objs -> put_CollectionType(OBJECTSCOLLECTIONTYPE(dwType)));
		THROW_FAILED_HRESULT(Objs -> put_Updatable(VARIANT_TRUE));

	// Namen der Standard-Objekteigenschaften (Geometrie und Normal) setzen
		THROW_FAILED_HRESULT(Objs -> put_DefaultGeometry (CComBSTR(g_cbGeometry)));
		THROW_FAILED_HRESULT(Objs -> put_PrimaryKey (CComBSTR(g_cbObjektname)));

	// neues Objekt ist jetzt gültig
	dbDatabase *pdb = GetRelatedDatabase(GetUnknown());
	dbReference<CDBClass> refobjs = pdb -> insert (Objects);

		THROW_FAILED_HRESULT(SetPropertyBy (Objs, g_cbObjectsCursor, CComVariant(refobjs.getOid(), VT_I4), true));

	// wenn Objektklasse bereits zu dieser Menge von Objektklassen gehört, dann liefert _Add den Wert S_FALSE
		hr = BaseObjs -> _Add (Objs, VARIANT_TRUE);
		if (SUCCEEDED(hr) && NULL != ppIObjs)
			*ppIObjs = Objs.detach();			// evtl. neue/gefundene Objektklasse liefern

	} COM_CATCH;
	return hr;
}

