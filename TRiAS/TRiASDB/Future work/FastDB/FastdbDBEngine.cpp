// $Header: $
// Copyright© 1998-2000 TRiAS GmbH Potsdam, All rights reserved
// Created: 25.02.2000 11:15:18
//
// This file was generated by the TRiASDB Data Server Wizard V1.01.076 (#HK000225)
//
// @doc 
// @module FastdbDBEngine.cpp |  Databaseengine für TRiASDB Data Server Fastdb

#include "stdafx.h"

#include "Version.h"
#include "Strings.h"

#include "Fastdb.h"
#include "FastdbDBEngine.h"
#include "FastdbDatabase.h"

#if defined(_DEBUG)
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// globale Instanz der DBEngine
CFastdbDBEngine *g_pDBEngine = NULL;
STARTMODE g_rgStartMode = STARTMODE_Normal;

///////////////////////////////////////////////////////////////////////////////
// SmartIF's
DefineSmartInterface(TRiASCSStorageService);

///////////////////////////////////////////////////////////////////////////////
// CFastdbDBEngine

STDMETHODIMP CFastdbDBEngine::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITRiASDBEngine,
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

HRESULT CFastdbDBEngine::FinalConstruct (void)
{
	return S_OK;
}

void CFastdbDBEngine::FinalRelease()
{
	ASSERT(NULL == g_pDBEngine);	// existiert nicht mehr (sollte jedenfalls)
}

///////////////////////////////////////////////////////////////////////////////
// ITRiASDBEngine
STDMETHODIMP CFastdbDBEngine::get_Version (BSTR *pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	CHECKOUTPOINTER(pVal);	

CString strVersion;

	strVersion.Format (_T("%d.%02d.%03d"), FASTDB_DS_VERSION, FASTDB_DS_RELEASE, FASTDB_DS_BUILD);

CComBSTR bstrVersion (strVersion);

	*pVal = bstrVersion.Detach();
	return S_OK;
}

STDMETHODIMP CFastdbDBEngine::put_Password (BSTR bstrPwd)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	CHECKINPOINTER(bstrPwd);	

	m_bstrPassword = bstrPwd;
	return S_OK;
}

STDMETHODIMP CFastdbDBEngine::put_UserName (BSTR bstrUser)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	CHECKINPOINTER(bstrUser);

	m_bstrUserName = bstrUser;
	return S_OK;
}

STDMETHODIMP CFastdbDBEngine::get_Description (BSTR * pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	CHECKOUTPOINTER(pVal);	

CComBSTR bstr;

	if (!bstr.LoadString (IDS_DBENGINE_DESC))
		return E_OUTOFMEMORY;

	*pVal = bstr.Detach();
	return S_OK;
}

STDMETHODIMP CFastdbDBEngine::Start (STARTMODE rgMode)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	ASSERT(NULL == g_pDBEngine);	// darf nur einmal gerufen werden

	COM_TRY {
	// singletions instantiieren
		m_Service = WTRiASCSStorageService(CLSID_TRiASCSStorageService);

	// fertig initialisieren
		g_pDBEngine = this;
		g_rgStartMode = rgMode;
		m_fIsStarted = true;
	} COM_CATCH;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// Liefert Enumerator, der alle bekannten Projekttypen enthält

const LPCOLESTR s_poleTypesNormal[] = 
{
	g_cbDatabase,		// ProgID des Database-Objektes (s. FastdbDatabase.h)
};

typedef CComEnum<IEnumString, &IID_IEnumString, LPOLESTR, _Copy<LPOLESTR> > CEnumString;

STDMETHODIMP CFastdbDBEngine::EnumDataBaseTypes (IUnknown **ppIEnum)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	CHECKOUTPOINTER(ppIEnum);	

CComObject<CEnumString> *pIEnum = NULL;

	ATLTRY(pIEnum = new CComObject<CEnumString>());
	if (NULL == pIEnum) return E_OUTOFMEMORY;

// die Funktion Init des EnumTemplates erwartet die Adressen des ersten und 
// letzten+1 Elementes eines Vektors
LPOLESTR *ppStringsStart = (LPOLESTR *)&s_poleTypesNormal[0];
LPOLESTR *ppStringsEnd = (LPOLESTR *)&s_poleTypesNormal[_countof(s_poleTypesNormal)];

HRESULT hr = pIEnum -> Init (ppStringsStart, ppStringsEnd, static_cast<ITRiASDBEngine *>(this), AtlFlagCopy);

	if (SUCCEEDED(hr))
		hr = pIEnum -> QueryInterface(IID_IEnumString, (LPVOID *)ppIEnum);

	if (FAILED(hr))		// bei Fehler alles freigeben
		delete pIEnum;

	return hr;
}

STDMETHODIMP CFastdbDBEngine::Stop()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	ERROR_EXPR_TRUE(!m_fIsStarted, TRIASDB_E_NOT_STARTED);

	g_pDBEngine = NULL;				// das letzte vom Tage
	return S_OK;
}
