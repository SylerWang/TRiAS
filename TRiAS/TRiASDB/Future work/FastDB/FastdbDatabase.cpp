// $Header: $
// Copyright© 1998-2000 TRiAS GmbH Potsdam, All rights reserved
// Created: 25.02.2000 11:15:18
//
// This file was generated by the TRiASDB Data Server Wizard V1.01.076 (#HK000225)
//
// @doc 
// @module FastdbDatabase.cpp | Datenbankobjekt TRiASDB Data Server Fastdb

#include "stdafx.h"

#include <ospace/file/path.h>
#include <CSRectGeom.h>

#include "Version.h"
#include "Strings.h"

#include "Fastdb.h"
#include "FastdbDatabase.h"

///////////////////////////////////////////////////////////////////////////////
// SmartIF's
DefineSmartInterface(Dispatch);
DefineSmartInterface(PersistStreamInit);

DefineSmartInterface(TRiASConnection);
DefineSmartInterface(TRiASPropertyBase);
DefineSmartInterface(TRiASProperties);
DefineSmartInterface(TRiASObjectsCollection);
DefineSmartInterface(TRiASObjects);

DefineSmartInterface(TRiASCS);
DefineSmartInterface(TRiASCSGCS);
DefineSmartInterface(TRiASCSDatumTransformation);
DefineSmartInterface(TRiASTransformGeometry);

DefineSmartInterface(TRiASSimpleRectangle);

///////////////////////////////////////////////////////////////////////////////
// Vollen GeoDBNamen erzeugen 
// Der volle GeoDBName wird erzeugt, in dem die im gegebenen DateiNamen fehlenden
// Bestandteile des vollen DateiNamens durch die Teile aus den StandardPfad
// (aus der Registry) ergänzt werden. Wenn nur der Name des Projektes vorgegeben
// ist, so wird folgender Name erzeugt
//		StandardPfad\Projekt\Projekt.rim.
HRESULT GenerateFullPath (LPCTSTR pcDBName, bool fMakeSubDir, os_string &rStr, os_string &rStrName)
{
	if (NULL == pcDBName) 
		return E_POINTER;	// temporäre Datei erzeugen

	COM_TRY {
	os_path Name = os_string(pcDBName);

	// wenn UNC vorliegt, dann nichts machen
		if (!Name.has_unc()) {
		// Default-Verzeichnis besorgen
		os_path Default = os_string(g_cbProjects);

		// fehlende Bestandteile des Namens ersetzen
			if (!Name.has_directory() && !Name.has_fulldrive())
				Name.directory (Default.directory());
			if (!Name.has_drive())
				Name.drive (*Default.drive().c_str());
			if (Name.base().size() > 0 && !Name.has_extension())
				Name.extension (os_string(g_cbRim));

			if (fMakeSubDir) {
			// Unterverzeichnis dranhängen, welches genau wie die Datei heißt
			os_string dir (Name.directory());

				dir += Name.path_separator();
				dir += Name.base();
				Name.directory (dir);
			}
		}
		rStr = (LPCTSTR)Name;		// Resultat kopieren
		rStrName = Name.base();		// basename kopieren

	} COM_CATCH;
	
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// CTRiASMDatabase

STDMETHODIMP CFastdbDatabase::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITRiASDatabase,
		&IID_ITRiASPropertyBase,
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

HRESULT CFastdbDatabase::FinalConstruct (void)
{
	return S_OK;
}

void CFastdbDatabase::FinalRelease()
{
}

///////////////////////////////////////////////////////////////////////////////
// ITRiASBase
STDMETHODIMP CFastdbDatabase::get_Application (IDispatch **pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	CHECKOUTPOINTER(pVal);

WDispatch disp (m_Application);

	*pVal = disp.detach();
	return S_OK;
}

STDMETHODIMP CFastdbDatabase::put_Application (IDispatch *newVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	m_Application = newVal;
	return S_OK;
}

STDMETHODIMP CFastdbDatabase::get_Parent (IDispatch **pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	CHECKOUTPOINTER(pVal);

WDispatch disp (m_Parent);

	*pVal = disp.detach();
	return S_OK;
}

STDMETHODIMP CFastdbDatabase::put_Parent (IDispatch *newVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	m_Parent = newVal;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// ITRiASDatabase
STDMETHODIMP CFastdbDatabase::get_Handle (INT_PTR *pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	CHECKOUTPOINTER(pVal);
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED);

	*pVal = reinterpret_cast<INT_PTR>(this);
	return S_OK;
}

STDMETHODIMP CFastdbDatabase::get_IsDirty (VARIANT_BOOL *pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	CHECKOUTPOINTER(pVal);
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED);

	*pVal = m_DB.IsDirty() ? VARIANT_TRUE : VARIANT_FALSE;
	return S_OK;
}

STDMETHODIMP CFastdbDatabase::put_IsDirty (VARIANT_BOOL newVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED);

	m_DB.SetDirty (newVal ? true : false);
	return S_OK;
}

STDMETHODIMP CFastdbDatabase::get_OpenedAsCopy (VARIANT_BOOL * pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	CHECKOUTPOINTER(pVal);
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED);
		
	*pVal = VARIANT_FALSE;
	return S_OK;
}

STDMETHODIMP CFastdbDatabase::get_CouldOpenTarget (VARIANT_BOOL * pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	CHECKOUTPOINTER(pVal);
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED);
		
	*pVal = VARIANT_FALSE;
	return S_OK;
}

STDMETHODIMP CFastdbDatabase::get_SchemaUpdatable (VARIANT_BOOL * pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	CHECKOUTPOINTER(pVal);
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED);
		
	*pVal = VARIANT_TRUE;
	return S_OK;
}

STDMETHODIMP CFastdbDatabase::get_Name (BSTR *pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	CHECKOUTPOINTER(pVal);
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED);

CComBSTR bstrName (m_bstrName);

	if (!bstrName)
		return E_OUTOFMEMORY;

	*pVal = bstrName.Detach();
	return S_OK;
}

STDMETHODIMP CFastdbDatabase::get_Version (BSTR * pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	CHECKOUTPOINTER(pVal);
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED);

char cbBuffer[64];

	wsprintf (cbBuffer, "%d.%02d", FASTDB_VERSION_MAJOR, FASTDB_VERSION_MINOR);

CComBSTR bstrVersion (cbBuffer);

	*pVal = bstrVersion.Detach();
	return S_OK;
}

STDMETHODIMP CFastdbDatabase::get_VersionLong (LONG *pVal)
{
	CHECKOUTPOINTER(pVal);
	*pVal = FASTDB_VERSION_MAJOR*100 + FASTDB_VERSION_MINOR;
	return S_OK;
}

STDMETHODIMP CFastdbDatabase::get_CollatingOrder (LONG * pVal)
{
	CHECKOUTPOINTER(pVal);
	return E_NOTIMPL;
}

STDMETHODIMP CFastdbDatabase::get_Connect (BSTR * pVal)
{
	CHECKOUTPOINTER(pVal);
	return E_NOTIMPL;
}

STDMETHODIMP CFastdbDatabase::get_Transactions (VARIANT_BOOL * pVal)
{
	CHECKOUTPOINTER(pVal);

	*pVal = VARIANT_TRUE;
	return S_OK;
}

STDMETHODIMP CFastdbDatabase::get_Updatable (VARIANT_BOOL * pVal)
{
	CHECKOUTPOINTER(pVal);

	*pVal = VARIANT_TRUE;
	return S_OK;
}

STDMETHODIMP CFastdbDatabase::get_Temporary (VARIANT_BOOL * pVal)
{
	CHECKOUTPOINTER(pVal);
	return E_NOTIMPL;
}

STDMETHODIMP CFastdbDatabase::put_Temporary (VARIANT_BOOL pVal)
{
	return E_NOTIMPL;
}

STDMETHODIMP CFastdbDatabase::get_TemporaryName (BSTR * pVal)
{
	return get_Name (pVal);
}

STDMETHODIMP CFastdbDatabase::get_Type (BSTR * pVal)
{
	CHECKOUTPOINTER(pVal);
		
// ProgID des zugehörigen Datenbankobjektes
CComBSTR bstr (g_cbDatabase);

	*pVal = bstr.Detach();
	return S_OK;
}

STDMETHODIMP CFastdbDatabase::get_StorageMode (DATABASESTORAGEMODE * pVal)
{
	CHECKOUTPOINTER(pVal);

	*pVal = DATABASESTORAGEMODE_FileBased;
	return S_OK;
}

STDMETHODIMP CFastdbDatabase::CreateDatabase (BSTR Name, BSTR Locale, BSTR Source)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	if (IsOpened())
		return TRIASDB_W_ALREADY_OPENED;

	USES_CONVERSION;
	COM_TRY {
	os_string strPath, strName;

		THROW_FAILED_HRESULT(GenerateFullPath (OLE2A(Name), false, strPath, strName));
		
	// einfach nur öffnen und sofort wieder schließen
		DeleteFile (strPath.c_str());		// erstmal sicher weglöschen
		if (!m_DB.open (strName.c_str(), strPath.c_str()))
			return TRIASDB_E_COULD_NOT_OPEN;

	// Version der Datenbank wegschreiben
	CDBHeader Hdr;
	
		Hdr.m_pKey = const_cast<char *>(g_cbVersion);
		Hdr.SetValue (CComVariant(FASTDATABASE_VERSION_100));
		Hdr.m_rgType = PROPERTY_TYPE_System|PROPERTY_TYPE_ReadOnly;

		m_DB.insert (Hdr);
		m_DB.commit();

	// wieder schließen
		m_DB.close();

	} COM_CATCH;
	return S_OK;
}

STDMETHODIMP CFastdbDatabase::CreateDatabaseFromFiles (IUnknown * FileNames, BSTR Locale, BSTR Source)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	return E_NOTIMPL;
}

STDMETHODIMP CFastdbDatabase::CreateDatabaseOnStg (IUnknown *pIUnk, BSTR Name, BSTR Locale, BSTR Source)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	return E_NOTIMPL;
}

STDMETHODIMP CFastdbDatabase::OpenDatabase (
	BSTR Name, VARIANT_BOOL Exclusive, VARIANT_BOOL fReadOnly, VARIANT_BOOL ModTrack, BSTR Source)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	if (IsOpened())
		return TRIASDB_W_ALREADY_OPENED;

	USES_CONVERSION;
	COM_TRY {
	os_string strPath, strName;

		THROW_FAILED_HRESULT(GenerateFullPath (OLE2A(Name), false, strPath, strName));
		
	// einfach nur öffnen
		if (!m_DB.open (strName.c_str(), strPath.c_str()))
			return TRIASDB_E_COULD_NOT_OPEN;

	// Version testen
	dbCursor<CDBHeader> cursor(&m_DB);
	dbQuery q;

		q = "KEY=", g_cbVersion;
		if (cursor.select(q) != 1) {
			THROW_FAILED_HRESULT(FASTDB_E_UNKNOWN_DATABASE_VERSION);
		}

	CComVariant v;

		cursor -> GetValue (&v);
		THROW_FAILED_HRESULT(v.ChangeType(VT_I4));
		if (V_I4(&v) > LASTKNOWN_FASTDATABASE_VERSION) {
			THROW_FAILED_HRESULT(FASTDB_E_UNKNOWN_DATABASE_VERSION);
		}

		m_bstrName = strPath.c_str();

	// neue PropertiesCollection anlegen und initialisieren
		THROW_FAILED_HRESULT(CreatePropertiesCollection());		// --> FastdbPropertyBase.h

	// KoordinatenSystemService erzeugen und initialisieren
		THROW_FAILED_HRESULT(InitCoordSystemService());

	} COM_CATCH_OP(if (IsOpened()) m_DB.close(););
	return S_OK;
}

STDMETHODIMP CFastdbDatabase::OpenFilesAsDatabase (
	IUnknown * FileNames, VARIANT_BOOL Exclusive, VARIANT_BOOL ReadOnly, VARIANT_BOOL ModTrack, BSTR Source)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	return E_NOTIMPL;
}

STDMETHODIMP CFastdbDatabase::OpenStorageAsDatabase(
	IUnknown *pIUnk, VARIANT_BOOL Exclusive, VARIANT_BOOL fReadOnly, VARIANT_BOOL ModTrack, BSTR Source)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	return E_NOTIMPL;
}

STDMETHODIMP CFastdbDatabase::Save()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED);

	COM_TRY {
		m_DB.commit();		// Änderungen speichern
		m_DB.SetDirty (false);
	} COM_CATCH_RETURN(FASTDB_E_DATABASE_COULDNOTSAVE);
	return S_OK;
}

STDMETHODIMP CFastdbDatabase::SaveAs (BSTR NewName)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED);

	USES_CONVERSION;
	COM_TRY {
		if (!m_DB.backup (OLE2A(NewName), true))
			return FASTDB_E_DATABASE_COULDNOTSAVE;
		m_bstrName = NewName;
	} COM_CATCH;
	return S_OK;
}

STDMETHODIMP CFastdbDatabase::Close()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED);

	COM_TRY {
	// alle Objekte abhängen (_vor_ FreePropertiesCollection, da sonst neue Coll erzeugt wird)
		m_ObjectsDefs -> put_Parent (NULL);
		m_ObjectsDefs.Assign(NULL);

	// alles freigeben
		ShutdownCoordSystemService();
		ReleasePropertySupportObjects();		// --> FastdbPropertySupport.h
		FreePropertiesCollection();				// --> FastdbPropertyBase.h

		m_bstrName.Empty();

	// es _muß_ vorher gespeichert worden sein
		m_DB.rollback();
		m_DB.close();

	} COM_CATCH;
	return S_OK;
}

STDMETHODIMP CFastdbDatabase::BeginTrans()
{
	return E_NOTIMPL;
}

STDMETHODIMP CFastdbDatabase::ClearModificationLog(LONG Entry)
{
	return E_NOTIMPL;
}

STDMETHODIMP CFastdbDatabase::CommitTrans()
{
	return E_NOTIMPL;
}

STDMETHODIMP CFastdbDatabase::Rollback()
{
	return E_NOTIMPL;
}

STDMETHODIMP CFastdbDatabase::ReLoad (RELOADDATABASE rgWhat)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

HRESULT hr = S_OK;

	if (RELOADDATABASE_All == rgWhat) {
	// alles neu einlesen
		RETURN_FAILED_HRESULT(OnReLoadObjects());
		RETURN_FAILED_HRESULT(OnReLoadEnvelope());

	} else switch (rgWhat) {
	case RELOADDATABASE_Envelope:
		hr = OnReLoadEnvelope();
		break;

	case RELOADDATABASE_Objects:
		hr = OnReLoadObjects();
		break;
	}
	return hr;
}

HRESULT CFastdbDatabase::OnReLoadObjects()
{
	return S_OK;	// werden bei nächster Gelegenheit wieder neu initialisiert
}

HRESULT CFastdbDatabase::OnReLoadEnvelope()
{
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// 
STDMETHODIMP CFastdbDatabase::RefreshChangesFromModificationLog (
	ITRiASRefreshChangesCallback *pICallback)
{
	return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////////
// ITRiASAccessDatabase

// liefert die Sammlung aller Objektklassen dieser Datenquelle
STDMETHODIMP CFastdbDatabase::get_ObjectsDefs (ITRiASObjectsCollection **pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	CHECKOUTPOINTER(pVal);
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED)

// wenn die Collection bereits existiert, dann lediglich diese zurückliefern
	if (m_ObjectsDefs.IsValid()) 
		return LPUNKNOWN(*pVal = m_ObjectsDefs) -> AddRef(), S_OK;

// ansonsten neu erzeugen
	return EnsureObjectsDefs (pVal);
}

HRESULT CFastdbDatabase::EnsureObjectsDefs (ITRiASObjectsCollection **pVal)
{
	_ASSERTE(!m_ObjectsDefs.IsValid());
	COM_TRY {
	WTRiASObjectsCollection ObjsColl (CLSID_FastdbObjectsCollection);

		THROW_FAILED_HRESULT(ObjsColl -> put_Application(m_Application));
		THROW_FAILED_HRESULT(ObjsColl -> put_Parent(GetDispatch()));

	dbCursor<CDBClass> cursor(&m_DB);

		if (cursor.select() > 0) {
			do {
			// Objektklasse instantiieren
			WTRiASObjects Objs (CLSID_FastdbObjects);

			// Objektklasse fertig initialisieren
				THROW_FAILED_HRESULT(WPersistStreamInit(Objs) -> InitNew());
				THROW_FAILED_HRESULT(Objs -> put_Application (m_Application));
				THROW_FAILED_HRESULT(Objs -> put_Parent (GetDispatch()));

			// Namen etc. dieser Objektklasse festlegen
				if ('\0' != cursor -> m_pName[0]) {
					THROW_FAILED_HRESULT(Objs -> put_Name (CComBSTR(cursor -> m_pName)));
				}
				if ('\0' != cursor -> m_pDesc[0]) {
					THROW_FAILED_HRESULT(Objs -> put_Description (CComBSTR(cursor -> m_pDesc)));
				}
				if ('\0' != cursor -> m_pOKS[0]) {
					THROW_FAILED_HRESULT(Objs -> put_OKS (CComBSTR(cursor -> m_pOKS)));
				}

			// Typen der Objektklasse setzen
				THROW_FAILED_HRESULT(Objs -> put_CollectionType(OBJECTSCOLLECTIONTYPE_Class));
				THROW_FAILED_HRESULT(Objs -> put_Types(GetTypes (cursor)));
				THROW_FAILED_HRESULT(Objs -> put_Updatable(VARIANT_TRUE));

			// Namen der Standard-Objekteigenschaften (Geometrie und Normal) setzen
				THROW_FAILED_HRESULT(Objs -> put_DefaultGeometry (CComBSTR(cursor -> m_pGeometryName)));
				THROW_FAILED_HRESULT(Objs -> put_PrimaryKey (CComBSTR(cursor -> m_pPrimaryKey)));

			// an der erzeugten Objektklasse unsere Nummer (cursor) speichern
				THROW_FAILED_HRESULT(SetPropertyBy (Objs, g_cbObjectsCursor, CComVariant(cursor.currentId().getOid(), VT_I4), true));

			// die neu instantiierte Objektklasse zur Menge der Objektklassen hinzufügen
				THROW_FAILED_HRESULT(ObjsColl -> _Add (Objs, VARIANT_TRUE));

			} while (NULL != cursor.next());
		}
		m_ObjectsDefs = ObjsColl;
		if (NULL != pVal)
			*pVal = ObjsColl.detach();

	} COM_CATCH;
	return S_OK;
}

// liefert bzw. erzeugt eine neue Objektklasse dieser Datenquelle
STDMETHODIMP CFastdbDatabase::get_ObjectsDef(
	VARIANT vItem, VARIANT_BOOL fCreate, BSTR Type, ITRiASObjects **pIObjDef)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	CHECKOUTPOINTER(pIObjDef);
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED)

	if (!m_ObjectsDefs.IsValid())
	{
		RETURN_FAILED_HRESULT(EnsureObjectsDefs());
	}
	_ASSERTE(m_ObjectsDefs.IsValid());

HRESULT hr = m_ObjectsDefs -> Item (vItem, pIObjDef);

	if (TRIASDB_E_UNKNOWN_OBJECTS == hr && fCreate) {	// evtl. neu erzeugen
	CComVariant v;

		hr = v.ChangeType (VT_BSTR, &vItem);
		if (SUCCEEDED(hr)) {
		CIID ClsId (Type, CIID::INITCIID_InitFromProgId);

			if (!ClsId)	
				hr = m_ObjectsDefs -> Add (V_BSTR(&v), CComBSTR(g_cbNil), pIObjDef);	// default type verwenden
			else
				hr = m_ObjectsDefs -> Add (V_BSTR(&v), CComBSTR(ClsId.ProgID().c_str()), pIObjDef);
			if (S_OK == hr) hr = S_FALSE;				// Objektmenge wurde neu erzeugt
		}
	}
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// Umschließenden Datenbank-Container liefern
STDMETHODIMP CFastdbDatabase::get_Envelope (ENVELOPETYPE rgType, IDispatch **pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	CHECKOUTPOINTER(pVal);
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED)

	USES_CONVERSION;
	COM_TRY {
	// CS-Transformator besorgen
	WTRiASCSTransform CST (GetPropertyFrom (GetDispatch(), g_cbTRiASCSTransform, (IDispatch *)NULL), false);

		_ASSERTE(CST.IsValid());

	// Container der Datenquelle einlesen
	WTRiASSimpleRectangle Rect;
	dbCursor<CDBHeader> cursor(&m_DB);
	dbQuery q;

		q = "KEY=", OLE2A(g_cbDatabaseEnvelope);
		if (cursor.select(q) == 1) {
		CComVariant v;

			cursor -> GetValue (&v);
			if (SUCCEEDED(v.ChangeType(VT_DISPATCH))) {
				Rect = V_DISPATCH(&v);
				THROW_FAILED_HRESULT(WTRiASTransformGeometry(Rect) -> Transform ((CSID &)m_CtfGuid, CST));
			}
		}
		if (!Rect.IsValid()) {
		CCSRectangleGeometry rect (0.0, 0.0, 0.0, 0.0, 1);

			*pVal = rect.detach();
		} else
			*pVal = Rect.detach();

	} COM_CATCH;
	return S_OK;
}

STDMETHODIMP CFastdbDatabase::get_ObjectCount (long *pVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
	CHECKOUTPOINTER(pVal);
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED)

// Anzahl der Objekte festellen
dbCursor<CDBObject> cursor(&m_DB);

	*pVal = cursor.select();
	return S_OK;
}

STDMETHODIMP CFastdbDatabase::get_AttachedCS (BSTR bstrDbName, BSTR *pbstrAssocCS)
{
	return E_NOTIMPL;
}

STDMETHODIMP CFastdbDatabase::get_ConnectionFilter(ITRiASConnectionFilter **ppIGeom)
{
	return E_NOTIMPL;
}

STDMETHODIMP CFastdbDatabase::put_ConnectionFilter(ITRiASConnectionFilter *pIGeom)
{
	return E_NOTIMPL;
}

STDMETHODIMP CFastdbDatabase::get_Views (ITRiASViews **pVal)
{
	return E_NOTIMPL;
}

STDMETHODIMP CFastdbDatabase::get_StartViewName (BSTR *pVal)
{
	return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////////
// Koordinatensystem neu initialisieren
HRESULT CFastdbDatabase::InitCoordSystemService()
{
	COM_TRY {
	// CTF-Service holen/initialisieren
	WTRiASProperties Props (GetProperties());
	WTRiASCSTransform CST (GetProperty (Props, g_cbTRiASCSTransform, (IDispatch *)NULL), false);

		if (!CST.IsValid()) {
		// neuen CTF-Service erzeugen und am Objekt ablegen
		CIID CTFGuid;	// Guid vergeben

			CST = WTRiASCSTransform(CLSID_TRiASCSTransform);

#pragma TODO("Konkretes Koordinatensystem erzeugen und entsprechend Daten initialisieren.")

		WTRiASCS CS (CLSID_TRIASCS);	

		// BEGIN_SAMPLE_DATA
		// hier: WGS84 geodätisch (ohne Projektion) annehmen
			THROW_FAILED_HRESULT(CS -> put_CoordSystemType(tcsCS_Geographic));		// Typ des CoordSystems setzen

		// Geodätische Grundlage initialisieren
			{
			WTRiASCSGCS GCS;

				THROW_FAILED_HRESULT(CS -> get_GeographicCS(GCS.ppi()));
				THROW_FAILED_HRESULT(GCS -> put_GeodeticDatum(tcsGD_WorldGeodeticSystem1984));
				THROW_FAILED_HRESULT(GCS -> put_PrimeMeridian(tcsPM_Greenwich));
				THROW_FAILED_HRESULT(GCS -> put_UnitOfAngle(tcsUOA_Second));
			}

		// Datumsparameter einstellen
			{
			WTRiASCSDatumTransformation DTrans;

				THROW_FAILED_HRESULT(CS -> get_DatumTransformation(DTrans.ppi()));
				THROW_FAILED_HRESULT(DTrans -> put_GeodeticDatum(tcsGD_WorldGeodeticSystem1984));
				THROW_FAILED_HRESULT(DTrans -> put_TransformationAlgorithm(tcsDTA_PositionVector7ParamTransformation));
			}

			THROW_FAILED_HRESULT(CS -> put_GUID (CComBSTR(CTFGuid)));	// Guid zuordnen

		// CS-Guid an der Datenbank speichern
			THROW_FAILED_HRESULT(SetProperty (Props, g_cbCSSGuid, CComBSTR(os_string(CTFGuid).c_str()), true));
		// END_SAMPLE_DATA

		// dieses Koordinatensystem als InputCS zum Transformator hinzufügen
			THROW_FAILED_HRESULT(CST -> AddInputCS (CS));
			m_CtfGuid = CTFGuid;			// Guid des Koordinatensystems hier speichern

		// als Property an der Datenbank speichern
			THROW_FAILED_HRESULT(SetProperty (Props, g_cbTRiASCSTransform, CComVariant(CST), true));
		}

	// Ausgabesystem von der Connection holen (hat sich u.U. geändert) und an unserem Transformator
	// setzen
	WTRiASConnection Conn;

		THROW_FAILED_HRESULT(FindSpecificParent (m_Parent, Conn.ppi()));

	WTRiASCS CSOut (GetPropertyFrom (WTRiASPropertyBase(Conn), g_cbTRiASCSService, (IDispatch *)NULL), false);

		ASSERT(CSOut.IsValid());	// muß bereits existieren
		THROW_FAILED_HRESULT(CST -> putref_OutputCS (CSOut));
		THROW_FAILED_HRESULT(CSOut -> Recompute());		// TransformationsPfad neu berechnen

	} COM_CATCH;
	return S_OK;
}

// Koordinatensystem freigeben
HRESULT CFastdbDatabase::ShutdownCoordSystemService()
{
	COM_TRY {
	WTRiASCSTransform CST (GetProperty (GetProperties(), g_cbTRiASCSTransform, (IDispatch *)NULL), false);

		ERROR_EXPR_TRUE(!CST.IsValid(), E_UNEXPECTED);
		THROW_FAILED_HRESULT(CST -> ShutDown());
	} COM_CATCH;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// OleItemContainerSupport
// nach einer bestimmten Objektklasse fragen
HRESULT CFastdbDatabase::GetObjectsDef (
	LPCTSTR pcItem, DWORD dwSpeedNeeded, REFIID riid, LPVOID *ppvObj, bool fTestRunningOnly)
{
	if (!m_ObjectsDefs) {
		if (BINDSPEED_IMMEDIATE == dwSpeedNeeded)
			return MK_E_EXCEEDEDDEADLINE;

	// evtl. Neuerzeugen der benötigten Collection
	WTRiASObjectsCollection Coll;

		RETURN_FAILED_HRESULT(get_ObjectsDefs (Coll.ppi()));	// fills in m_ObjectsDefs
	}
	_ASSERTE(m_ObjectsDefs.IsValid());

HRESULT hr = S_OK;

	COM_TRY {
	WTRiASObjects Objs;
		
		hr = m_ObjectsDefs -> Item (CComVariant(pcItem), Objs.ppi());
		if (TRIASDB_E_UNKNOWN_OBJECTS == hr && !fTestRunningOnly) {
		// Objektklasse ist neu und muß erzeugt werden
			if (BINDSPEED_IMMEDIATE == dwSpeedNeeded)
				return MK_E_EXCEEDEDDEADLINE;
			hr = m_ObjectsDefs -> Add (CComBSTR(pcItem), CComBSTR("TRiASDB.FastdbObjects.1"), Objs.ppi());
		}

		if (SUCCEEDED(hr) && !fTestRunningOnly && NULL != ppvObj)	// Objektklasse ist (jetzt) bekannt
		{
			_ASSERTE(Objs.IsValid());
			THROW_FAILED_HRESULT(Objs -> QueryInterface (riid, ppvObj));
		}
	} COM_CATCH;
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// nach einem bestimmten Objekt fragen
HRESULT CFastdbDatabase::GetObjectDef (
	LPCTSTR pcItem, DWORD dwSpeedNeeded, REFIID riid, LPVOID *ppvObj, bool fTestRunningOnly)
{
	if (BINDSPEED_IMMEDIATE == dwSpeedNeeded)	// muß immer in der eigentlichen Datenbank gesucht werden
		return MK_E_EXCEEDEDDEADLINE;

	COM_TRY {
#pragma TODO("Objekt anhand des übergenenen Displaynames wiederfinden.")

	} COM_CATCH;
	return S_OK;
}

// DisplayName parsen und Moniker liefern
HRESULT CFastdbDatabase::ParseObjectsDef (
	LPCTSTR pcItem, ULONG ulSkipped, ULONG *pulEaten, IMoniker **ppmkOut)
{
CComBSTR bstrItem(pcItem);

	RETURN_FAILED_HRESULT(CreateItemMoniker (g_cbMkDel, bstrItem, ppmkOut));
	*pulEaten += bstrItem.Length();
	return S_OK;
}

HRESULT CFastdbDatabase::ParseObjectDef (
	LPCTSTR pcItem, ULONG ulSkipped, ULONG *pulEaten, IMoniker **ppmkOut)
{
CComBSTR bstrItem(pcItem);

	RETURN_FAILED_HRESULT(CreateItemMoniker (g_cbMkDel, bstrItem, ppmkOut));
	*pulEaten += bstrItem.Length();
	return S_OK;
}

