// $Header: $
// Copyright© 1998-2000 TRiAS GmbH Potsdam, All rights reserved
// Created: 25.02.2000 11:15:18 
//
// This file was generated by the TRiASDB Data Server Wizard V1.01.076 (#HK000225)
//
// @doc
// @module FastdbObject.cpp | Implementation of the <c CFastdbObject> class

#include "stdafx.h"

#include "Strings.h"

#include "Fastdb.h"
#include "FastdbDatabase.h"
#include "FastdbObject.h"
#include "FastdbPropertySupport.h"

#if defined(_DEBUG)
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// SmartIF's
DefineSmartInterface(TRiASObject);
DefineSmartInterface(TRiASObjects);
DefineSmartInterface(TRiASFeatures);
DefineSmartInterface(TRiASObjectHandleMap);
DefineSmartInterface(TRiASPropertyMapHandler);

DefineSmartInterface(Dispatch);
DefineSmartInterface(PersistStreamInit);

/////////////////////////////////////////////////////////////////////////////
// CFastdbObject

STDMETHODIMP CFastdbObject::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITRiASObject,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// ITRiASObjectCallback

STDMETHODIMP CFastdbObject::get_DefaultType (BSTR *pbstrType)
{
	CHECKOUTPOINTER(pbstrType);

CIID Guid (GetObjectCLSID());
CComBSTR bstrType (Guid.ProgID().c_str());

	*pbstrType = bstrType.Detach();
	return S_OK;
}

// called during InitNew/Load
STDMETHODIMP CFastdbObject::SetupObject(SETUPOBJECTMODE rgMode)
{
	_ASSERTE(SETUPOBJECTMODE_InitOrLoad == rgMode);		// z.Zt nur dieses
	COM_TRY {
	// Properties zum aggregierten Objekt hinzufügen
	WTRiASPropertyMapHandler MapHandler(m_BaseUnk);

		THROW_FAILED_HRESULT(MapHandler -> AddMapEntry (
			CComBSTR(g_cbObjectCursor), (INT_PTR)&CLSID_FastdbCursorProperty, PROPERTYSUPPORT_NOFLAGS, vtMissing));

	} COM_CATCH;
	return S_OK;
}

STDMETHODIMP CFastdbObject::OnChanging (CHANGEDOBJECT rgWhat, VARIANT vNewValue, VARIANT_BOOL *pDisAllow)
{
	CHECKOUTPOINTER(pDisAllow);

	*pDisAllow = VARIANT_FALSE;		// immer einverstanden sein
	return S_OK;
}

STDMETHODIMP CFastdbObject::OnChanged (CHANGEDOBJECT rgWhat, VARIANT vOldValue)
{
	switch (rgWhat) {
	case CHANGEDOBJECT_Type:
		return OnChangedType (vOldValue);

	case CHANGEDOBJECT_Handle:
	case CHANGEDOBJECT_Name:
	default:
		break;
	}
	return S_OK;
}

HRESULT CFastdbObject::OnChangedType (VARIANT vOldValue)
{
	COM_TRY {
	CComVariant v;

		THROW_FAILED_HRESULT(v.ChangeType (VT_I4, &vOldValue));
		if (OBJECTTYPE_Unknown == V_I4(&v)) {
		// Objekttyp wurde erstmalig festgelegt: Objektklasse nachführen
		WTRiASObject Obj;
		WTRiASObjects Objs;
		OBJECTTYPE rgType = OBJECTTYPE_Unknown;

			THROW_FAILED_HRESULT(FindSpecificParent (m_BaseUnk, Objs.ppi()));
			THROW_FAILED_HRESULT(m_BaseUnk -> QueryInterface (Obj.ppi()));

		// Objektzähler im ObjektklassenSatz richten
			THROW_FAILED_HRESULT(Obj -> get_Type (&rgType));

		LONG lCursor (GetPropertyFrom (Objs, g_cbObjectsCursor, 0L));

			if (0 == lCursor) 		// Objekt nicht fertig initialisiert
				return S_OK;

		dbCursor<CDBClass> cursor (GetRelatedDatabase(GetUnknown()), dbCursorForUpdate);
		CDBClass *pClass = cursor.at (dbReference<CDBClass>(oid_t(lCursor)));

			if (NULL == pClass || cursor.isEmpty())
				THROW_FAILED_HRESULT(E_UNEXPECTED);

			if (0 != AdjustObjectCount (cursor, rgType))
				cursor.update();
		}

	} COM_CATCH;
	return S_OK;
}

// Objekt wird logisch freigegeben
STDMETHODIMP CFastdbObject::OnFinalRelease()
{
	COM_TRY {
	// unsere Nummer (Cursor) freigeben und damit dieses Objekt aus der Handlemap herauslöschen
		THROW_FAILED_HRESULT(DelPropertyBy (WDispatch(m_BaseUnk), g_cbObjectCursor));

	} COM_CATCH;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// Objekt löschen
STDMETHODIMP CFastdbObject::OnDelete()
{
	COM_TRY {
	// zugehöriges DB-Objekt referenzieren
	WTRiASObject BaseObj;
	
		THROW_FAILED_HRESULT(m_BaseUnk -> QueryInterface (BaseObj.ppi()));

	LONG lCursor (GetPropertyFrom (BaseObj, g_cbObjectCursor, 0L));

		if (0 == lCursor) 		// Objekt nicht fertig initialisiert
			THROW_FAILED_HRESULT(FASTDB_E_OBJECT_BADREFERENCE);

	dbCursor<CDBObject> object (GetRelatedDatabase(GetUnknown()), dbCursorForUpdate);
	CDBObject *pObject = object.at (dbReference<CDBObject>(oid_t(lCursor)));

		if (NULL == pObject || object.isEmpty())
			THROW_FAILED_HRESULT(FASTDB_E_OBJECTS_BADREFERENCE);

		object.remove();		// Objekt und alles was dran hängt löschen

	} COM_CATCH;
	return S_OK;
}

STDMETHODIMP CFastdbObject::SetupFeatures(SETUPFEATURESMODE rgMode)
{
	// wird vollständig von der Objektklasse bestimmt
	return E_NOTIMPL;
}

