// $Header: $
// Copyright© 1998-2001 TRiAS GmbH Potsdam, All rights reserved
// Created: 27.04.2001 16:50:09
//
// This file was generated by the TRiASDB Data Server Wizard V1.02.115 (#HK010427)
//
// @doc 
// @module TRiASOGCDBEngine.cpp |  Databaseengine für TRiASDB Data Server TRiASOGC

#include "stdafx.h"

#include <ospace/std/vector>

#include "Version.h"
#include "Strings.h"

#include "TRiASOGC.h"
#include "TRiASOGCDBEngine.h"
#include "TRiASOGCDatabase.h"

#if defined(_DEBUG)
#if defined(_MFC_VER)
#define new DEBUG_NEW
#endif // defined(_MFC_VER)
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// globale Instanz der DBEngine
CTRiASOGCDBEngine *g_pDBEngine = NULL;
STARTMODE g_rgStartMode = STARTMODE_Normal;

///////////////////////////////////////////////////////////////////////////////
// Registrieren der derzeit installierten OleDb Provider
/*static*/
HRESULT CTRiASOGCDBEngine::UpdateRegistry(BOOL bRegister)
{
COGISDataProviderEnum Enum;

	RETURN_FAILED_HRESULT(Enum.Open());
    while (S_OK == Enum.MoveNext()) {
		if (Enum.IsOGISProvider()) {
		// OGC Data Provider
		CComBSTR bstrProgId;

			RETURN_FAILED_HRESULT(Enum.GetProgId(&bstrProgId));
			RETURN_FAILED_HRESULT(UpdateRegistry(bRegister, Enum, bstrProgId));
		}
	}

	return _Module.UpdateRegistryFromResource(IDR_TRIASOGCDBENGINE_RGS, bRegister);
}

namespace {
	const UINT PROGID_INDEX = 0;
	const UINT NAMEDESC_INDEX = 1;
	const UINT LONGNAME_INDEX = 2;
	const UINT SHORTNAME_INDEX = 3;
	const UINT READWRITE_INDEX = 4;
	const UINT VERSION_INDEX = 5;
	const UINT BITMAP_INDEX = 6;

	_ATL_REGMAP_ENTRY s_regEntryMap[] =  {
		{ L"PROGID", NULL },		// PROGID_INDEX
		{ L"NAMEDESC", NULL },		// NAMEDESC_INDEX
		{ L"LONGNAME", NULL },		// LONGNAME_INDEX
		{ L"SHORTNAME", NULL },		// SHORTNAME_INDEX
		{ L"READWRITE", NULL },		// READWRITE_INDEX
		{ L"VERSION", NULL },		// VERSION_INDEX
		{ L"BITMAP", NULL },		// BITMAP_INDEX
		{ NULL, NULL },			// EndeKennung
	};
}

/*static*/
HRESULT CTRiASOGCDBEngine::UpdateRegistry(BOOL bRegister, COGISDataProviderEnum& rEnum, BSTR bstrProgId)
{
CComBSTR bstrParams[_countof(s_regEntryMap)-1];

	bstrParams[PROGID_INDEX] = bstrProgId;
	bstrParams[SHORTNAME_INDEX] = rEnum.m_szName;
	bstrParams[NAMEDESC_INDEX] = rEnum.m_szDescription;
	bstrParams[LONGNAME_INDEX] = rEnum.m_szDescription;
	bstrParams[READWRITE_INDEX] = "0";					// erstmal alles RO
	bstrParams[BITMAP_INDEX] = "21";

// Version dieses Modules erzeugen
CString strVersion;

	strVersion.Format (_T("%s.%s.%s"), TRIASOGC_VERSION, TRIASOGC_RELEASE, TRIASOGC_BUILD);
	bstrParams[VERSION_INDEX] = strVersion;

// Parameter umkopieren
	for (int i = 0; s_regEntryMap[i].szKey; ++i) 
		s_regEntryMap[i].szData = bstrParams[i];

	return _Module.UpdateRegistryFromResource(IDR_FAKETRIASDBSERVER, bRegister, s_regEntryMap);
}

///////////////////////////////////////////////////////////////////////////////
// CTRiASOGCDBEngine

STDMETHODIMP CTRiASOGCDBEngine::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITRiASDBEngine,
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

HRESULT CTRiASOGCDBEngine::FinalConstruct (void)
{
	return S_OK;
}

void CTRiASOGCDBEngine::FinalRelease()
{
	_ASSERTE(NULL == g_pDBEngine);	// existiert nicht mehr (sollte jedenfalls)
}

///////////////////////////////////////////////////////////////////////////////
// ITRiASDBEngine
STDMETHODIMP CTRiASOGCDBEngine::get_Version (BSTR *pVal)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	CHECKOUTPOINTER(pVal);	

CString strVersion;

	strVersion.Format (_T("%s.%s.%s"), TRIASOGC_VERSION, TRIASOGC_RELEASE, TRIASOGC_BUILD);

CComBSTR bstrVersion (strVersion);

	*pVal = bstrVersion.Detach();
	return S_OK;
}

STDMETHODIMP CTRiASOGCDBEngine::put_Password (BSTR bstrPwd)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	CHECKINPOINTER(bstrPwd);	

	m_bstrPassword = bstrPwd;
	return S_OK;
}

STDMETHODIMP CTRiASOGCDBEngine::put_UserName (BSTR bstrUser)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	CHECKINPOINTER(bstrUser);

	m_bstrUserName = bstrUser;
	return S_OK;
}

STDMETHODIMP CTRiASOGCDBEngine::get_Description (BSTR * pVal)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	CHECKOUTPOINTER(pVal);	

// Wert aus der Registry lesen
CRegKey regKey;
char cbBuffer[_MAX_PATH];
DWORD dwLen = sizeof(cbBuffer);

	if (ERROR_SUCCESS != regKey.Open(HKEY_CLASSES_ROOT, "TRiASDB.TRiASOGC.DBEngine.1", KEY_READ) || 
		ERROR_SUCCESS != regKey.QueryValue(cbBuffer, NULL, &dwLen))
	{
		return E_UNEXPECTED;
	}

CComBSTR bstr (cbBuffer);

	if (!bstr)
		return E_OUTOFMEMORY;

	*pVal = bstr.Detach();
	return S_OK;
}

STDMETHODIMP CTRiASOGCDBEngine::Start (STARTMODE rgMode)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)
	_ASSERTE(NULL == g_pDBEngine);	// darf nur einmal gerufen werden

	COM_TRY {
	// singletions instantiieren
		m_Service = WTRiASCSStorageService(CLSID_TRiASCSStorageService);

	// fertig initialisieren
		g_pDBEngine = this;
		g_rgStartMode = rgMode;
		m_fIsStarted = true;

	} COM_CATCH;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// Liefert Enumerator, der alle bekannten Projekttypen enthält

typedef CComEnum<IEnumString, &IID_IEnumString, LPOLESTR, _Copy<LPOLESTR> > CEnumString;

STDMETHODIMP CTRiASOGCDBEngine::EnumDataBaseTypes (IUnknown **ppIEnum)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	CHECKOUTPOINTER(ppIEnum);	

// alle registrierten Datenquellentypen aus Regsitry lesen
CRegKey regEnum;

	if (ERROR_SUCCESS != regEnum.Open(HKEY_CLASSES_ROOT, "TRiASDB.TRiASOGC.DBEngine.1", KEY_READ) ||
		ERROR_SUCCESS != regEnum.Open(regEnum, "TRiASDB", KEY_READ))
	{
		return E_UNEXPECTED;
	}

HRESULT hr = S_OK;

	COM_TRY {
	vector<CComBSTR> vecKeys;
	DWORD dwIndex = 0;
	char cbName[_MAX_PATH];
	DWORD dwSizeName = sizeof(cbName);

		while (ERROR_SUCCESS == RegEnumKey(regEnum, dwIndex++, cbName, dwSizeName)) 
			vecKeys.push_back(CComBSTR(cbName));

	// gefundene Datenquellentypen in Enumerator übernehmen
	CComObject<CEnumString> *pIEnum = new CComObject<CEnumString>();

	// die Funktion Init des EnumTemplates erwartet die Adressen des ersten und 
	// letzten+1 Elementes eines Vektors
	LPOLESTR *poleStart = (LPOLESTR *)vecKeys.begin();
	LPOLESTR *poleEnd = (LPOLESTR *)vecKeys.end();

		hr = pIEnum -> Init (poleStart, poleEnd, static_cast<ITRiASDBEngine *>(this), AtlFlagCopy);
		if (SUCCEEDED(hr))
			hr = pIEnum -> QueryInterface(IID_IEnumString, (LPVOID *)ppIEnum);

		if (FAILED(hr))		// bei Fehler alles freigeben
			delete pIEnum;

	} COM_CATCH;
	return hr;
}

STDMETHODIMP CTRiASOGCDBEngine::Stop()
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	ERROR_EXPR_TRUE(!m_fIsStarted, TRIASDB_E_NOT_STARTED);

	g_pDBEngine = NULL;				// das letzte vom Tage
	return S_OK;
}
