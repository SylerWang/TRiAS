// $Header: $
// Copyright© 1998 Fernerkundungszentrum Potsdam GmbH, All rights reserved
// Created: 10/05/1998 11:04:18 PM
//
// @doc
// @module COMHelper.cpp | COM-Helper eben

#include "stdafx.h"

#include "COMHelper.h"

#define MAXPATHLENGTH		_MAX_PATH
#define MAXTABTITLELENGTH	_MAX_PATH
#define MAXPPIENTRYLENGTH	_MAX_PATH

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////////
// SmartIF's
DefineSmartInterface(SpecifyPropertyPages);		// WSpecifyPropertyPages

/*
  *****************************************************
  * Routine:	InstantiateCOMObject
  *
  * Function:	instantiiert ein COM-Objekt als Inproc-
  *		Server; enthält Fehlerbehandlung für CCI;
  *		AddRef()'ed
  *****************************************************
  * input parameter:
  * - (CLSID): ClassID des Objektes
  *
  * output parameter:
  * - (IUnknown *): Ptr auf IUnknown des Objektes
  *****************************************************
  * Created:        10.09.98  TWI
  * Last modified:  10.09.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

HRESULT InstantiateCOMObject(
	CLSID clsid,						// in:	ClassID des Objektes
	IUnknown **ppUnk)					// out:	Ptr auf IUnknown
{
	HRESULT	_hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (LPVOID *)ppUnk);
	// Fehlerbehandlung für Objektinstantiierung
	switch (_hr)
	{
		case S_OK:					
			break;
		case REGDB_E_CLASSNOTREG:	
			AfxMessageBox(_T("CoCreateInstance fehlgeschlagen.\n Klasse nicht registriert."));
			break;
		case CLASS_E_NOAGGREGATION:	
			AfxMessageBox(_T("CoCreateInstance fehlgeschlagen.\n Aggregation nicht möglich."));
			break;
		case E_INVALIDARG:			
			AfxMessageBox(_T("CoCreateInstance fehlgeschlagen.\n Ungültiges Argument."));
			break;
		default:					
			AfxMessageBox(_T("CoCreateInstance fehlgeschlagen.\n Fehlerursache unbekannt."));
			break;
	}

	return _hr;
}

/*
  *****************************************************
  * Routine:	GetISPP
  *
  * Function:	liefert einen Ptr auf das Interface
  *		ISpecifyPropertyPages eines COM-Objektes; 
  *		enthält Fehlerbehandlung; AddRef()'ed
  *****************************************************
  * input parameter:
  * - (IUnknown *): Ptr auf IUnknown des Objektes
  *
  * output parameter:
  * - (ISpecifyPropertyPages *): Ptr auf 
  *		ISpecifyPropertyPages des Objektes
  *****************************************************
  * Created:        10.09.98  TWI
  * Last modified:  10.09.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

HRESULT GetISPP(
	IUnknown * pUnk,					// in:	Ptr auf IUnknown-Interface des COM-Objektes
	ISpecifyPropertyPages **ppISPP)		// out:	Ptr auf ISpecifyPropertyPages-Interface des COM-Objektes
{
	// NULL-Ptr abfangen
	if (pUnk == NULL || NULL == ppISPP)
	{
		return E_POINTER;
	}

	HRESULT	_hr = pUnk->QueryInterface(IID_ISpecifyPropertyPages, (void **)ppISPP);
	// Fehlerbehandlung für Abfrage ISpecifyPropertyPages über QI
	switch (_hr)
	{
		case S_OK:					
			break;
		case E_NOINTERFACE:
			AfxMessageBox(_T("QueryInterface fehlgeschlagen.\n Interface wird nicht unterstützt."));
			break;
		case REGDB_E_CLASSNOTREG:	
			AfxMessageBox(_T("QueryInterface fehlgeschlagen.\n Klasse nicht registriert."));
			break;
		case CLASS_E_NOAGGREGATION:	
			AfxMessageBox(_T("QueryInterface fehlgeschlagen.\n Aggregation nicht möglich."));
			break;
		case E_INVALIDARG:			
			AfxMessageBox(_T("QueryInterface fehlgeschlagen.\n Ungültiges Argument."));
			break;
		default:					
			AfxMessageBox(_T("QueryInterface fehlgeschlagen.\n Fehlerursache unbekannt."));
			break;
	}

	return _hr;
}

/*
  *****************************************************
  * Routine:	GetIPP
  *
  * Function:	liefert einen Ptr auf das Interface
  *		IPropertyPage eines COM-Objektes; enthält 
  *		Fehlerbehandlung; AddRef()'ed
  *****************************************************
  * input parameter:
  * - (IUnknown *): Ptr auf IUnknown des Objektes
  *
  * output parameter:
  * - (IPropertyPage *): Ptr auf IPropertyPage des 
  *		Objektes
  *****************************************************
  * Created:        10.09.98  TWI
  * Last modified:  10.09.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

HRESULT GetIPP(
	IUnknown * pUnk,					// in:	Ptr auf IUnknown-Interface des COM-Objektes
	IPropertyPage **ppIPP)				// out:	Ptr auf IPropertyPage-Interface des COM-Objektes
{
	// NULL-Ptr abfangen
	if (pUnk == NULL)
	{
		return E_POINTER;
	}

	HRESULT	_hr = pUnk->QueryInterface(IID_IPropertyPage, (void **)ppIPP);
	// Fehlerbehandlung für Abfrage IPropertyPage über QI
	switch (_hr)
	{
		case S_OK:					
			break;
		case E_NOINTERFACE:
			AfxMessageBox(_T("QueryInterface fehlgeschlagen.\n Interface wird nicht unterstützt."));
			break;
		case REGDB_E_CLASSNOTREG:	
			AfxMessageBox(_T("QueryInterface fehlgeschlagen.\n Klasse nicht registriert."));
			break;
		case CLASS_E_NOAGGREGATION:	
			AfxMessageBox(_T("QueryInterface fehlgeschlagen.\n Aggregation nicht möglich."));
			break;
		case E_INVALIDARG:			
			AfxMessageBox(_T("QueryInterface fehlgeschlagen.\n Ungültiges Argument."));
			break;
		default:					
			AfxMessageBox(_T("QueryInterface fehlgeschlagen.\n Fehlerursache unbekannt."));
			break;
	}

	return _hr;
}

HRESULT ClearUnkArray(
	unsigned long cObjects,				// in:	Anzahl der Objekte im Array
	IUnknown ** &ppUnk)					// out:	indirekter Ptr auf das leere Array
{
	if (ppUnk == NULL)
	{
		return E_POINTER;
	}

	for (unsigned long j = 0; j < cObjects; j++)
	{
		if (ppUnk[j] != NULL)
		{
			ppUnk[j]->Release();
			ppUnk[j] = NULL;
		}
	}
	CoTaskMemFree(ppUnk);
	ppUnk = NULL;

	return S_OK;
}

HRESULT	PrepareCAUUID(
	UINT cObjects,						// in:	Anzahl der PropertyPageObjekte
	CAUUID * &pcaGUID)					// out:	Ptr auf CAUUID-Struktur
{
	if (pcaGUID != NULL)
	{
		return E_POINTER;
	}

	// Struktur CAUUID bereitstellen
	pcaGUID = (CAUUID *) CoTaskMemAlloc(sizeof(CAUUID));
	if (!pcaGUID)
	{
		return E_OUTOFMEMORY;
	}

	pcaGUID->pElems = (GUID *)CoTaskMemAlloc(sizeof(GUID) * cObjects);
	if (!pcaGUID->pElems)
	{
		return E_OUTOFMEMORY;
	}

	pcaGUID->cElems = 0;

	return S_OK;
}

HRESULT	PrepareCAUUID(
	CAUUID * &pcaGUID)					// out:	Ptr auf CAUUID-Struktur
{
	if (pcaGUID != NULL)
	{
		return E_POINTER;
	}

	// Struktur CAUUID bereitstellen
	pcaGUID = (CAUUID *) CoTaskMemAlloc(sizeof(CAUUID));
	if (!pcaGUID)
	{
		return E_OUTOFMEMORY;
	}

	pcaGUID->pElems = (GUID *)CoTaskMemAlloc(sizeof(GUID));
	if (!pcaGUID->pElems)
	{
		return E_OUTOFMEMORY;
	}

	pcaGUID->cElems = 0;

	return S_OK;
}

HRESULT FreeCAUUID(
	CAUUID * &pcaGUID)					// out:	Ptr auf CAUUID-Struktur
{
	if (pcaGUID == NULL)
	{
		return E_POINTER;
	}

	CoTaskMemFree(pcaGUID->pElems);
	CoTaskMemFree(pcaGUID);

	pcaGUID = NULL;

	return S_OK;
}

/*
  *****************************************************
  * Routine:	GetHandleOfModule
  *
  * Function:	fügt ein Objekt der Klasse CCOMTreeItem
  *		in die Liste m_CTIList ein; kann nur intern 
  *		aufgerufen werden
  *****************************************************
  * input parameter:
  * - (CCOMTreeItem): einzufügendes CCOMTreeItem-Objekt
  *
  * output parameter:
  * - (unsigned long): ID des eingefügten Objektes
  *****************************************************
  * Created:        24.07.98  TWI
  * Last modified:  14.08.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

HINSTANCE GetHandleOfModule(CString path)
{
// #HK990625 work around WinNT4 LoadProcess bug
char szModuleShort[_MAX_PATH];
int cbShortName = GetShortPathName (path, szModuleShort, _MAX_PATH);
LPCSTR pcModule = NULL;

	if (cbShortName == _MAX_PATH)
		return false;
	pcModule = (cbShortName == 0 || cbShortName == ERROR_INVALID_PARAMETER) ? path : szModuleShort;

	return ::LoadLibrary(pcModule);
}

/*
  *****************************************************
  * Routine: AssemblyHLMRegPath
  *
  * Function:  erzeugt den Registry-Pfad auf den 
  *		ToolboxBitmap32-Eintrag eines COM-Objektes
  *		im Zweig HKEY_LOCAL_MACHINE
  *****************************************************
  * input parameter:
  * - (CLSID): ClassID des COM-Objektes
  *
  * output parameter:
  * - (CString): Registry-Pfad unter HKEY_LOCAL_MACHINE
  *****************************************************
  * Created:        21.08.98  TWI
  * Last modified:  21.08.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

CString AssemblyHLMRegPath(CLSID clsid)
{
	TCHAR			_buf[MAXPATHLENGTH];
	_buf[MAXPATHLENGTH] = '\0';
	CString			_tempStr = _buf;

	LPOLESTR	_clsidStr;
	StringFromCLSID(clsid, &_clsidStr);
	_tempStr = _clsidStr;

	CString		_path;
	CString		_p1 = "SOFTWARE\\Classes\\CLSID\\";
	_path = _p1 + _clsidStr;

	return _path;
}

/*
  *****************************************************
  * Routine: AssemblyHCRRegPath
  *
  * Function:  erzeugt den Registry-Pfad auf den 
  *		ToolboxBitmap32-Eintrag eines COM-Objektes
  *		im Zweig HKEY_CLASSES_ROOT
  *****************************************************
  * input parameter:
  * - (CLSID): ClassID des COM-Objektes
  *
  * output parameter:
  * - (CString): Registry-Pfad unter HKEY_CLASSES_ROOT
  *****************************************************
  * Created:        21.08.98  TWI
  * Last modified:  21.08.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

CString AssemblyHCRRegPath(CLSID clsid)
{
	TCHAR			_buf[MAXPATHLENGTH];
	_buf[MAXPATHLENGTH] = '\0';
	CString			_tempStr = _buf;

	LPOLESTR	_clsidStr;
	StringFromCLSID(clsid, &_clsidStr);
	_tempStr = _clsidStr;

	CString		_path;
	CString		_p1 = "CLSID\\";
	_path = _p1 + _clsidStr;

	return _path;
}

/*
  *****************************************************
  * Routine: GetInprocServer32Value
  *
  * Function:  hängt an den übergebenen Registry-Pfad
  *		'\InprocServer32' an und ermittelt den Wert
  *		dieses Schlüssels
  *****************************************************
  * input parameter:
  * - (CString): Registry-Pfad
  *
  * output parameter:
  * - (CString): Wert des Schlüssels
  *****************************************************
  * Created:        21.08.98  TWI
  * Last modified:  21.08.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

CString GetInprocServer32Value(CString regStr)
{
	regStr = regStr + "\\InprocServer32";
	return ::GetRegValue(regStr);			// Registry öffnen, lesen und schließen
}

/*
  *****************************************************
  * Routine: GetToolboxBitmap32Value
  *
  * Function:  hängt an den übergebenen Registry-Pfad
  *		'\ToolboxBitmap32' an und ermittelt den Wert
  *		dieses Schlüssels
  *****************************************************
  * input parameter:
  * - (CString): Registry-Pfad
  *
  * output parameter:
  * - (CString): Wert des Schlüssels
  *****************************************************
  * Created:        21.08.98  TWI
  * Last modified:  21.08.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

CString GetToolboxBitmap32Value(CString regStr)
{
	regStr = regStr + "\\ToolboxBitmap32";
	return ::GetRegValue(regStr);			// Registry öffnen, lesen und schließen
}

/*
  *****************************************************
  * Routine: ExtractBitmapID
  *
  * Function:  extrahiert aus einem String der Form
  *		<Pfad, Komma, Leerzeichen, ResourceID> die
  *		ResourceID
  *****************************************************
  * input parameter:
  * - (CString): String der Klasse CString
  *
  * output parameter:
  * - (long): numerischer Wert der ResourceID
  *****************************************************
  * Created:        21.08.98  TWI
  * Last modified:  21.08.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

long ExtractBitmapID(CString &regPathStr)
{
	int			_pos;
	CString		_resIdStr;

	_pos = regPathStr.ReverseFind(_T(','));
	if (_pos >= 0)
	{
		_resIdStr = regPathStr.Right(regPathStr.GetLength() - _pos - 1);
		regPathStr = regPathStr.Left(regPathStr.GetLength() - _pos - 1);
		return ::StrToLong(_resIdStr);
	}
	return 0;
}

/*
  *****************************************************
  * Routine: StrToLong
  *
  * Function:  konvertiert CString nach long (es werden
  *		nur die Ziffern im String umgewandelt)
  *****************************************************
  * input parameter:
  * - (CString): String der Klasse CString
  *
  * output parameter:
  * - (long): numerischer Wert des Strings
  *****************************************************
  * Created:        21.08.98  TWI
  * Last modified:  21.08.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

long StrToLong(CString str)
{
	long _value = 0;

	for (int i = 0; i < str.GetLength(); i++)
	{
		if ((str[i] >= _T('0')) && (str[i] <= _T('9')))
		{
			if (i > 0)
			{
				_value *= 10;
			}
			_value += str[i] - _T('0');
		}
	}

	return _value;
}

/*
  *****************************************************
  * Routine: GetRegValue
  *
  * Function:  ermittelt den Wert eines Registry-
  *		Schlüssels, dessen vollständiger Pfad übergeben
  *		wird
  *****************************************************
  * input parameter:
  * - (CString): Registry-Pfad zum gewünschten 
  *		Schlüssel
  *
  * output parameter:
  * - (CString): Wert des Schlüssels
  *****************************************************
  * Created:        21.08.98  TWI
  * Last modified:  22.09.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

CString GetRegValue(CString regPathStr)
{
	TCHAR			_buf[MAXPATHLENGTH];
	_buf[MAXPATHLENGTH] = '\0';
	CString			_tempStr = _buf;

	HKEY			_hKey;
	long			_lValueSize = 10;
	LPTSTR			_lpszVal;

	CString			retStr = "";

	if (RegOpenKeyEx(HKEY_CLASSES_ROOT, LPCTSTR(regPathStr), 0, KEY_READ, &_hKey) != ERROR_SUCCESS)
	{
		AfxMessageBox(_T("Fehler beim Zugriff auf Registry.\n Zweig konnte nicht geöffnet werden."));
	}
	else 
	{
		// Größe des Schlüssels abfragen
		if (RegQueryValue(_hKey, NULL, NULL, &_lValueSize) != ERROR_SUCCESS)
		{
			AfxMessageBox(_T("Fehler beim Zugriff auf Registry.\n Wert der Schlüsselgröße konnte nicht ermittelt werden."));
		}
		else
		{
			// Schlüssel abfragen
			_lpszVal = new TCHAR[_lValueSize];
			if (RegQueryValue(_hKey, NULL, _lpszVal, &_lValueSize) != ERROR_SUCCESS)
			{
				AfxMessageBox(_T("Fehler beim Zugriff auf Registry.\n Wert des Schlüssels konnte nicht ermittelt werden."));
			}
			else
			{
				_tempStr = _lpszVal;		// Konvertierung LPTSTR nach CString
				retStr = _tempStr;
			}
		}
	}

	// dynamische Variablen aufräumen
	delete _lpszVal;

	// Registrierung schließen
	if (_hKey)
	{
		RegCloseKey(_hKey);
	}

	return retStr;
}

/*
  *****************************************************
  * Routine: GetPropsOfCOMObject
  *
  * Function:  ermittelt CLSIDs der
  *		Eigenschaftsseiten eines (beliebigen) 
  *		COM-Objektes.
  *****************************************************
  * input parameter:
  * - (ISpecifyPropertyPages*): Ptr auf konkretes 
  *		ISPP-Interface
  *	- (CAUUID*): Ptr auf Struktur, welche die 
  *		PropertyPage-Objekte enthält
  *
  * output parameter:
  * - (HRESULT): Ergebnis des Dialogs
  *****************************************************
  * Created:        02.07.98  TWI
  * Last modified:  10.07.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

HRESULT GetPropsOfCOMObject(
	IUnknown * pUnk,					// in:	Ptr auf IUnknown-Interface
	CAUUID * &pPages)					// out:	Ptr auf CAUUID-Struktur der ermittelten PropertyPages
{
HRESULT						_hr;
WSpecifyPropertyPages		ISPP;

	if (pPages != NULL)
		return E_POINTER;

// Struktur bereitstellen
	RETURN_FAILED_HRESULT(::PrepareCAUUID(pPages));
	if (pUnk == NULL)
		return S_FALSE;		// no object, no fun

	_hr = ::GetISPP(pUnk, ISPP.ppi());
	if (_hr != S_OK) {
	// Interface ISpecifyPropertyPages wird nicht unterstützt
		::FreeCAUUID(pPages);
		return _hr;
	}
	else
	{
		// Eigenschaften abfragen
		_hr = ISPP->GetPages(pPages);

		// Fehlerbehandlung für GetPages
		switch (_hr)
		{
			case S_OK:					
				break;
			case REGDB_E_CLASSNOTREG:	
				AfxMessageBox(_T("GetPages fehlgeschlagen.\n Klasse nicht registriert."));
				::FreeCAUUID(pPages);
				break;
			case CLASS_E_NOAGGREGATION:	
				AfxMessageBox(_T("GetPages fehlgeschlagen.\n Aggregation nicht möglich."));
				::FreeCAUUID(pPages);
				break;
			case E_INVALIDARG:			
				AfxMessageBox(_T("GetPages fehlgeschlagen.\n Ungültiges Argument."));
				::FreeCAUUID(pPages);
				break;
			default:					
				AfxMessageBox(_T("GetPages fehlgeschlagen.\n Fehlerursache unbekannt."));
				::FreeCAUUID(pPages);
				break;
		}
		return _hr;
	}
}

/*
  *****************************************************
  * Routine: GetCommonProps
  *
  * Function:  ermittelt die gemeinsamen Eigenschaften
  *		von COM-Objekten; diese Methode kann nur mit
  *		einer Liste aufgerufen werden, welche zwei oder
  *		mehr Objekte enthält
  *****************************************************
  * input parameter:
  * - (list<CAUUID*>): Liste von CAUUID-Strukturen zur
  *		Aufnahme der PropertyPage-Objekte der Objekte
  * - (CAUUID *): CAUUID-Struktur zur
  *		Aufnahme der gemeinsamen PropertyPage-Objekte
  *
  * output parameter:
  * - (HRESULT): Ergebnis des Dialogs
  *****************************************************
  * Created:        13.07.98  TWI
  * Last modified:  31.07.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

HRESULT GetCommonProps(
	list<CAUUID *> pps,					// in:	Liste von Ptr auf die zu prüfenden CAUUID-Strukturen
	CAUUID * &commonPPs)				// out:	Ptr auf CAUUID-Struktur der ermittelten PropertyPages
{
	HRESULT						_hr;
	// Diese PPs sind allen Objekten gemeinsam
	list<BOOL>					_commonPropPages;
	// Diese Objekte besitzen _eine_ (spezielle) PropertyPage
	list<BOOL>					_propObjects;

	list<CAUUID *>::iterator	_Icauuid;
	list<BOOL>::iterator		_Ibool;
	list<BOOL>::iterator		_IboolcPP;
	CLSID						*_baseClassPPObjects;
	CLSID						*_compareClassPPObjects;
	CAUUID						*_baseClass;
	CAUUID						*_compareClass;
	CLSID						_curBasePPCLSID, _curComparePPCLSID;
	BOOL						_PPPresent;
	unsigned int				_propPageBaseIndex, i, _compPPIndex;
	unsigned long				_max = 0;

	if (pps.size() == 0)
	{
		return E_FAIL;
	}

	if (commonPPs != NULL)
	{
		return E_POINTER;
	}

	_hr = ::PrepareCAUUID((pps.front())->cElems, commonPPs);
	if (_hr != S_OK)
	{
		return _hr;
	}

	// Ptr auf die CLSIDs aller PPs des Basis-COM-Objektes
	_baseClass = pps.front();
	_baseClassPPObjects = _baseClass->pElems;

	// ein Element weniger in _propObjects bereitstellen, als COM-Objekte übergeben wurden
	for (i = 0; i < (pps.size() - 1); i++)
	{
		_propObjects.push_back(FALSE);
	}

	// soviele Elemente in _commonPropPages bereitstellen und initialisieren, wie CLSIDs von PPs 
	// des Basis-COM-Objektes vorhanden sind (mehr können nicht gemeinsam sein)
	for (i = 0; i < _baseClass->cElems; i++)
	{
		_commonPropPages.push_back(FALSE);
	}

	// Iterator über _commonPropPages auf erstes Element setzen und merken
	_IboolcPP = _commonPropPages.begin();

	// für alle CLSIDs der PPs des Basis-COM-Objektes
	for (_propPageBaseIndex = 0; _propPageBaseIndex < _baseClass->cElems; _propPageBaseIndex++)
	{
		// aktuelle PP-CLSID des Basis-COM-Objektes
		_curBasePPCLSID = _baseClassPPObjects[_propPageBaseIndex];

		// 'Bitfeld' der Objekte initialisieren
		for (_Ibool = _propObjects.begin(); _Ibool != _propObjects.end(); ++_Ibool)
		{
			*_Ibool = FALSE;
		}

		// Iteratoren der übergebenen Liste pps und des 'Bitfeldes' der Objekte (_propObjects) initialisieren
		_Icauuid = pps.begin();
		_Ibool = _propObjects.begin();
		// die erste CAUUID-Struktur muß nicht mit sich selbst verglichen werden
		++_Icauuid;
		// Der Index wird nur mitgeführt, um auch das letzte Element der Compare-Liste
		// zu erwischen. Bei der Abbruchbedingung '_Icauuid != pps.end()' passiert dies nicht.
		unsigned int IcauuidIndex = 1;

		// für alle Compare-COM-Objekte
		do
		{
			// aktuelles Compare-COM-Objekt tempern (erforderlich für Zugriff auf dessen Daten)
			_compareClass = *_Icauuid;
			// Ptr auf alle PPs des aktuellen Compare-COM-Objektes
			_compareClassPPObjects = _compareClass->pElems;
			_compPPIndex = 0;
			// für alle PPs des aktuellen Compare-COM-Objektes:
			// (Abbruch, wenn die PP gefunden wurde)
			while ((_compPPIndex < _compareClass->cElems) && !(*_Ibool))
			{
				_curComparePPCLSID = _compareClassPPObjects[_compPPIndex];
				if ((_curBasePPCLSID.Data1 == _curComparePPCLSID.Data1) && \
					(_curBasePPCLSID.Data2 == _curComparePPCLSID.Data2) && \
					(_curBasePPCLSID.Data3 == _curComparePPCLSID.Data3))
				{
					// PP in _propObjects als vorhanden kennzeichnen
					*_Ibool = TRUE;
				}
				_compPPIndex++;
			}
			++_Icauuid;
			++IcauuidIndex;
			++_Ibool;
		} 
		while (IcauuidIndex < pps.size());

		_Ibool = _propObjects.begin();
		// War die aktuelle PP überall in _propObjects vorhanden, bekommt _commonPropPages der aktuellen
		// PP-CLSID eine 1. Im Basis-COM-Objekt ist sie auf jeden Fall enthalten.
		_PPPresent = TRUE;

		do
		{
			_PPPresent = _PPPresent & *_Ibool;
			++_Ibool;
		}
		while ((_Ibool != _propObjects.end()) && _PPPresent);

		*_IboolcPP = _PPPresent;
		// Iterator auf das nächste Element in _commonPropPages setzen
		_IboolcPP++;
	}

	// Struktur füllen
	int index = 0;
	for (_Ibool = _commonPropPages.begin(); _Ibool != _commonPropPages.end(); ++_Ibool)
	{
		if (*_Ibool)
		{
			commonPPs->pElems[commonPPs->cElems] = _baseClassPPObjects[index];
			commonPPs->cElems += 1;
		}
		index++;
	}

	return S_OK;
}

/*
  *****************************************************
  * Routine: ObjectWithNoPPExists
  *
  * Function:  ermittelt, ob in einer vorgegebenen
  *		Menge von COM-Objekte mind. eines ohne
  *		PropertyPages existiert
  *****************************************************
  * input parameter:
  * - (CAUUID *): Array von CAUUID-Strukturen zur 
  *		Aufnahme der PropertyPage-Objekte der Objekte
  *	- (long): Anzahl der COM-Objekte
  *
  * output parameter:
  * - (BOOL): logisches Ergebnis der Funktion
  *		TRUE, wenn ein Objekt ohne PropertyPages
  *		vorhanden ist, sonst FALSE
  *****************************************************
  * Created:        14.07.98  TWI
  * Last modified:  31.07.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

HRESULT ObjectWithNoPPExists(
	list<CAUUID *> objectPropIDs,		// in:	Liste von Ptr auf CAUUID-Strukturen der COM-Objekte
	BOOL &retVal)						// out:	TRUE, wenn eins der Objekte in objectPropIDs keine Property Pages hat
{
	BOOL						_abbruch = FALSE;
	list<CAUUID *>::iterator	_Icauuid;

	if (objectPropIDs.size() == 0)
	{
		return E_FAIL;
	}

	_Icauuid = objectPropIDs.begin();
	while ((_Icauuid != objectPropIDs.end()) && !_abbruch)
	{
		if (((CAUUID *)*_Icauuid)->cElems == 0)
		{
			_abbruch = TRUE;
		}
		_Icauuid++;
	}

	(_abbruch) ? retVal = TRUE : retVal = FALSE;

	return S_OK;
}

