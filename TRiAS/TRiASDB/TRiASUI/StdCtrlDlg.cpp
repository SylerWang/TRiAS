/*
  *****************************************************
  * Copyright:
  *   Datenmanagement- & Präsentationssysteme
  *   Weimarer Str. 1B
  *   D-98693 Ilmenau
  *   GERMANY
  *****************************************************
  * Module: Implementation, Klasse CStdCtrlDlg: 
  *		Dialog, der die Anzeige eines Eigenschaften-
  *		dialoges ermöglicht
  *
  * Function: enthält das TreeViewControl des Stingray
  *		Objective Toolkit 5.2 zur Anzeige der 
  *		Eigenschaftsdialoge der selektierten COM-
  *		Objekte
  *****************************************************
  * Created:        15.07.98  TWI
  * Last modified:  01.10.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 01.10.98
  *****************************************************
*/

// StdCtrlDlg.cpp: Implementierungsdatei
//

#include "stdafx.h"

#include "Strings.h"
#include "MfcHelper.h"
#include "PropPageInfo.h"
#include "StdCtrlDlg.h"
#include "TRiASOptionDlg.h"

#define MAXTABTITLELENGTH	_MAX_PATH
#define MAXPPIENTRYLENGTH	_MAX_PATH

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif //_DEBUG

DefineSmartInterface(UIContextHandle);

/////////////////////////////////////////////////////////////////////////////
// SmartIF's
DefineSmartInterface(Dispatch);
DefineSmartInterface(Picture);

#if _TRiAS_VER < 0x0400
///////////////////////////////////////////////////////////////////////////////
// Version 4 emulieren
extern DWORD g_dwVer4;
#endif // _TRiAS_VER < 0x0400

/////////////////////////////////////////////////////////////////////////////
// Dialogfeld CStdCtrlDlg 

IMPLEMENT_SERIAL (CStdCtrlDlg, CDialog, 0)

BEGIN_INTERFACE_MAP(CStdCtrlDlg, CDialog)
	INTERFACE_PART(CStdCtrlDlg, IID_IPropertyPageSite, PropPageSite)
	INTERFACE_PART(CStdCtrlDlg, IID_IPersistStreamInit, PersistStreamInit)
END_INTERFACE_MAP()

/*
  *****************************************************
  * Routine: CStdCtrlDlg
  *
  * Function:	Konstruktor der Klasse CStdCtrlDlg;
  *		erzeugt ein SECTreeControl (in m_pSECTreeCtrl),
  *		initialisiert den Dialogstatus und erzeugt die
  *		Bitmapliste zur Anzeige
  *****************************************************
  * input parameter:
  * - (CWnd *): Handle auf Parent-Window (=NULL)
  *
  * output parameter:
  * - none
  *****************************************************
  * Created:        15.07.98  TWI
  * Last modified:  22.09.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

CStdCtrlDlg::CStdCtrlDlg(CWnd* pParent)
	: CDialog(CStdCtrlDlg::IDD, pParent)
{
	EnableAutomation();

// Make this object aggregatable.
	EnableAggregation();   

// To keep the application running as long as an OLE automation 
// object is active, the constructor calls AfxOleLockApp.   
	AfxOleLockApp(); 

	//{{AFX_DATA_INIT(CStdCtrlDlg)
	//}}AFX_DATA_INIT

// IPropertyPageSite-Interface bereitstellen
	VERIFY(SUCCEEDED(InternalQueryInterface(&IID_IPropertyPageSite, m_IPropPageSite.ppv())));

	InitDlgState();
	InitTreeCtrlEnv();

	if (!m_imageList.Create (IDB_NOPIC, 16, 16, RGB(255, 0, 255)))
		TRACE0("Could not create imagelist for CStdCtrlDlg\r\n");

	m_curMaxPageSize.cx = 0;
	m_curMaxPageSize.cy = 0;

	m_fEnabled = TRUE;		// erstes HandleEmptyPage erzwingen
	m_pTarget = NULL;
	m_pPopup = NULL;
	m_uiDefault = (UINT)-1;
	m_ContextHandle = NULL;
}

///////////////////////////////////////////////////////////////////////////////
// Dialog erzeugen
BOOL CStdCtrlDlg::Create()
{
	return CDialog::Create (CStdCtrlDlg::IDD, m_pParentWnd);
}

void CStdCtrlDlg::HandleEmptyPage (BOOL fEnable, LPCTSTR pcText)
{
	if (fEnable == m_fEnabled) {
		if (m_fEnabled && NULL != pcText)
			m_Text.SetWindowText(pcText);	// evtl. lediglich Text verändern
		return;
	}

	if (fEnable) {
		UpdatePropApplyBtn();			// Apply jetzt enabled/disabled

		m_PropSheet.EnableWindow(FALSE);
		m_PropSheet.ShowWindow (SW_HIDE);

		m_Frame.EnableWindow(TRUE);
		m_Frame.ShowWindow (SW_SHOW);
		m_Text.EnableWindow(TRUE);
		m_Text.SetWindowText(pcText);
		m_Text.ShowWindow (SW_SHOW);
		m_Rectangle.EnableWindow(TRUE);
		m_Rectangle.ShowWindow (SW_SHOW);
	} else {
		m_Frame.EnableWindow(FALSE);
		m_Frame.ShowWindow (SW_HIDE);
		m_Text.EnableWindow(FALSE);
		m_Text.ShowWindow (SW_HIDE);
		m_Rectangle.EnableWindow(FALSE);
		m_Rectangle.ShowWindow (SW_HIDE);

		m_PropSheet.EnableWindow(TRUE);
		m_PropSheet.ShowWindow (SW_SHOW);
	}

	m_fEnabled = fEnable;
}

/*
  *****************************************************
  * Routine: ~CStdCtrlDlg
  *
  * Function:	Destruktor der Klasse CStdCtrlDlg;
  *		zerstört das SECTreeControl (in m_pSECTreeCtrl)
  *****************************************************
  * input parameter:
  * - none
  *
  * output parameter:
  * - none
  *****************************************************
  * Created:        15.07.98  TWI
  * Last modified:  22.09.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

CStdCtrlDlg::~CStdCtrlDlg()
{
	VERIFY(SUCCEEDED(FreeCurrentPages()));

	ClearCTIList(m_CTIList);	// Liste der CCOMTreeItems löschen
	AfxOleUnlockApp();
}

///////////////////////////////////////////////////////////
// IPropertyPageSite-Methoden
///////////////////////////////////////////////////////////

// IUnknown for IPropPageSite    
IMPLEMENT_IUNKNOWN(CStdCtrlDlg, PropPageSite)

/*
  *****************************************************
  * Routine:	XPropPageSite::OnStatusChange
  *
  * Function:	Umleitung auf OnStatusChange des 
  *		Dialogs
  *****************************************************
  * input parameter:
  * - (DWORD): Flags
  *
  * output parameter:
  * - (HRESULT): Ergebnis des OnStatusChange des 
  *		Dialogs
  *****************************************************
  * Created:        28.08.98  TWI
  * Last modified:  01.10.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 01.10.98
  *****************************************************
*/

HRESULT CStdCtrlDlg::XPropPageSite::OnStatusChange(DWORD dwFlags)
{
	METHOD_PROLOGUE(CStdCtrlDlg, PropPageSite)
	return pThis->OnStatusChange(dwFlags);
}

/*
  *****************************************************
  * Routine:	XPropPageSite::GetLocaleID
  *
  * Function:	Umleitung auf GetLocaleID des Dialogs
  *****************************************************
  * input parameter:
  * - (LCID *): Ptr auf den Local Identifier
  *
  * output parameter:
  * - (HRESULT): Ergebnis des GetLocaleID des Dialogs
  *****************************************************
  * Created:        28.08.98  TWI
  * Last modified:  01.10.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 01.10.98
  *****************************************************
*/

HRESULT CStdCtrlDlg::XPropPageSite::GetLocaleID(LCID * pLocaleID)
{
	METHOD_PROLOGUE(CStdCtrlDlg, PropPageSite)
	return pThis->GetLocaleID(pLocaleID);
}

/*
  *****************************************************
  * Routine:	XPropPageSite::GetPageContainer
  *
  * Function:	Umleitung auf GetPageContainer des 
  *		Dialogs
  *****************************************************
  * input parameter:
  * - (IUnknown **): indirekter Ptr auf IUnknown-
  *		Interface
  *
  * output parameter:
  * - (HRESULT): Ergebnis des GetPageContainer des 
  *		Dialogs
  *****************************************************
  * Created:        28.08.98  TWI
  * Last modified:  01.10.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 01.10.98
  *****************************************************
*/

HRESULT CStdCtrlDlg::XPropPageSite::GetPageContainer(IUnknown ** ppUnk)
{
	METHOD_PROLOGUE(CStdCtrlDlg, PropPageSite)
	return pThis->GetPageContainer(ppUnk);
}

/*
  *****************************************************
  * Routine:	XPropPageSite::TranslateAccelerator
  *
  * Function:	Umleitung auf TranslateAccelerator des 
  *		Dialogs
  *****************************************************
  * input parameter:
  * - (LPMSG): Ptr auf Message-Struktur
  *
  * output parameter:
  * - (HRESULT): Ergebnis des TranslateAccelerator des 
  *		Dialogs
  *****************************************************
  * Created:        28.08.98  TWI
  * Last modified:  01.10.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 01.10.98
  *****************************************************
*/

HRESULT CStdCtrlDlg::XPropPageSite::TranslateAccelerator(LPMSG pMsg)
{
	METHOD_PROLOGUE(CStdCtrlDlg, PropPageSite)
	return pThis->TranslateAccelerator(pMsg);
}

///////////////////////////////////////////////////////////
// IPersistStreamInit-Methoden
///////////////////////////////////////////////////////////

// IUnknown for IPersistStreamInit    
IMPLEMENT_IUNKNOWN(CStdCtrlDlg, PersistStreamInit)

/*
  *****************************************************
  * Routine:	XPersistStreamInit::GetClassID
  *
  * Function:	ermittelt die ClassID aus dem Stream
  *****************************************************
  * input parameter:
  * - (CLSID *): Ptr auf die CLSID
  *
  * output parameter:
  * - (HRESULT): Ergebnis des GetClassID des Dialogs
  *****************************************************
  * Created:        28.08.98  TWI
  * Last modified:  01.10.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 01.10.98
  *****************************************************
*/

HRESULT CStdCtrlDlg::XPersistStreamInit::GetClassID(CLSID* pClassID)
{
	METHOD_PROLOGUE(CStdCtrlDlg, PersistStreamInit)
	return pThis->GetClassID(pClassID);
}

/*
  *****************************************************
  * Routine:	XPersistStreamInit::IsDirty
  *
  * Function:	Umleitung auf IsDirty des Dialogs
  *****************************************************
  * input parameter:
  * - none
  *
  * output parameter:
  * - (HRESULT): Ergebnis des IsDirty des Dialogs
  *****************************************************
  * Created:        28.08.98  TWI
  * Last modified:  01.10.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 01.10.98
  *****************************************************
*/

HRESULT CStdCtrlDlg::XPersistStreamInit::IsDirty(void)
{
	METHOD_PROLOGUE(CStdCtrlDlg, PersistStreamInit)
	return pThis->IsDirty();
}

/*
  *****************************************************
  * Routine:	XPersistStreamInit::Load
  *
  * Function:	Umleitung auf Load des Dialogs
  *****************************************************
  * input parameter:
  * - none
  *
  * output parameter:
  * - (HRESULT): Ergebnis des Load des Dialogs
  *****************************************************
  * Created:        28.08.98  TWI
  * Last modified:  01.10.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 01.10.98
  *****************************************************
*/

HRESULT CStdCtrlDlg::XPersistStreamInit::Load(LPSTREAM pStm)
{
	METHOD_PROLOGUE(CStdCtrlDlg, PersistStreamInit)
	return pThis->Load(pStm);
}

/*
  *****************************************************
  * Routine:	XPersistStreamInit::Save
  *
  * Function:	Umleitung auf Save des Dialogs
  *****************************************************
  * input parameter:
  * - none
  *
  * output parameter:
  * - (HRESULT): Ergebnis des Save des Dialogs
  *****************************************************
  * Created:        28.08.98  TWI
  * Last modified:  01.10.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 01.10.98
  *****************************************************
*/

HRESULT CStdCtrlDlg::XPersistStreamInit::Save(LPSTREAM pStm, BOOL fClearDirty)
{
	METHOD_PROLOGUE(CStdCtrlDlg, PersistStreamInit)
	return pThis->Save(pStm, fClearDirty);
}

/*
  *****************************************************
  * Routine:	XPersistStreamInit::GetSizeMax
  *
  * Function:	Umleitung auf GetSizeMax des Dialogs
  *****************************************************
  * input parameter:
  * - none
  *
  * output parameter:
  * - (HRESULT): Ergebnis des GetSizeMax des Dialogs
  *****************************************************
  * Created:        28.08.98  TWI
  * Last modified:  01.10.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 01.10.98
  *****************************************************
*/

HRESULT CStdCtrlDlg::XPersistStreamInit::GetSizeMax(ULARGE_INTEGER* pcbSize)
{
	METHOD_PROLOGUE(CStdCtrlDlg, PersistStreamInit)
	return pThis->GetSizeMax(pcbSize);
}

/*
  *****************************************************
  * Routine:	XPersistStreamInit::InitNew
  *
  * Function:	Umleitung auf InitNew des Dialogs
  *****************************************************
  * input parameter:
  * - none
  *
  * output parameter:
  * - (HRESULT): Ergebnis des InitNew des Dialogs
  *****************************************************
  * Created:        28.08.98  TWI
  * Last modified:  01.10.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 01.10.98
  *****************************************************
*/

HRESULT CStdCtrlDlg::XPersistStreamInit::InitNew(void)
{
	METHOD_PROLOGUE(CStdCtrlDlg, PersistStreamInit)
	return pThis->InitNew();
}

///////////////////////////////////////////////////////////
// Implementierung der Methoden von IPropertyPageSite
///////////////////////////////////////////////////////////

/*
  *****************************************************
  * Routine:	OnStatusChange
  *
  * Function:	reagiert als PageContainer auf 
  *		Änderungen der Seiten durch Enablen/Disablen
  *		der Schalter unter dem TabControl
  *****************************************************
  * input parameter:
  * - (DWORD): Flags
  *
  * output parameter:
  * - (HRESULT): Ergebnis der Funktion
  *****************************************************
  * Created:        28.08.98  TWI
  * Last modified:  01.10.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 01.10.98
  *****************************************************
*/

HRESULT CStdCtrlDlg::OnStatusChange(DWORD dwFlags)
{
	if (dwFlags & PROPPAGESTATUS_DIRTY)
		return UpdatePropApplyBtn();
	return S_OK;
}

/*
  *****************************************************
  * Routine:	GetLocaleID
  *
  * Function:	ermittelt den Local Identifier
  *****************************************************
  * input parameter:
  * - (LCID *): Ptr auf den Local Identifier
  *
  * output parameter:
  * - (HRESULT): Ergebnis der Funktion
  *****************************************************
  * Created:        28.08.98  TWI
  * Last modified:  01.10.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 01.10.98
  *****************************************************
*/

HRESULT CStdCtrlDlg::GetLocaleID(LCID * pLocaleID)
{
	if (NULL == pLocaleID)
		return E_POINTER;

	*pLocaleID = GetUserDefaultLCID();
	return S_OK;
}

HRESULT CStdCtrlDlg::GetPageContainer(IUnknown ** ppUnk)
{
	return E_NOTIMPL;
}

HRESULT CStdCtrlDlg::TranslateAccelerator(LPMSG pMsg)
{
	return PreTranslateMessage(pMsg) ? S_OK : S_FALSE;
}

///////////////////////////////////////////////////////////
// Implementierung der Methoden von IPersistStreamInit
///////////////////////////////////////////////////////////

/*
  *****************************************************
  * Routine:	GetClassID
  *
  * Function:	ermittelt die ClassID des Dialogs; da
  *		dies eine MFC-Klasse ist, wird die ClassID 0
  *		zurückgegeben
  *****************************************************
  * input parameter:
  * - (CLSID *): Ptr auf die CLSID
  *
  * output parameter:
  * - (HRESULT): Ergebnis der Funktion
  *****************************************************
  * Created:        28.08.98  TWI
  * Last modified:  01.10.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 01.10.98
  *****************************************************
*/

HRESULT CStdCtrlDlg::GetClassID(CLSID* pClassID)
{
	ASSERT(FALSE);		// should not be called
	return E_NOTIMPL;
}


/*
  *****************************************************
  * Routine:	IsDirty
  *
  * Function:	ermittelt, ob die Daten des Dialogs 
  *		geändert wurden
  *****************************************************
  * input parameter:
  * - none
  *
  * output parameter:
  * - (HRESULT): Ergebnis der Funktion
  *****************************************************
  * Created:        28.08.98  TWI
  * Last modified:  01.10.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 01.10.98
  *****************************************************
*/

HRESULT CStdCtrlDlg::IsDirty(void)
{
	return (IsModified() || HasDataChanged()) ? S_OK : S_FALSE;
}

/*
  *****************************************************
  * Routine:	Load
  *
  * Function:	lädt den Zustand des Dialogs aus einem
  *		Stream
  *****************************************************
  * input parameter:
  * - (LPSTREAM): Ptr auf den Stream
  *
  * output parameter:
  * - (HRESULT): Ergebnis der Funktion
  *****************************************************
  * Created:        28.08.98  TWI
  * Last modified:  01.10.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 01.10.98
  *****************************************************
*/

HRESULT CStdCtrlDlg::Load(LPSTREAM pStm)
{
	USES_CONVERSION;
	if (StateWasLoaded())
		return E_UNEXPECTED;
	if (NULL == pStm)
		return E_POINTER;

UINT _objCount;
ULONG _bytesRead;

// Daten des Dialogs laden
	RETURN_FAILED_HRESULT(pStm->Read(&m_WordWrapEnabled, sizeof(BOOL), &_bytesRead));
	RETURN_FAILED_HRESULT(pStm->Read(&m_HasLinesEnabled, sizeof(BOOL), &_bytesRead));
	RETURN_FAILED_HRESULT(pStm->Read(&m_HasButtonsEnabled, sizeof(BOOL), &_bytesRead));
	RETURN_FAILED_HRESULT(pStm->Read(&m_MultiSelectEnabled, sizeof(BOOL), &_bytesRead));

CComBSTR bstrCaption;

	RETURN_FAILED_HRESULT(bstrCaption.ReadFromStream(pStm));
	SetCaption(OLE2A(bstrCaption));
	
// Daten der CCOMTreeItem's des TreeCtrls laden
// Anzahl der Objekte und Objekte selbst
CCOMTreeItem		_cti;

	RETURN_FAILED_HRESULT(pStm->Read(&_objCount, sizeof(UINT), &_bytesRead));
	for (unsigned int i = 0; i < _objCount; i++)
	{
		RETURN_FAILED_HRESULT(_cti.Load(pStm));
		InsertItem(_cti);
	}

	ASSERT(m_CTIList.size() == _objCount);
	SetStateLoadedFlag(TRUE);
	return S_OK;
}

/*
  *****************************************************
  * Routine:	Save
  *
  * Function:	speichert den Zustand des Dialogs in
  *		einem Stream
  *****************************************************
  * input parameter:
  * - (LPSTREAM): Ptr auf den Stream
  *
  * output parameter:
  * - (HRESULT): Ergebnis der Funktion
  *****************************************************
  * Created:        28.08.98  TWI
  * Last modified:  01.10.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 01.10.98
  *****************************************************
*/

HRESULT CStdCtrlDlg::Save(LPSTREAM pStm, BOOL fClearDirty)
{
UINT							_objCount;
CComTreeItems::iterator	_Icti;
ULONG							_bytesWritten;

// Daten des Dialogs speichern
	RETURN_FAILED_HRESULT(pStm->Write(&m_WordWrapEnabled, sizeof(BOOL), &_bytesWritten));
	RETURN_FAILED_HRESULT(pStm->Write(&m_HasLinesEnabled, sizeof(BOOL), &_bytesWritten));
	RETURN_FAILED_HRESULT(pStm->Write(&m_HasButtonsEnabled, sizeof(BOOL), &_bytesWritten));
	RETURN_FAILED_HRESULT(pStm->Write(&m_MultiSelectEnabled, sizeof(BOOL), &_bytesWritten));

// Caption des Fensters speichern
	GetWindowText (m_strCaption);

CComBSTR bstrCaption (m_strCaption);

	RETURN_FAILED_HRESULT(bstrCaption.WriteToStream(pStm));

// Daten der CCOMTreeItem's des TreeCtrls speichern
// Anzahl der Objekte
	_objCount = m_CTIList.size();
	RETURN_FAILED_HRESULT(pStm->Write(&_objCount, sizeof(UINT), &_bytesWritten));

// Objekte selbst
	for (_Icti = m_CTIList.begin(); _Icti != m_CTIList.end(); ++_Icti)
	{
		RETURN_FAILED_HRESULT((*_Icti).second.Save(pStm));
	}

	if (fClearDirty)
		SetDataChangedFlag(FALSE);
	return S_OK;
}

HRESULT CStdCtrlDlg::GetSizeMax(ULARGE_INTEGER* pcbSize)
{
	return E_NOTIMPL;
}

HRESULT CStdCtrlDlg::InitNew(void)
{
	if (StateWasLoaded())
		return E_UNEXPECTED;

	SetStateLoadedFlag(true);
	return S_OK;
}

/*
  *****************************************************
  * Routine: DoDataExchange
  *
  * Function:  
  *****************************************************
  * input parameter:
  * - (CDataExchange *):
  *
  * output parameter:
  * - none
  *****************************************************
  * Created:        15.07.98  TWI
  * Last modified:  23.07.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

void CStdCtrlDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CStdCtrlDlg)
	DDX_Control(pDX, IDC_STATIC_FRAME, m_Frame);
	DDX_Control(pDX, IDC_STATIC_TEXT, m_Text);
	DDX_Control(pDX, IDC_STATIC_RECTANGLE, m_Rectangle);
	DDX_Control(pDX, IDC_TAB, m_PropSheet);
	DDX_Control(pDX, IDOK, m_OKBtn);
	DDX_Control(pDX, IDCANCEL, m_CancelBtn);
	//}}AFX_DATA_MAP

	DDX_Control(pDX, IDAPPLY, m_ApplyBtn);
}

static UINT uiPreparePopupMenu = RegisterWindowMessage(PrepareMenuString);
static UINT uiDestroyPopupMenu = RegisterWindowMessage(DestroyMenuString);
static UINT uiInitCoolButton = RegisterWindowMessage("InitCoolButton");

BEGIN_MESSAGE_MAP(CStdCtrlDlg, CDialog)
	//{{AFX_MSG_MAP(CStdCtrlDlg)
	ON_NOTIFY(NM_CLICK, IDC_TREE, OnClickTree)
	ON_NOTIFY(TVN_ITEMEXPANDED, IDC_TREE, OnItemexpandedTree)
	ON_NOTIFY(TVN_SELCHANGED, IDC_TREE, OnSelchangedTree)
	ON_NOTIFY(TCN_SELCHANGING, IDC_TAB, OnSelChangingTab)
	ON_NOTIFY(TCN_SELCHANGE, IDC_TAB, OnSelChangeTab)
	ON_NOTIFY(TVN_GETDISPINFO, IDC_TREE, OnGetdispinfoTree)
	ON_NOTIFY(TVN_ITEMEXPANDING, IDC_TREE, OnItemexpandingTree)
	ON_NOTIFY(NM_RCLICK, IDC_TREE, OnRclickTree)
	ON_BN_CLICKED(IDAPPLY, OnApply)
	ON_REGISTERED_MESSAGE(uiPreparePopupMenu, OnPreparePopupMenu)
	ON_REGISTERED_MESSAGE(uiDestroyPopupMenu, OnDestroyPopupMenu)
	ON_REGISTERED_MESSAGE(uiInitCoolButton, OnInitCoolButton)
	ON_BN_CLICKED(IDB_ACTIONS, OnActions)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// Behandlungsroutinen für Nachrichten CStdCtrlDlg 

/*
  *****************************************************
  * Routine: OnInitDialog
  *
  * Function:	Event-Handler für WM_INITDIALOG;
  *		lädt den TreeControl-Status, 
  *		Subclassing mit dem designten CTreeCtrl, Setzen
  *		der Bildliste und Konfiguration des 
  *		SECTreeCtrls (m_pSECTreeCtrl)
  *		mit dem geladenen TreeControl-Status;
  *		lädt die übergebenen Daten in das TreeControl
  *****************************************************
  * input parameter:
  * - none
  *
  * output parameter:
  * - (BOOL): TRUE, wenn erfolgreich ausgeführt
  *****************************************************
  * Created:        15.07.98  TWI
  * Last modified:  01.10.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 01.10.98
  *****************************************************
*/

BOOL CStdCtrlDlg::OnInitDialog() 
{
	CComTreeItems				_selItems;
//	CComTreeItems::iterator	_Icti;

	CDialog::OnInitDialog();

	HandleEmptyPage(FALSE);
	if (!m_strCaption.IsEmpty())
		SetWindowText (m_strCaption);

	CenterWindow(GetParent());

// aus dem designten MS-Control ein SECTreeControl machen
	if (!m_SECTreeCtrl.SubclassTreeCtrlId( IDC_TREE, this ))
		ASSERT(FALSE);
	m_SECTreeCtrl.SetImageList(&m_imageList, TVSIL_NORMAL);

// die übergebenen COM-Objekte in das TreeControl einfügen
//	FillTreeCtrl();
	if (NULL != m_pTarget)
		m_pTarget -> Fire_OnInitDialog();

	if (DlgWasShown()) {
		if(HasDataChanged())
		{
			// Der Status des TreeControls ist (entsprechend der internen Statusinformationen)
			// jungfräulich.
		}
		else
		{
			m_TreeExpanded = FALSE;
			// Der Dialog wurde bereits angezeigt:
			// Den letzten Status des TreeControls (expandierte Knoten, Selektionen) aus den internen
			// Laufzeitinformationen wiederherstellen.
			UpdateTreeCtrlState(m_CTIList);
		}
	}
//	if (!StateWasLoaded())
//	{
//		InitTreeCtrlEnv();
//	}

// Actions-Button einbinden
	m_Actions.SubclassDlgItem(IDB_ACTIONS, this);
//	m_Actions.SetButtonImage(IDC_ACTIONS, RGB(255, 0, 255));
#if _TRiAS_VER < 0x0400
	if (0 == g_dwVer4) {
		m_Actions.EnableWindow(FALSE);
		m_Actions.ShowWindow(SW_HIDE);
	}
#endif // _TRiAS_VER < 0x0400

	SetModifiedFlag(FALSE);
	SetDataChangedFlag(FALSE);
	SetShownFlag(TRUE);

//	// Controls über den aktuellen Zustand 'informieren'
//	m_WordWrapChk.SetCheck(m_WordWrapEnabled);
//	m_HasLinesChk.SetCheck(m_HasLinesEnabled);
//	m_HasButtonsChk.SetCheck(m_HasButtonsEnabled);

// Treecontrol konfigurieren
	m_SECTreeCtrl.EnableMultiSelect(m_MultiSelectEnabled);
	m_SECTreeCtrl.EnableWordWrap(m_WordWrapEnabled);

// Fly-by-Tooltips sind standardmäßig enabled, um mit dem SysTreeView32 kompatibel zu sein
// Default-Farben verwenden: funktioniert nur mit OT 5.2
#if _SEC_VER > 0x0510
	m_SECTreeCtrl.EnableSysColorTracking();
#endif // _SEC_VER > 0x0510
	ToggleStyle(TVS_HASLINES, m_HasLinesEnabled);
	ToggleStyle(TVS_HASBUTTONS, m_HasButtonsEnabled);

#if _SEC_VER > 0x0510
	if (m_TreeExpanded)
	{
		// alle Rootelemente expandieren; deren Children werden rekursiv mit expandiert
		CComTreeItems::iterator	Icti;
		for (Icti = m_CTIList.begin(); Icti != m_CTIList.end(); ++Icti)
		{
			if (IsRootObject((*Icti).second))
			{
				m_SECTreeCtrl.ExpandCompletely((*Icti).second.m_hItem, TRUE);
			}
		}
	}
#endif // _SEC_VER

// das selektierte Item ermitteln...
	GetSelectedItems(m_CTIList, _selItems);

// ...und dessen Eigenschaften anzeigen
	if (_selItems.size() > 0) {
		ShowObjectProps(_selItems);
		ClearCTIList(_selItems);
	}
	else
		ShowEmptyPP(IDS_NOSELECTEDITEM);

// ApplyButton behandeln
	if (!GetHasApply()) {
	// OK Knopf schieben
	CRect rect;

		m_CancelBtn.GetWindowRect (&rect);
		ScreenToClient (&rect);
		m_OKBtn.SetWindowPos (NULL, rect.left, rect.top, 0, 0, SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);

	// Cancel-Knopf schieben
		m_ApplyBtn.GetWindowRect (&rect);
		ScreenToClient (&rect);
		m_CancelBtn.SetWindowPos (NULL, rect.left, rect.top, 0, 0, SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);

	// Apply Knopf ausblenden
		m_ApplyBtn.ShowWindow (SW_HIDE);
	}

// Button neu setzen
	PostMessage(uiInitCoolButton, TRUE);
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CStdCtrlDlg::ShutDown() 
{
	m_IPropPageSite.Assign(NULL);
}

void CStdCtrlDlg::OnFinalRelease() 
{
	if (m_hWnd != NULL)         
		DestroyWindow();    
	delete this;                
}

/*
  *****************************************************
  * Routine: SetModifiedFlag
  *
  * Function:	Setzt das interne Flag m_DlgIsModified
  *****************************************************
  * input parameter:
  * - (BOOL): zu setzender Status
  *
  * output parameter:
  * - none
  *****************************************************
  * Created:        15.07.98  TWI
  * Last modified:  23.07.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

void CStdCtrlDlg::SetModifiedFlag(BOOL state)
{
	m_DlgIsModified = state;
}

/*
  *****************************************************
  * Routine: IsModified
  *
  * Function:	ermittelt, ob der Dialogzustand 
  *		verändert wurde
  *****************************************************
  * input parameter:
  * - none
  *
  * output parameter:
  * - (BOOL): TRUE, wenn Dialogzustand verändert wurde
  *****************************************************
  * Created:        15.07.98  TWI
  * Last modified:  23.07.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

BOOL CStdCtrlDlg::IsModified()
{
	return (m_DlgIsModified == TRUE);
}

/*
  *****************************************************
  * Routine: SetDataChangedFlag
  *
  * Function:	Setzt das interne Flag m_DataChanged
  *****************************************************
  * input parameter:
  * - (BOOL): zu setzender Status
  *
  * output parameter:
  * - none
  *****************************************************
  * Created:        15.07.98  TWI
  * Last modified:  23.07.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

void CStdCtrlDlg::SetDataChangedFlag(BOOL state)
{
	m_DataChanged = state;
}

/*
  *****************************************************
  * Routine: HasDataChanged
  *
  * Function:	ermittelt, ob die Daten des Dialoges 
  *		verändert wurden
  *****************************************************
  * input parameter:
  * - none
  *
  * output parameter:
  * - (BOOL): TRUE, wenn Dialogdaten verändert wurden
  *****************************************************
  * Created:        15.07.98  TWI
  * Last modified:  23.07.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

BOOL CStdCtrlDlg::HasDataChanged()
{
	return (m_DataChanged == TRUE);
}

/*
  *****************************************************
  * Routine: SetShownFlag
  *
  * Function:	Setzt das interne Flag m_WasShown
  *****************************************************
  * input parameter:
  * - (BOOL): zu setzender Status
  *
  * output parameter:
  * - none
  *****************************************************
  * Created:        15.07.98  TWI
  * Last modified:  23.07.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

void CStdCtrlDlg::SetShownFlag(BOOL state)
{
	m_WasShown = state;
}

/*
  *****************************************************
  * Routine: DlgWasShown
  *
  * Function:	ermittelt, ob der Dialog schon einmal
  *		angezeigt wurde
  *****************************************************
  * input parameter:
  * - none
  *
  * output parameter:
  * - (BOOL): TRUE, wenn Dialog angezeigt wurde
  *****************************************************
  * Created:        15.07.98  TWI
  * Last modified:  23.07.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

BOOL CStdCtrlDlg::DlgWasShown()
{
	return (m_WasShown == TRUE);
}

/*
  *****************************************************
  * Routine: InitDlgState
  *
  * Function:	Initialisiert den Default-Dialogzustand
  *		in den Member-Variablen m_DlgIsModified, 
  *		m_DataChanged, m_WasShown, m_StateLoaded, 
  *		m_TreeExpanded
  *****************************************************
  * input parameter:
  * - none
  *
  * output parameter:
  * - none
  *****************************************************
  * Created:        24.08.98  TWI
  * Last modified:  28.09.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 01.10.98
  *****************************************************
*/

void CStdCtrlDlg::InitDlgState()
{
	// Dialogstatus
	SetModifiedFlag(FALSE);
	SetDataChangedFlag(FALSE);
	SetShownFlag(FALSE);
	SetStateLoadedFlag(FALSE);
	m_TreeExpanded = FALSE;
}

/*
  *****************************************************
  * Routine: InitTreeCtrlEnv
  *
  * Function:	Initialisiert den Default-TreeControl-
  *		Zustand in den Member-Variablen 
  *		m_WordWrapEnabled, m_HasLinesEnabled, 
  *		m_HasLinesEnabled
  *****************************************************
  * input parameter:
  * - none
  *
  * output parameter:
  * - (BOOL): TRUE, wenn erfolgreich ausgeführt
  *****************************************************
  * Created:        24.08.98  TWI
  * Last modified:  22.09.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

void CStdCtrlDlg::InitTreeCtrlEnv()
{
	// Status des TreeControls
	m_WordWrapEnabled = TRUE;
	m_HasLinesEnabled = TRUE;
	m_HasButtonsEnabled = TRUE;
	m_MultiSelectEnabled = TRUE;
}

/*
  *****************************************************
  * Routine: UpdateTreeCtrlState
  *
  * Function:	benachrichtigt die bei der letzten 
  *		Anzeige des Dialogs expandierten Baumelemente,
  *		sich zu expandieren
  *****************************************************
  * input parameter:
  * - (CComTreeItems): interne Liste der 
  *		CCOMTreeItem-Objekte
  *
  * output parameter:
  * - none
  *****************************************************
  * Created:        24.08.98  TWI
  * Last modified:  01.10.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 01.10.98
  *****************************************************
*/

void CStdCtrlDlg::UpdateTreeCtrlState(CComTreeItems ctiList)
{
	CComTreeItems::iterator	_Icti;
	CComTreeItems				_selItems;

// die im Moment selektierten Items deselektieren
// ..BAUSTELLE
	GetSelectedItems(m_CTIList, _selItems);
	if (_selItems.size() > 0)
	{
		for (_Icti = _selItems.begin(); _Icti != _selItems.end(); ++_Icti)
		{
//			m_SECTreeCtrl.SetItemState(((CCOMTreeItem)*_Icti).m_hItem, 0, );
		}
	}

	// TreeControl-Zustand aus der internen Liste wiederherstellen
	for (_Icti = ctiList.begin(); _Icti != ctiList.end(); ++_Icti)
	{
		// Items expandieren
		if ((*_Icti).second.m_expanded)
		{
			m_SECTreeCtrl.Expand((*_Icti).second.m_hItem, TVE_EXPAND, TRUE);
		}
		// Items selektieren
		if ((*_Icti).second.m_selected)
		{
			// SelectItem sendet für jede Selektion TVN_SELCHANGING und TVN_SELCHANGED;
			// Der Dialog würde darauf unnötigerweise mit der Anzeige der jeweils gemeinsamen
			// Eigenschaften in den Event-Handlern reagieren.
//			m_SECTreeCtrl.SelectItem(((CCOMTreeItem)*Icti).m_hItem);
			m_SECTreeCtrl.Select((*_Icti).second.m_hItem, TVGN_FIRSTVISIBLE);
		}
	}
}

/*
  *****************************************************
  * Routine: OnOK
  *
  * Function:  Event-Handler für BN_CLICKED:
  *		aktualisiert die Liste von CCOMTreeItems und
  *		speichert den Zustand des Dialogs
  *****************************************************
  * input parameter:
  * - none
  *
  * output parameter:
  * - none
  *****************************************************
  * Created:        15.07.98  TWI
  * Last modified:  29.09.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 01.10.98
  *****************************************************
*/

void CStdCtrlDlg::OnOK()
{
// TreeControl-Zustand in die lokalen Variablen schreiben
// expandierte und selektierte TreeItems ermitteln
	UpdateSelectedItems(m_CTIList);
	UpdateExpandedItems(m_CTIList);

// Liste umkehren, damit beim Einlesen die richtige Reihenfolge da ist
//	m_CTIList.reverse();

	Apply();
	m_pTarget -> Fire_OnOk();

	VERIFY(SUCCEEDED(FreeCurrentPages()));		// alle Seiten freigeben

	CDialog::OnOK();
}

void CStdCtrlDlg::OnCancel() 
{
	m_pTarget -> Fire_OnCancel();

	VERIFY(SUCCEEDED(FreeCurrentPages()));		// alle Seiten freigeben
	CDialog::OnCancel();
}

/*
  *****************************************************
  * Routine: GetBitmapOfCOMObject
  *
  * Function:  Umleitung auf GetBitmapOfCOMObject mit
  *		den Parametern im übergebenen CCOMTreeItem
  *****************************************************
  * input parameter:
  * - (CCOMTreeItem): Objekt, dessen Eigenschaften
  *		m_hInst und m_bitmapRID weitergereicht werden
  *
  * output parameter:
  * - (int): Index des ersten Bitmaps des eingetragenen
  *		Bitmap-Paares (Status Normal und Selektiert)
  *****************************************************
  * Created:        14.08.98  TWI
  * Last modified:  21.08.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

//int CStdCtrlDlg::GetBitmapOfCOMObject(CCOMTreeItem cti)
//{
//	if (0 != cti.m_bitmapRID)
//		return GetBitmapOfCOMObject(cti.m_hInst, cti.m_bitmapRID);
//	else
//		return GetBitmapOfCOMObject(cti.m_hBmp);
//}

/*
  *****************************************************
  * Routine: GetBitmapOfCOMObject
  *
  * Function:  ermittelt das Bitmap zu einem COM-Objekt
  *		über den ToolboxBitmap32-Eintrag in der
  *		Registry
  *****************************************************
  * input parameter:
  * - (CCOMTreeItem): Objekt, dessen Eigenschaft
  *		m_modulePath genutzt wird, um m_bitmapRID zu 
  *		setzen
  *
  * output parameter:
  * - (int): Index des ersten Bitmaps des eingetragenen
  *		Bitmap-Paares (Status Normal und Selektiert)
  *****************************************************
  * Created:        14.08.98  TWI
  * Last modified:  21.08.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

int CStdCtrlDlg::GetBitmapOfCOMObject(
	HINSTANCE hInst,					// in:	Handle auf das Modul
	long int bmpID)						// in:	ResourceID des Bitmaps
{
// Bitmap laden...
CBitmap		_bitmap;
HINSTANCE hInstOld = AfxGetResourceHandle();

	AfxSetResourceHandle(hInst);
	if (!_bitmap.LoadBitmap(bmpID))
	{
		AfxSetResourceHandle(hInstOld);
		return IMG_DEFAULTICON;
	}
// Resource-Handle der Applikation zurücksetzen
	AfxSetResourceHandle(hInstOld);

// ...und in die Bitmapliste einfügen
	return m_imageList.Add(&_bitmap, (COLORREF)0xFF00FF);
}

int CStdCtrlDlg::GetBitmapOfCOMObject(
	BOOL fIsIcon, HBITMAPICON hBmp)						// in:	(GDI-)Handle der Bitmap
{
// Bitmap binden...
	if (NULL == hBmp.hBmp)	// Standardbitmap laden
		return IMG_DEFAULTICON;

int iIndex = -1;

	if (fIsIcon) {
		iIndex = m_imageList.Add(hBmp.hIcon);
	} else {
	CBitmap	_bitmap;

		_bitmap.Attach (hBmp.hBmp);

	// ...und in die Bitmapliste einfügen
		iIndex = m_imageList.Add(&_bitmap, (COLORREF)0xFF00FF);
		_bitmap.Detach();
	}
	return iIndex;
}

/*
  *****************************************************
  * Routine: GetPropsOfTreeItemList
  *
  * Function:  ermittelt CLSIDs der
  *		Eigenschaftsseiten einer (beliebigen) Liste
  *		von CCOMTreeItems.
  *****************************************************
  * input parameter:
  * - (CComTreeItems): Liste der den COM-Objekten
  *		zugeordneten TreeItems
  *	- (list<CAUUID*>): Ptr auf Liste der Strukturen, 
  *		welche die PropertyPage-Objekte enthalten
  *
  * output parameter:
  * - (HRESULT): Ergebnis des Dialogs
  *****************************************************
  * Created:        02.07.98  TWI
  * Last modified:  01.10.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 01.10.98
  *****************************************************
*/

HRESULT CStdCtrlDlg::GetPropsOfTreeItemList(
	CComTreeItems objects,			// in:	Liste der CCOMTreeItem-Objekte
	list<CAUUID *> &pps)				// out:	Liste von Ptr auf die entsprechenden CAUUID-Strukturen
{
	HRESULT							_hr;
	CComTreeItems::iterator	_Icti;
	list<CAUUID *>::iterator		_Icauuid;
	CCOMTreeItem					_curItem;
	CAUUID							*_curPPs;
	ISpecifyPropertyPages			*_pISPP = NULL;

	// das Member m_pUnk des jeweiligen CCOMTreeItem's wird NICHT geprüft

	if (objects.size() == 0)
	{
		return E_FAIL;
	}

	for (_Icti = objects.begin(); _Icti != objects.end(); ++_Icti)
	{
		_curPPs = NULL;
		_hr = ::GetPropsOfCOMObject((*_Icti).second.m_Unk, _curPPs);
		if (_hr != S_OK)
		{
			// bisher aufgebaute Liste zerstören
			for (_Icauuid = pps.begin(); _Icauuid != pps.end(); ++_Icauuid)
			{
				::FreeCAUUID(*_Icauuid);
			}
			pps.clear();
			return _hr;
		}
		else
		{
			pps.push_front(_curPPs);
		}
	}

	return _hr;
}

/*
  *****************************************************
  * Routine: ShowEmptyPP
  *
  * Function:  instantiiert ein COM-Objekt, dessen
  *		Eigenschaftsdialog eine leere Eigenschaftsseite
  *		mit dem Hinweis auf nicht vorhandene 
  *		Eigenschaften anzeigt, und zeigt diesen Dialog
  *		an.
  *****************************************************
  * input parameter:
  * - none
  *
  * output parameter:
  * - (HRESULT): Ergebnis des Dialogs
  *****************************************************
  * Created:        07.07.98  TWI
  * Last modified:  01.10.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 01.10.98
  *****************************************************
*/

HRESULT CStdCtrlDlg::ShowEmptyPP(UINT uiMsg)
{
CString strMsg;

	VERIFY(strMsg.LoadString (uiMsg));
	return ShowEmptyPP (strMsg);
}

HRESULT CStdCtrlDlg::ShowEmptyPP(LPCTSTR pcMsg)
{
	HRESULT _hr = S_OK;
//	CComTreeItems				_emptyPPs;
//	CCOMTreeItem					_item;

	TRACE(_T("CStdCtrlDlg::ShowEmptyPP\n"));

	HandleEmptyPage(TRUE, pcMsg);

//	// für ShowObjectProps direkt ist zunächst nur m_pUnk notwendig
//	_hr = ::InstantiateCOMObject(CLSID_Dummy, _item.m_Unk);
//	if (_hr != S_OK)
//	{
//		return _hr;
//	}
//
//	_emptyPPs.push_front(_item);
//	AddRefPtrOfElement(_emptyPPs.front());
//
//	_hr = ShowObjectProps(_emptyPPs);
//	if (_hr != S_OK)
//	{
//		if (_hr == E_OUTOFMEMORY)
//		{
//			AfxMessageBox(_T("Anzeige der Eigenschaften nicht möglich.\nZuwenig Speicher verfügbar."));
//		}
//		else
//		{
//			AfxMessageBox(_T("Anzeige der Eigenschaften nicht möglich.\nUnbekannte Fehlerursache."));
//		}
//	}
//
//	ClearCTIList(_emptyPPs);

	return _hr;
}

/*
  *****************************************************
  * Routine: OnClickTree
  *
  * Function:Event-Handler für NM_CLICK im Tree-
  *		Control: setzt m_DlgIsModified auf TRUE, um
  *		den Dialogzustand als verändert zu 
  *		kennzeichnen
  *****************************************************
  * input parameter:
  * - (NMHDR *):
  *	- (LRESULT *):
  *
  * output parameter:
  * - none
  *****************************************************
  * Created:        15.07.98  TWI
  * Last modified:  23.07.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

void CStdCtrlDlg::OnClickTree(NMHDR* pNMHDR, LRESULT* pResult) 
{
	SetModifiedFlag(TRUE);
	*pResult = 0;
}

/*
  *****************************************************
  * Routine: OnItemexpandedTree
  *
  * Function:	Event-Handler für TVN_ITEMEXPANDED im
  *		TreeControl: setzt m_DlgIsModified auf TRUE, um
  *		den Dialogzustand als verändert zu 
  *		kennzeichnen
  *****************************************************
  * input parameter:
  * - (NMHDR *):
  *	- (LRESULT *):
  *
  * output parameter:
  * - none
  *****************************************************
  * Created:        15.07.98  TWI
  * Last modified:  23.07.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

void CStdCtrlDlg::OnItemexpandedTree(NMHDR* pNMHDR, LRESULT* pResult) 
{
NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
HTREEITEM hItem = pNMTreeView -> itemNew.hItem;

#if defined(_DUMP_NOTIFY)
CString strText;

	strText = m_SECTreeCtrl.GetItemText(hItem);
	TRACE1("ItemExpanded: %s\r\n", (LPCSTR)strText);
#endif // _DUMP_NOTIFY

	if (m_SECTreeCtrl.ItemHasChildren (hItem)) {
	// nur Parents behandeln
		if (m_SECTreeCtrl.GetItemState (hItem, TVIS_EXPANDED) & TVIS_EXPANDED) 
			m_SECTreeCtrl.SetItemImage (hItem, IMG_FOLDEREXPANDED, IMG_FOLDEREXPANDED);
		else
			m_SECTreeCtrl.SetItemImage (hItem, IMG_FOLDERCOLLAPSED, IMG_FOLDERCOLLAPSED);
	}

	SetModifiedFlag(TRUE);
	EndWaitCursor();

	*pResult = 0;
}

void CStdCtrlDlg::OnItemexpandingTree(NMHDR* pNMHDR, LRESULT* pResult) 
{
#if defined(_DUMP_NOTIFY)
NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
HTREEITEM hItem = pNMTreeView -> itemNew.hItem;
CString strText;

	strText = m_SECTreeCtrl.GetItemText(hItem);
	TRACE1("ItemExpanding: %s\r\n", (LPCSTR)strText);
#endif // _DUMP_NOTIFY

	BeginWaitCursor();	
	*pResult = 0;
}

/*
  *****************************************************
  * Routine: OnSelchangedTree
  *
  * Function:	Event-Handler für TVN_SELCHANGED im
  *		TreeControl: setzt m_DlgIsModified auf TRUE, um
  *		den Dialogzustand als verändert zu 
  *		kennzeichnen, und zeigt die neuen 
  *		Eigenschaftsseiten an
  *****************************************************
  * input parameter:
  * - (NMHDR *):
  *	- (LRESULT *):
  *
  * output parameter:
  * - none
  *****************************************************
  * Created:        15.07.98  TWI
  * Last modified:  02.10.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 02.10.98
  *****************************************************
*/

void CStdCtrlDlg::OnSelchangedTree(NMHDR* pNMHDR, LRESULT* pResult) 
{
#if defined(_DUMP_NOTIFY)
	TRACE(_T("CStdCtrlDlg::OnSelchangedTree\n"));
#endif // _DUMP_NOTIFY

// nur etwas tun, wenn sich wirklich was verändert hat
NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;

	if (pNMTreeView -> itemOld.hItem == pNMTreeView -> itemNew.hItem) {
		*pResult = 0;
		return;
	}

bool fHideEmptyPP = false;

	VERIFY(SUCCEEDED(FreeCurrentPages(&fHideEmptyPP)));

// Status der Schalter setzen
	if (GetHasApply())
		m_ApplyBtn.EnableWindow(FALSE);
//	m_HelpBtn.EnableWindow(FALSE);

// die selektierten Items ermitteln...
CComTreeItems _selItems;

	GetSelectedItems(m_CTIList, _selItems);
	if (_selItems.size() == 0)
		ShowEmptyPP(IDS_NOSELECTEDITEM);
	else {
	// evtl. PP wieder einblenden
		if (fHideEmptyPP)
			HandleEmptyPage(FALSE);

	// ...und deren Eigenschaften anzeigen
	HRESULT _hr = ShowObjectProps(_selItems);

		if (FAILED(_hr)) {
		CString strError;

			strError.Format (IDS_ERROR_SHOWPROPERTIES, _hr);
			ShowEmptyPP(strError);
		}
		ClearCTIList(_selItems);
	}

	PostMessage(uiInitCoolButton, TRUE);

	SetModifiedFlag(TRUE);
	*pResult = 0;
}

void CStdCtrlDlg::InitCoolButton(BOOL fMenuBtn)
{
// Text des DefaultItems des Menus in CoolBtn übernehmen
#if _TRiAS_VER < 0x0400
	if (0 == g_dwVer4) 
		return;
#endif // _TRiAS_VER < 0x0400

	ASSERT(NULL == m_pPopup);
	ATLTRY(m_pPopup = new CPopUpMenu(this, IDR_TREE_POPUPMENU));
	if (NULL == m_pPopup) return;

	m_uiDefault = (UINT)-1;
	if (InitPopupMenu (m_pPopup, fMenuBtn)) 
		m_uiDefault = m_pPopup -> GetSubMenu() -> GetDefaultItem(0, FALSE);

#if _TRiAS_VER < 0x0400
	if (0 != g_dwVer4) 
#endif // _TRiAS_VER < 0x0400
	{
	CString strItem;

		if ((UINT)-1 != m_uiDefault) {
			m_pPopup -> GetSubMenu() -> GetMenuString(m_uiDefault, strItem, MF_BYCOMMAND);
			m_Actions.SetWindowText(strItem);
			m_Actions.EnableWindow (TRUE);
		} else {
			VERIFY(strItem.LoadString(IDS_ACTIONS));
			m_Actions.SetWindowText(strItem);
			m_Actions.EnableWindow (FALSE);
		}
	}
	delete m_pPopup;
	m_pPopup = NULL;
}

HRESULT CStdCtrlDlg::FreeCurrentPages(bool *pfHideEmptyPP)
{
// Die Selektion im Baum hat sich geändert -> alles bisherige verwerfen
// Änderungen auf den Seiten zurückschreiben
	for (list<WPropertyPage>::iterator _IIPP = m_IPPList.begin();
		 _IIPP != m_IPPList.end(); ++_IIPP)
	{
	WPropertyPage Page (*_IIPP);

		if (S_OK == Page -> IsPageDirty())
			VERIFY(SUCCEEDED(Page -> Apply()));
	}

// aktuelle Seite verstecken und deaktivieren
WPropertyPage IPP;
HRESULT _hr = GetCurIPPOfTab(IPP.ppi());

	if (_hr != S_OK) {
		if (NULL != pfHideEmptyPP)
			*pfHideEmptyPP = true;
	} else {
		RETURN_FAILED_HRESULT(IPP -> Show(FALSE));
		RETURN_FAILED_HRESULT(IPP -> Deactivate());

		for (list<WPropertyPage>::iterator IIPP = m_IPPList.begin();
			 IIPP != m_IPPList.end(); ++IIPP)
		{
		// Kontext wieder freigeben
		WPropertyPage Page (*IIPP);

			RETURN_FAILED_HRESULT(Page -> SetObjects(0, NULL)); 
//			RETURN_FAILED_HRESULT(Page -> SetPageSite(NULL));
		}

		VERIFY(m_PropSheet.DeleteAllItems());
		ClearIPPList(m_IPPList);
	}
	return S_OK;
}

void CStdCtrlDlg::OnGetdispinfoTree(NMHDR* pNMHDR, LRESULT* pResult) 
{
TV_DISPINFO* pTVDispInfo = (TV_DISPINFO*)pNMHDR;
#if defined(_DEBUG)
CString strText;

	strText = m_SECTreeCtrl.GetItemText(pTVDispInfo -> item.hItem);
#endif // _DEBUG

CCOMTreeItem item;
HTREEITEM hItem = pTVDispInfo -> item.hItem;

	if (!GetElementOfHandle (hItem, item))
		return;

	if (pTVDispInfo -> item.mask & TVIF_CHILDREN) {
#if defined(_DUMP_NOTIFY)
		TRACE1("GetDispInfo(TVIF_CHILDREN): %s\r\n", (LPCSTR)strText);
#endif // _DUMP_NOTIFY
		;
	} else if (pTVDispInfo -> item.mask & (TVIF_IMAGE|TVIF_SELECTEDIMAGE)) {
#if defined(_DUMP_NOTIFY)
		if (pTVDispInfo -> item.mask & TVIF_IMAGE)
			TRACE1("GetDispInfo(TVIF_IMAGE): %s\r\n", (LPCSTR)strText);
		else if (pTVDispInfo -> item.mask & TVIF_SELECTEDIMAGE)
			TRACE1("GetDispInfo(TVIF_SELECTEDIMAGE): %s\r\n", (LPCSTR)strText);
		else
			ASSERT(FALSE);
#endif // _DUMP_NOTIFY

	BOOL fDoesNotChangeFurther = FALSE;

		if (m_SECTreeCtrl.GetItemState (hItem, TVIS_EXPANDED) & TVIS_EXPANDED) {
			if (-1 == item.m_imageIndexExp && NULL != m_pTarget) {		// noch kein Bild vorhanden
			WDispatch Disp;
			WPicture Pict;

				if (FAILED(m_pTarget -> Fire_OnGetDispInfoExpandedImage (item.m_id, Disp.ppi())))
					return;
				ATLTRY(Pict = Disp);

			OLE_HANDLE hIconBmp = NULL;
			short rgType = PICTYPE_NONE;

				if (FAILED(Pict -> get_Handle (&hIconBmp))) return;
				if (FAILED(Pict -> get_Type (&rgType))) return;
				item.m_imageIndexExp = GetBitmapOfCOMObject((PICTYPE_ICON == rgType) ? TRUE : FALSE, *(HBITMAPICON *)&hIconBmp);

			// neuen Wert zurückschreiben
				UpdateListElement(m_CTIList, item);
			} 

		// gewünschte Information liefern
			if (pTVDispInfo -> item.mask & TVIF_IMAGE)
				pTVDispInfo -> item.iImage = item.m_imageIndexExp;
			if (pTVDispInfo -> item.mask & TVIF_SELECTEDIMAGE)
				pTVDispInfo -> item.iSelectedImage = item.m_imageIndexExp;
		} else {
			if (-1 == item.m_imageIndex && NULL != m_pTarget) {		// noch kein Bild vorhanden
			WDispatch Disp;
			WPicture Pict;

				if (FAILED(m_pTarget -> Fire_OnGetDispInfoImage (item.m_id, Disp.ppi())))
					return;
				ATLTRY(Pict = Disp);

			OLE_HANDLE hIconBmp = NULL;
			short rgType = PICTYPE_NONE;

				if (FAILED(Pict -> get_Handle (&hIconBmp))) return;
				if (FAILED(Pict -> get_Type (&rgType))) return;
				item.m_imageIndex = GetBitmapOfCOMObject((PICTYPE_ICON == rgType) ? TRUE : FALSE, *(HBITMAPICON *)&hIconBmp);

			// neuen Wert zurückschreiben
				UpdateListElement(m_CTIList, item);
			} 

		// gewünschte Information liefern
			if (pTVDispInfo -> item.mask & TVIF_IMAGE)
				pTVDispInfo -> item.iImage = item.m_imageIndex;
			if (pTVDispInfo -> item.mask & TVIF_SELECTEDIMAGE)
				pTVDispInfo -> item.iSelectedImage = item.m_imageIndex;
		}
		if (fDoesNotChangeFurther)
			pTVDispInfo -> item.mask |= LVIF_DI_SETITEM;

	} else if (pTVDispInfo -> item.mask & TVIF_TEXT) {
#if defined(_DUMP_NOTIFY)
		TRACE1("GetDispInfo(TVIF_TEXT): %s\r\n", (LPCSTR)strText);
#endif // _DUMP_NOTIFY
		;
	}
	*pResult = 0;
}

/*
  *****************************************************
  * Routine: ToggleStyle
  *
  * Function:	negiert das übergebene Attribut des
  *		TreeControls
  *****************************************************
  * input parameter:
  * - (DWORD): Attribut des Tree-Controls
  *
  * output parameter:
  * - none
  *****************************************************
  * Created:        23.07.98  TWI
  * Last modified:  23.07.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

void CStdCtrlDlg::ToggleStyle(DWORD lStyleMask, BOOL fSetFlag)
{
// aktuellen Style des TreeControls ermitteln
DWORD	_dwStyle, _dwExStyle;

	m_SECTreeCtrl.GetTreeCtrlStyles(_dwStyle, _dwExStyle);

// übergebenen Style als zu entfernendes bzw. hinzuzufügendes Attribut verwenden
	if ((_dwStyle & lStyleMask) && !fSetFlag)
		m_SECTreeCtrl.ModifyTreeCtrlStyles (lStyleMask, 0, 0, 0);
	else if (!(_dwStyle & lStyleMask) && fSetFlag)
		m_SECTreeCtrl.ModifyTreeCtrlStyles (0, lStyleMask, 0, 0);
}

/*
  *****************************************************
  * Routine: InsertItem
  *
  * Function:	fügt ein Objekt der Klasse CCOMTreeItem
  *		in die Liste m_CTIList ein
  *****************************************************
  * input parameter:
  * - (CLSID): CLSID des COM-Objektes
  * - (LPSTR): Bezeichnung des COM-Objektes für das 
  *		TreeControl
  *	- (unsigned long): ID des Parent-COM-Objektes
  *
  * output parameter:
  * - (unsigned long): ID des eingefügten Objektes
  *****************************************************
  * Created:        24.07.98  TWI
  * Last modified:  14.08.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

unsigned long CStdCtrlDlg::InsertItem(
		REFCLSID clsid,					// in:	CLSID des COM-Objektes
		LPCSTR name,					// in:	Bezeichnung des COM-Objektes für das TreeControl
		unsigned long parent)			// in:	ID des Parent-COM-Objektes
{
// Daten der Struktur vervollständigen
WUnknown Unk;

	if (S_OK == ::InstantiateCOMObject(clsid, Unk.ppu())) {
	CString objectPath = ::AssemblyHLMRegPath(clsid);				// Pfad des Objektes

	// ResourceID des Bitmaps
	CString modulePath (::GetToolboxBitmap32Value(objectPath));
	UINT bitmapRID = ::ExtractBitmapID(modulePath);					// modifiziert modulePath
	HINSTANCE hInst = ::GetHandleOfModule(modulePath);

		ASSERT(NULL != hInst);
		if (0 == bitmapRID)
			return InsertItem(Unk, name, FALSE, NULL, NULL, parent);

	CCOMTreeItem item;

		item.m_Unk = Unk;
		item.m_name = _T(name);
		item.m_parentId = parent;
		item.m_imageIndex = item.m_imageIndexExp = GetBitmapOfCOMObject (hInst, bitmapRID);
		return InsertItem(item);
	}		
	return -1;
}

unsigned long CStdCtrlDlg::InsertItem(
		IUnknown * pUnk,				// in:	Ptr auf IUnknown-Interface des COM-Objektes
		LPCSTR name,					// in:	Bezeichnung des COM-Objektes für das TreeControl
		BOOL fHasIcons,					// folgende HANDLE's sind HICON's 
		HANDLE hBmpCollapsed,			// in:	(GDI-)Handle der Bitmap collapsed
		HANDLE hBmpExpanded,			// in:	(GDI-)Handle der Bitmap expanded
		unsigned long parent)			// in:	ID des Parent-COM-Objektes
{
// übergebene Daten in die eigene Struktur übernehmen; 
CCOMTreeItem _treeItem;

	_treeItem.m_Unk = pUnk;

	_treeItem.m_name = _T(name);
	_treeItem.m_fIsIcon = fHasIcons;
	if (fHasIcons) {
		_treeItem.m_hBmpColl.hIcon = (HICON)hBmpCollapsed;
		_treeItem.m_hBmpExp.hIcon = hBmpExpanded ? (HICON)hBmpExpanded : (HICON)hBmpCollapsed;
	} else {
		_treeItem.m_hBmpColl.hBmp = (HBITMAP)hBmpCollapsed;
		_treeItem.m_hBmpExp.hBmp = hBmpExpanded ? (HBITMAP)hBmpExpanded : (HBITMAP)hBmpCollapsed;
	}
	_treeItem.m_parentId = parent;
	return InsertItem(_treeItem);
}

unsigned long CStdCtrlDlg::InsertFolderItem(
		LPCSTR name,					// in:	Bezeichnung des COM-Objektes für das TreeControl
		unsigned long parent)			// in:	ID des Parent-COM-Objektes
{
// übergebene Daten in die eigene Struktur übernehmen; 
CCOMTreeItem _treeItem;

	_treeItem.m_name = _T(name);
	_treeItem.m_parentId = parent;
	_treeItem.m_imageIndex = IMG_FOLDERCOLLAPSED;
	_treeItem.m_imageIndexExp = IMG_FOLDEREXPANDED;
	return InsertItem(_treeItem);
}

/*
  *****************************************************
  * Routine:	InsertItem
  *
  * Function:	fügt ein Objekt der Klasse CCOMTreeItem
  *		in die Liste m_CTIList ein; kann nur intern 
  *		aufgerufen werden
  *****************************************************
  * input parameter:
  * - (CCOMTreeItem): einzufügendes CCOMTreeItem-Objekt
  *
  * output parameter:
  * - (unsigned long): ID des eingefügten Objektes
  *****************************************************
  * Created:        24.07.98  TWI
  * Last modified:  14.08.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

unsigned long CStdCtrlDlg::InsertItem(CCOMTreeItem &item)
{
// Daten vervollständigen
// Index des zugehörigen Bitmaps
	if (-1 == item.m_imageIndex && NULL != item.m_hBmpColl.hBmp) {
		item.m_imageIndex = GetBitmapOfCOMObject(item.m_fIsIcon, item.m_hBmpColl);
		item.m_hBmpColl.hBmp = NULL;
	}
	if (-1 == item.m_imageIndexExp && NULL != item.m_hBmpExp.hBmp) {
		item.m_imageIndexExp = GetBitmapOfCOMObject(item.m_fIsIcon, item.m_hBmpExp);
		item.m_hBmpExp.hBmp = NULL;
	}

// Daten der Struktur vervollständigen
HTREEITEM hParent = NULL;

	if (!IsRootObject(item.m_parentId)) {	
	// Parent ist nicht Root -> dessen Ptr auf dessen IUnknown in m_pParentUnk übernehmen
	// Element kopieren
	CCOMTreeItem _item;

		if (GetListElement(m_CTIList, item.m_parentId, _item)) {
			item.m_ParentUnk = _item.m_Unk;
			_item.m_HasChildren = TRUE;
			hParent = _item.m_hItem;		// ParentHandle zwischenspeichern

		// geändertes Parent-Objekt in der Liste aktualisieren
			UpdateListElement(m_CTIList, _item);
		} else 
			return -1;
	}

// Struktur in die unsortierte Liste einfügen
	item.m_id = m_CTIList.size() + 1;
	m_CTIList.insert(CComTreeItems::value_type(item.m_id, item));

// evtl. Item in Baum einhängen
	if (IsWindow(m_SECTreeCtrl.GetSafeHwnd())) {
		InsertTreeObject(hParent, item);
		UpdateListElement(m_CTIList, item);
	}

	SetDataChangedFlag(TRUE);
	return item.m_id;
}

/*
  *****************************************************
  * Routine:	InsertItem
  *
  * Function:	fügt ein Objekt der Klasse CCOMTreeItem
  *		in die Liste m_CTIList ein
  *****************************************************
  * input parameter:
  * - (CLSID): CLSID des COM-Objektes
  * - (IUnknown *):Ptr auf IUnknown-Interface des 
  *		COM-Objektes
  *	- (LPSTR): Bezeichnung des COM-Objektes für das 
  *		TreeControl
  *	- (unsigned long): ID des Parent-COM-Objektes
  *
  * output parameter:
  * - (unsigned long): ID des eingefügten Objektes
  *****************************************************
  * Created:        24.07.98  TWI
  * Last modified:  14.08.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

//unsigned long CStdCtrlDlg::InsertItem(
//		REFCLSID clsid,					// in:	ClassID des Objektes
//		IUnknown * pUnk,				// in:	Ptr auf IUnknown-Interface des COM-Objektes
//		LPCSTR name,					// in:	Bezeichnung des COM-Objektes für das TreeControl
//		unsigned long parent)			// in:	ID des Parent-COM-Objektes
//{
//HINSTANCE		hInst;
//CString			objectPath, modulePath;
//long int		bitmapRID;
//
//// Pfad des Objektes
//	objectPath = ::AssemblyHLMRegPath(clsid);
//
//// Pfad des Modules
//	modulePath = ::GetInprocServer32Value(objectPath);
//
//// ResourceID des Bitmaps
//	bitmapRID = ::ExtractBitmapID(::GetToolboxBitmap32Value(objectPath));
//
//// Handle des Moduls
//	hInst = ::GetHandleOfModule(modulePath);
//	ASSERT(NULL != hInst);
//
//	return InsertItem(clsid, pUnk, name, objectPath, modulePath, hInst, bitmapRID, parent);
//}
//
/*
  *****************************************************
  * Routine:	InsertItem
  *
  * Function:	fügt ein Objekt der Klasse CCOMTreeItem
  *		in die Liste m_CTIList ein
  *****************************************************
  * input parameter:
  * - (CLSID): CLSID des COM-Objektes
  * - (IUnknown *):Ptr auf IUnknown-Interface des 
  *		COM-Objektes
  *	- (LPSTR): Bezeichnung des COM-Objektes für das 
  *		TreeControl
  *	- (HINSTANCE): Handle auf das Modul
  *	- (long int): ResourceID des Bitmaps
  *	- (unsigned long): ID des Parent-COM-Objektes
  *
  * output parameter:
  * - (unsigned long): ID des eingefügten Objektes
  *****************************************************
  * Created:        24.07.98  TWI
  * Last modified:  14.08.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

//unsigned long CStdCtrlDlg::InsertItem(
//		REFCLSID clsid,					// in:	CLSID des COM-Objektes
//		IUnknown * pUnk,				// in:	Ptr auf IUnknown-Interface des COM-Objektes
//		LPCSTR name,					// in:	Bezeichnung des COM-Objektes für das TreeControl
//		HINSTANCE hInst,				// in:	Handle auf das Modul
//		long int rID,					// in:	ResourceID des Bitmaps im Modul hInst
//		unsigned long parent)			// in:	ID des Parent-COM-Objektes
//{
//CString	objectPath, modulePath;
//
//// Pfad des Objektes
//	objectPath = ::AssemblyHLMRegPath(clsid);
//
//// Pfad des Modules
//	modulePath = ::GetInprocServer32Value(objectPath);
//	return InsertItem(clsid, pUnk, name, objectPath, modulePath, hInst, rID, parent);
//}
//
/*
  *****************************************************
  * Routine:	InsertItem
  *
  * Function:	fügt ein Objekt der Klasse CCOMTreeItem
  *		in die Liste m_CTIList ein; kann nur intern 
  *		aufgerufen werden
  *****************************************************
  * input parameter:
  * - (CLSID): CLSID des COM-Objektes
  * - (IUnknown *):Ptr auf IUnknown-Interface des 
  *		COM-Objektes
  *	- (LPSTR): Bezeichnung des COM-Objektes für das 
  *		TreeControl
  *	- (CString): Pfad des Moduls
  *	- (CString): Pfad des Moduls, welches das Bitmap
  *		enthält
  *	- (HINSTANCE): Handle auf das Modul
  *	- (long int): ResourceID des Bitmaps
  *	- (unsigned long): ID des Parent-COM-Objektes
  *
  * output parameter:
  * - (unsigned long): ID des eingefügten Objektes
  *****************************************************
  * Created:        24.07.98  TWI
  * Last modified:  14.08.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

//unsigned long CStdCtrlDlg::InsertItem(
//		REFCLSID clsid,					// in:	CLSID des COM-Objektes
//		IUnknown * pUnk,				// in:	Ptr auf IUnknown-Interface des COM-Objektes
//		LPCSTR name,					// in:	Bezeichnung des COM-Objektes für das TreeControl
//		CString objPath,				// in:	Pfad, unter dem das Modul (*.DLL/*.OCX) zu finden ist
//		CString modPath,				// in:	Pfad, unter dem das Modul (*.DLL/*.OCX) zu finden ist,welches das
//										//		zugehörige Bitmap enthält
//		HINSTANCE hInst,				// in:	Handle auf das Modul
//		long int rID,					// in:	ResourceID des Bitmaps im Modul hInst
//		unsigned long parent)			// in:	ID des Parent-COM-Objektes
//{
//// übergebene Daten in die eigene Struktur übernehmen; m_objectPath und m_modulePath werden
//// mit den Pfaden auf *.DLL/*.OCX belegt, die in der Registry unter der entsprechenden
//// ClassID gefunden werden.
//// Wurde explizit ein Handle auf ein Modul sowie eine BitmapID übergeben, wird NICHT getestet,
//// ob dies ein Handle der Module der gespeicherten Pfade ist!
//CCOMTreeItem _treeItem;
//
//	_treeItem.m_clsid = clsid;
//	_treeItem.m_Unk = pUnk;
//
//	_treeItem.m_name = _T(name);
//	_treeItem.m_hInst = hInst;
//	_treeItem.m_bitmapRID = rID;
//	_treeItem.m_parentId = parent;
//
//	return InsertItem(_treeItem);
//}

/*
  *****************************************************
  * Routine:	InsertItem
  *
  * Function:	fügt ein Objekt der Klasse CCOMTreeItem
  *		in die Liste m_CTIList ein
  *****************************************************
  * input parameter:
  * - (CTIPERSISTSTRUCT): Struktur mit den persistent
  *		gemachten Eigenschaften des CCOMTreeItem-
  *		Objektes
  *
  * output parameter:
  * - (unsigned long): ID des eingefügten Objektes
  *****************************************************
  * Created:        24.07.98  TWI
  * Last modified:  28.09.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 01.10.98
  *****************************************************
*/

//unsigned long CStdCtrlDlg::InsertItem(CTIPERSISTSTRUCT ctiPS)
//{
//	unsigned long		_retVal;
//	unsigned long		_index;
//
//	_index = InsertItem(ctiPS.clsid, ctiPS.name, ctiPS.parentId);
//	if (_index != 0)
//	{
//		// Attribute expanded und selected setzen
//		CCOMTreeItem		_item;
//		if (GetListElement(m_CTIList, _index, _item))
//		{
//			_item.m_expanded = ctiPS.expanded;
//			_item.m_selected = ctiPS.selected;
//			UpdateListElement(m_CTIList, _item);
//
//			ReleasePtrOfElement(_item);
//			_retVal = _index;
//		}
//		else 
//		{
//			_retVal = 0;
//		}
//	}
//	else
//	{
//		_retVal = 0;
//	}
//
//	return _retVal;
//}

/*
  *****************************************************
  * Routine:	GetChildObjects
  *
  * Function:	ermittelt die COM-Objekte in der Liste
  *		m_CTIList, welche keinem anderen COM-Objekt als
  *		Child zugeordnet sind.
  *		Diese Funktion wird nur zur Ermittlung der 
  *		Child-Objekte der _Root-Objekte_ genutzt.
  *****************************************************
  * input parameter:
  * - (CComTreeItems): Liste aller zu 
  *		durchsuchenden Objekte
  *
  * output parameter:
  * - (CComTreeItems): Liste der Parent-Objekte
  *****************************************************
  * Created:        28.07.98  TWI
  * Last modified:  01.10.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 01.10.98
  *****************************************************
*/

void CStdCtrlDlg::GetChildObjects(
		CComTreeItems &objList,	// in:	Liste aller zu durchsuchenden Objekte
		CComTreeItems &childList)	// out: Liste der Parent-Objekte
{
// wenn in der übergebenen Liste noch Elemente enthalten sind, diese löschen
	ClearCTIList(childList);
	for (CComTreeItems::iterator _Iobj = objList.begin(); _Iobj != objList.end(); ++_Iobj) {
		if (IsRootObject((*_Iobj).second))
			childList.insert(CComTreeItems::value_type((*_Iobj).second.m_id, (*_Iobj).second));	// Element wird kopiert
	}
}

/*
  *****************************************************
  * Routine:	GetChildObjects
  *
  * Function:	ermittelt die COM-Objekte in der Liste
  *		m_CTIList, welche einem anderen COM-Objekt als
  *		Child zugeordnet sind.
  *		Diese Funktion wird nur zur Ermittlung der 
  *		Child-Objekte eines bereits vorhandenen 
  *		Objektes genutzt.
  *****************************************************
  * input parameter:
  *	- (CCOMTreeItem): Parent-Objekt
  * - (CComTreeItems): Liste aller zu 
  *		durchsuchenden Objekte
  *
  * output parameter:
  * - (CComTreeItems): Liste der Parent-Objekte
  *****************************************************
  * Created:        28.07.98  TWI
  * Last modified:  01.10.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 01.10.98
  *****************************************************
*/

void CStdCtrlDlg::GetChildObjects(
		CCOMTreeItem &item,				// in:	Parent-Objekt
		CComTreeItems &objList,	// in:	Liste aller zu durchsuchenden Objekte
		CComTreeItems &childList)	// out: Liste der Child-Objekte
{
// wenn in der übergebenen Liste noch Elemente enthalten sind, diese löschen
	ClearCTIList(childList);
	for (CComTreeItems::iterator _Iobj = objList.begin(); _Iobj != objList.end(); ++_Iobj) {
		if ((*_Iobj).second.m_parentId == item.m_id)
			childList.insert (CComTreeItems::value_type((*_Iobj).second.m_id, (*_Iobj).second));		// Element wird kopiert
	}
}

/*
  *****************************************************
  * Routine:	InsertTreeObject
  *
  * Function:	fügt ein CCOMTreeItem-Objekt in das
  *		übergebene TreeControl ein, setzt dessen 
  *		Attribut m_hItem und übergibt ihm
  *		das Handle auf das Parent-Item
  *****************************************************
  * input parameter:
  * - (SECTreeCtrl *): TreeControl, in das die Objekte 
  *		eingefügt werden
  *	- (HTREEITEM): Handle auf das Parent-Item im
  *		TreeCtrl
  *
  * output parameter:
  *	- (CCOMTreeItem): einzufügendes Objekt
  *****************************************************
  * Created:        28.07.98  TWI
  * Last modified:  22.09.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

void CStdCtrlDlg::InsertTreeObject(
		HTREEITEM h,					// in:	Handle auf das Parent-Item im TreeCtrl
		CCOMTreeItem &curItem)			// out:	einzufügendes Objekt
{
// fülle TV_INSERTSTRUCT-Struktur
TV_INSERTSTRUCT	_tvis;

	memset (&_tvis, '\0', sizeof(TV_INSERTSTRUCT));
	_tvis.hParent = (NULL != h) ? h : TVI_ROOT;
	_tvis.hInsertAfter = (NULL != h) ? TVI_LAST : TVI_FIRST;

	if (curItem.m_selected)
	{
		_tvis.item.state = TVIS_SELECTED;
		_tvis.item.mask = TVIF_STATE;
	}
	_tvis.item.pszText = (LPSTR)(LPCSTR)curItem.m_name;	// LPSTR_TEXTCALLBACK 
	_tvis.item.iImage = I_IMAGECALLBACK;			// curItem.m_imageIndex;
	_tvis.item.iSelectedImage = I_IMAGECALLBACK;	// curItem.m_imageIndex;
	_tvis.item.mask |= TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
	
// füge Struktur in tree ein und merke Handle darauf
	curItem.m_hItem = m_SECTreeCtrl.InsertItem(&_tvis);
}

/*
  *****************************************************
  * Routine:	InsertTreeObject
  *
  * Function:	fügt ein CCOMTreeItem-Objekt in die 
  *		Root des übergebenen TreeControls ein, setzt 
  *		dessen Attribut m_hItem
  *****************************************************
  * input parameter:
  * - (SECTreeCtrl *): TreeControl, in das die Objekte 
  *		eingefügt werden
  *
  * output parameter:
  *	- (CCOMTreeItem): einzufügendes Objekt
  *****************************************************
  * Created:        24.08.98  TWI
  * Last modified:  30.07.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

//void CStdCtrlDlg::InsertTreeObject(
//		CCOMTreeItem &curItem)			// out:	einzufügendes Objekt
//{
//	TV_ITEM				_tvi;
//	TV_INSERTSTRUCT		_tvis;
//
//	memset(&_tvi, 0, sizeof(_tvi));
//
//	// fülle TV_ITEM-Struktur
//	if (curItem.m_selected)
//	{
//		_tvi.state = TVIS_SELECTED;
//		_tvi.mask = TVIF_STATE;
//	}
//	_tvi.pszText = (LPSTR)(LPCSTR)curItem.m_name;
//	_tvi.iImage = curItem.m_imageIndex;
//	_tvi.iSelectedImage = curItem.m_imageIndex;
//	_tvi.mask = _tvi.mask | TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
//
//	// fülle TV_INSERTSTRUCT-Struktur
//	memmove(&(_tvis.item), &_tvi, sizeof(TV_ITEM));
//	_tvis.hParent = NULL;
//	_tvis.hInsertAfter = TVI_FIRST;
//
//	// füge Struktur in tree ein und merke Handle darauf
//	curItem.m_hItem = m_SECTreeCtrl.InsertItem(&_tvis);
//}

/*
  *****************************************************
  * Routine: FillTreeCtrl
  *
  * Function:	füllt das übergebene TreeControl mit
  *		den Daten in m_CTIList
  *****************************************************
  * input parameter:
  * - (SECTreeCtrl *): TreeControl, in das die Objekte 
  *		eingefügt werden
  *
  * output parameter:
  * - (BOOL): TRUE, wenn erfolgreich ausgeführt
  *****************************************************
  * Created:        28.07.98  TWI
  * Last modified:  30.07.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

BOOL CStdCtrlDlg::FillTreeCtrl()
{
// TreeControl passivieren und alles rauslöschen
	m_SECTreeCtrl.SendMessage (WM_SETREDRAW, FALSE);
	m_SECTreeCtrl.DeleteAllItems();

// Liste der Objekte _einer_ Ebene in der Baumhierarchie
CComTreeItems _childItemsList;
BOOL fResult = FALSE;

// Alle Children der Root finden
	GetChildObjects(m_CTIList, _childItemsList);

// wenn es welche gibt,...
	if (_childItemsList.size() > 0)	{
	// ...jedes der Childs weiterverfolgen
		RecurseChildren(_childItemsList);
	
	// Release()'s für alle enthaltenen Ptr
		ClearCTIList(_childItemsList);
		fResult = TRUE;
	} 

// TreeControl passivieren
	m_SECTreeCtrl.SendMessage (WM_SETREDRAW, TRUE);
	if (fResult) {
		m_SECTreeCtrl.InvalidateRect(NULL);
		m_SECTreeCtrl.UpdateWindow();
	}
	return fResult;
}

/*
  *****************************************************
  * Routine:	RecurseChildren
  *
  * Function:	fügt die Objekte der nächsten Ebene in
  *		das übergebene TreeControl ein
  *****************************************************
  * input parameter:
  * - (SECTreeCtrl *): TreeControl, in das die Objekte 
  *		eingefügt werden
  *
  * output parameter:
  * - (CComTreeItems): Liste der Children dieser
  *		Ebene
  *****************************************************
  * Created:        28.07.98  TWI
  * Last modified:  12.08.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

void CStdCtrlDlg::RecurseChildren(
		CComTreeItems &itemsList)	// out: Liste der Child-Objekte einer Ebene
{
// Liste der Objekte _einer_ Ebene in der Baumhierarchie
CComTreeItems	_curParentItemsList, _childList;
HTREEITEM			_h;
BOOL				_moreChildren;

	if (itemsList.size() > 0) {
	// übergebene Parent-Liste temp-ern (da sie in den GetChildObjects-Aufrufen ständig neu 
	// belegt würde), damit alle Objekte _dieser_ Ebene durchlaufen werden
		_curParentItemsList = itemsList;

		_moreChildren = FALSE;
		for (CComTreeItems::iterator _Icti = _curParentItemsList.begin(); 
			 _Icti != _curParentItemsList.end(); _Icti++)
		{
		// aktuellen Parent in das TreeControl einfügen
			_h = GetHandleOfElement((*_Icti).second.m_parentId);

			InsertTreeObject(_h, (*_Icti).second);
			UpdateListElement(m_CTIList, (*_Icti).second);

			if ((*_Icti).second.m_HasChildren) {
			// Liste der Children des aktuellen Parent in itemsList speichern
				_moreChildren = TRUE;
				GetChildObjects((*_Icti).second, m_CTIList, itemsList);
			
			// Liste aller Children aller Parents dieser Ebene ergänzen
				for (CComTreeItems::iterator _Icti1 = itemsList.begin(); 
					 _Icti1 != itemsList.end(); _Icti1++)
				{
					// Element wird kopiert
					_childList.insert(CComTreeItems::value_type((*_Icti1).second.m_id, (*_Icti1).second));
				}
			}
		}
		if (_moreChildren)
		{
			RecurseChildren(_childList);
			ClearCTIList(_childList);
		}
	}
}

/*
  *****************************************************
  * Routine:	ShowObjectProps
  *
  * Function:	ermittelt die Eigenschaften der 
  *		selektierten Objekte und reicht diese an
  *		UpdateTabCtrl weiter.
  *		Diese Methode wird nur aufgerufen, wenn mind.
  *		ein Element in der übergebenen Liste enthalten
  *		ist.
  *****************************************************
  * input parameter:
  * - (CComTreeItems): Liste der Objekte, deren
  *		Eigenschaften angezeigt werden sollen
  *
  * output parameter:
  * - none
  *****************************************************
  * Created:        02.08.98  TWI
  * Last modified:  01.10.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 01.10.98
  *****************************************************
*/

HRESULT CStdCtrlDlg::ShowObjectProps(
	CComTreeItems selItems)		// in: Liste der selektierten Objekte
{
	HRESULT							_hr = S_OK;
	CComTreeItems::iterator	_Icti;
	CAUUID							*_pCommonPPs = NULL;
	list<CAUUID *>					_objectProps;
	list<CAUUID *>::iterator		_Icauuid;
	BOOL							_objWithNoPP;
	IUnknown						**_pUnks = NULL;

	TRACE(_T("CStdCtrlDlg::ShowObjectProps\n"));

	if (selItems.size() == 1) {
	// Eigenschaften des ersten und einzigen CCOMTreeItem's in der Liste ermitteln
		RETURN_FAILED_HRESULT(_hr = ::GetPropsOfCOMObject((*selItems.begin()).second.m_Unk, _pCommonPPs));

		if (_pCommonPPs->cElems == 0)
			ShowEmptyPP(IDS_NOPROPERTIES);
		else {
			_pUnks = (IUnknown **) CoTaskMemAlloc(sizeof(IUnknown *));
			memset (_pUnks, '\0', sizeof(IUnknown *));
		
		// für Parameterübergabe IUnknown-Ptr in Array kopieren
			_pUnks[0] = (*selItems.begin()).second.m_Unk;
			_pUnks[0]->AddRef();

		// TabControl aktualisieren
			_hr = UpdateTabCtrl(1, _pUnks, _pCommonPPs);
			if (_hr != S_OK)
			{
				::ClearUnkArray(1, _pUnks);
				::FreeCAUUID(_pCommonPPs);
				return _hr;
			}
		
		// IUnknown's im Array aufräumen
			::ClearUnkArray(1, _pUnks);
		}
	
	// Struktur der PP-CLSIDs aufräumen
		::FreeCAUUID(_pCommonPPs);
	} else {
	// Eigenschaften der CCOMTreeItem's in der Liste ermitteln
		_hr = GetPropsOfTreeItemList(selItems, _objectProps);
		if (_objectProps.size() == 0)
			return E_FAIL;

		_hr = ::ObjectWithNoPPExists(_objectProps, _objWithNoPP);
		if (_hr != S_OK)
		{
			// Liste der PP-Objekt-CLSIDs aufräumen...
			ClearCAUUIDList(_objectProps);
			return _hr;
		}

		if (_objWithNoPP)
			ShowEmptyPP(IDS_NOPROPERTIES);
		else {
		// Struktur zur Aufnahme der gemeinsamen PPs bereitstellen
			_hr = ::GetCommonProps(_objectProps, _pCommonPPs);
			if (_hr != S_OK) {
			// Liste der PP-Objekt-CLSIDs aufräumen...
				ClearCAUUIDList(_objectProps);
				return _hr;
			}

			if (_pCommonPPs->cElems == 0)
				ShowEmptyPP(IDS_NOCOMMON_PROPERTIES);
			else {
				_pUnks = (IUnknown **) CoTaskMemAlloc(sizeof(IUnknown *) * selItems.size());
				memset (_pUnks, '\0', sizeof(IUnknown *) * selItems.size());
			
			// IUnknown's der selektierten COM-Objekte ins Array kopieren
				_Icti = selItems.begin();
				for (unsigned int j = 0; j < selItems.size(); j++)
				{
					_pUnks[j] = (*_Icti).second.m_Unk;
					_pUnks[j]->AddRef();
					++_Icti;
				}

			// TabControl aktualisieren
				_hr = UpdateTabCtrl(selItems.size(), _pUnks, _pCommonPPs);

			// IUnknown's im Array aufräumen
				::ClearUnkArray(selItems.size(), _pUnks);
			}
		// Struktur der gemeinsamen PP-CLSIDs aufräumen
			::FreeCAUUID(_pCommonPPs);
		}
	// Liste der PP-Objekt-CLSIDs aufräumen
		ClearCAUUIDList(_objectProps);
	}
	return _hr;
}

/*
  *****************************************************
  * Routine:	ClearCAUUIDList
  *
  * Function:	löscht eine Liste (STL: list) von Ptr
  *		auf CAUUID-Strukturen; Release()'ed
  *****************************************************
  * input parameter:
  * - (list<CAUUID *>): Liste der zu löschenden
  *		CAUUID-Ptr
  *
  * output parameter:
  * - none
  *****************************************************
  * Created:        30.07.98  TWI
  * Last modified:  25.08.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 01.10.98
  *****************************************************
*/

void CStdCtrlDlg::ClearCAUUIDList(list<CAUUID *> &guidList)
{
	list<CAUUID *>::iterator		_Icauuid;

	if (guidList.size() == 0)
		return;

	for (_Icauuid = guidList.begin(); _Icauuid != guidList.end(); ++_Icauuid)
		::FreeCAUUID(*_Icauuid);

	guidList.clear();
}

/*
  *****************************************************
  * Routine:	IsListElement
  *
  * Function:	stellt fest, ob die übergebene CLSID
  *		einem Element der Liste zugeordnet werden kann
  *****************************************************
  * input parameter:
  * - (CComTreeItems): Liste aller zu 
  *		durchsuchenden Objekte
  *	- (unsigned long): ID, die gesucht wird
  *
  * output parameter:
  * - (BOOL): TRUE, wenn in der Liste ein
  *		Objekt mit der übergebenen ID existiert,
  *		sonst FALSE
  *****************************************************
  * Created:        30.07.98  TWI
  * Last modified:  01.10.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 01.10.98
  *****************************************************
*/

BOOL CStdCtrlDlg::IsListElement(
		unsigned long id)				// in:	ID, die gesucht wird
{
CComTreeItems::iterator	Icti = m_CTIList.find (id);

	return (Icti != m_CTIList.end()) ? TRUE : FALSE;
}

/*
  *****************************************************
  * Routine:	GetListElement
  *
  * Function:	ermittelt ein Element der Liste
  *****************************************************
  * input parameter:
  * - (CComTreeItems): Liste aller zu 
  *		durchsuchenden Objekte
  *	- (unsigned long): ID, die gesucht wird
  *
  * output parameter:
  * - (CCOMTreeItem): Objekt der Liste
  *****************************************************
  * Created:        30.07.98  TWI
  * Last modified:  01.10.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 01.10.98
  *****************************************************
*/

BOOL CStdCtrlDlg::GetListElement(
		CComTreeItems &objList,			// in:	Liste aller zu durchsuchenden Objekte
		unsigned long id,				// in:	ID zur Identifizierung des Objektes
		CCOMTreeItem &item)				// out:	ermitteltes CCOMTreeItem
{
CComTreeItems::iterator	Icti = m_CTIList.find (id);

	if (Icti != m_CTIList.end()) {
		item = (*Icti).second;
		return TRUE;
	}
	return FALSE;
}

/*
  *****************************************************
  * Routine:	GetListElement
  *
  * Function:	ermittelt ein Element der Liste
  *****************************************************
  * input parameter:
  * - (CComTreeItems): Liste aller zu 
  *		durchsuchenden Objekte
  *	- (HTREEITEM): HTREEITEM, das gesucht wird
  *	- (unsigned long): ID, die gesucht wird
  *
  * output parameter:
  * - (CCOMTreeItem): Objekt der Liste
  *****************************************************
  * Created:        30.07.98  TWI
  * Last modified:  01.10.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 01.10.98
  *****************************************************
*/

BOOL CStdCtrlDlg::GetListElement(
		CComTreeItems &objList,			// in:	Liste aller zu durchsuchenden Objekte
		HTREEITEM hti,					// in:	HTREEITEM, das gesucht wird
		CCOMTreeItem &item)				// out:	ermitteltes CCOMTreeItem
{
	for (CComTreeItems::iterator Icti = objList.begin(); Icti != objList.end(); Icti++)
	{
		if ((*Icti).second.m_hItem == hti)
		{
			item = (*Icti).second;
			return TRUE;
		}
	}
	return FALSE;
}

/*
  *****************************************************
  * Routine:	GetHandleOfElement
  *
  * Function:	ermittelt das Attribut m_hItem eines
  *		CCOMTreeItem-Objektes aus der Liste
  *****************************************************
  * input parameter:
  * - (CComTreeItems): Liste aller zu 
  *		durchsuchenden Objekte
  *	- (unsigned long): ID, die gesucht wird
  *
  * output parameter:
  * - (HTREEITEM): Wert des Attributes m_hItem, wenn
  *		Objekt gefunden, sonst NULL
  *****************************************************
  * Created:        30.07.98  TWI
  * Last modified:  10.08.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

HTREEITEM CStdCtrlDlg::GetHandleOfElement(
		unsigned long id)				// in:	ID zur Identifizierung des Objektes
{
CCOMTreeItem _item;

	if (GetListElement(m_CTIList, id, _item))
		return _item.m_hItem;

	return NULL;
}

BOOL CStdCtrlDlg::GetElementOfHandle(
		HTREEITEM hItem,				// in:	ID zur Identifizierung des Objektes
		CCOMTreeItem &rItem)
{
CComTreeItems::iterator Icti;

	for (Icti = m_CTIList.begin(); Icti != m_CTIList.end(); Icti++)
	{
		if ((*Icti).second.m_hItem == hItem)
		{
			rItem = (*Icti).second;
			return TRUE;
		}
	}
	return FALSE;
}

/*
  *****************************************************
  * Routine:	UpdateListElement
  *
  * Function:	aktualisiert ein Objekt der Liste
  *****************************************************
  * input parameter:
  *	- (CCOMTreeItem): zu aktualisierendes Item

  * output parameter:
  * - (CComTreeItems): Liste aller zu 
  *		durchsuchenden Objekte
  *****************************************************
  * Created:        30.07.98  TWI
  * Last modified:  14.08.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

BOOL CStdCtrlDlg::UpdateListElement(
		CComTreeItems &objList,	// out:	Liste der Objekte
		CCOMTreeItem &item)				// in:	zu aktualisierendes Item
{
CComTreeItems::iterator Icti = objList.find(item.m_id);

	if (Icti != objList.end()) {
		(*Icti).second = item;
		return TRUE;
	}
	return FALSE;
}

/*
  *****************************************************
  * Routine:	IsRootObject
  *
  * Function:	ermittelt, ob die übergebene ID der 
  *		eines Root-Objektes entspricht
  *****************************************************
  * input parameter:
  *	- (unsigned long): ID, die auf 0 geprüft wird
  *
  * - (BOOL): TRUE, wenn kein Parent zugeordnet, sonst
  *		FALSE
  *****************************************************
  * Created:        28.07.98  TWI
  * Last modified:  02.09.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

BOOL CStdCtrlDlg::IsRootObject(unsigned long id)
{
	return id == 0 ? TRUE : FALSE;
}

/*
  *****************************************************
  * Routine:	IsRootObject
  *
  * Function:	ermittelt, ob das übergebene 
  *		CCOMTreeItem-Objekt einen Parent hat
  *****************************************************
  * input parameter:
  * - (CCOMTreeItem): Objekt der Liste
  *
  * output parameter:
  * - (BOOL): TRUE, wenn kein Parent zugeordnet, sonst
  *		FALSE
  *****************************************************
  * Created:        28.07.98  TWI
  * Last modified:  02.09.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

BOOL CStdCtrlDlg::IsRootObject(CCOMTreeItem &item)
{
	return IsRootObject(item.m_parentId);
}

/*
  *****************************************************
  * Routine:	IsRootObject
  *
  * Function:	ermittelt, ob das CCOMTreeItem-Objekt 
  *		mit der übergebenen ID einen Parent hat
  *****************************************************
  * input parameter:
  * - (CComTreeItems): Liste aller zu 
  *		durchsuchenden Objekte
  *	- (unsigned long): ID, die gesucht wird
  *
  * - (BOOL): TRUE, wenn kein Parent zugeordnet, sonst
  *		FALSE
  *****************************************************
  * Created:        28.07.98  TWI
  * Last modified:  02.09.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

BOOL CStdCtrlDlg::IsRootObject(
		CComTreeItems &l,			// in:	Liste aller zu durchsuchenden Objekte
		unsigned long id)				// in:	Objekt-ID, die gesucht wird
{
	CCOMTreeItem	_curItem;

	// Objekt mit id suchen
	if (GetListElement(l, id, _curItem))
		return IsRootObject(_curItem);

	return FALSE;
}

/*
  *****************************************************
  * Routine:	GetSelectedItems
  *
  * Function:	ermittelt die selektierten Objekte im 
  *		übergebenen SECTreeCtrl
  *****************************************************
  * input parameter:
  * - (SECTreeCtrl *): Ptr auf das TreeControl
  *	- (CComTreeItems): Liste der CCOMTreeItems
  *	- (CComTreeItems): Liste der selektierten 
  *		Objekte
  *
  * - none
  *****************************************************
  * Created:        28.07.98  TWI
  * Last modified:  02.09.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

void CStdCtrlDlg::GetSelectedItems(
	CComTreeItems &ctiList,		// in:	Liste der CCOMTreeItem-Objekte
	CComTreeItems &objList)		// out:	Liste der selektierten Objekte
{
	CCOMTreeItem	_item;

	// erstes selektiertes Element ermitteln
	HTREEITEM	_hti = m_SECTreeCtrl.GetFirstSelectedItem();

	// Liste aller selektierten Items erstellen
	while (_hti != NULL)
	{
		// zugehöriges Listenelement ermitteln
		GetListElement(ctiList, _hti, _item);
		objList.insert(CComTreeItems::value_type(_item.m_id, _item));
		_hti = m_SECTreeCtrl.GetNextSelectedItem(_hti);
	}
}

/*
  *****************************************************
  * Routine:	UpdateSelectedItems
  *
  * Function:	ermittelt die im SECTreeCtrl aktuell
  *		selektierten Einträge und aktualisiert die 
  *		Stati der entsprechenden Listenelemente
  *****************************************************
  * input parameter:
  * - (SECTreeCtrl *): Ptr auf das betroffene 
  *		SECTreeCtrl
  *	- (CComTreeItems): Liste der zu 
  *		aktualisierenden CCOMTreeItems
  * output parameter:
  * - none
  *****************************************************
  * Created:        10.09.98  TWI
  * Last modified:  10.09.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

void CStdCtrlDlg::UpdateSelectedItems(
	CComTreeItems &objList)
{
HTREEITEM						_hti;
CCOMTreeItem					_item;

// Attribut m_selected bei allen Listenelementen zurücksetzen
	for (CComTreeItems::iterator _Icti = objList.begin(); _Icti != objList.end(); ++_Icti)
	{
		(*_Icti).second.m_selected = FALSE;
	}

// selektierte Elemente ermitteln
	if (0 < m_SECTreeCtrl.GetItemCount()) {
		_hti = m_SECTreeCtrl.GetFirstSelectedItem();
		while (_hti != NULL)
		{
			// zugehöriges Listenelement ermitteln
			GetListElement(objList, _hti, _item);
			_item.m_selected = TRUE;
			UpdateListElement(objList, _item);

			_hti = m_SECTreeCtrl.GetNextSelectedItem(_hti);
		}
	}
}

/*
  *****************************************************
  * Routine:	UpdateExpandedItems
  *
  * Function:	ermittelt die im SECTreeCtrl aktuell
  *		expandierten Einträge und aktualisiert die 
  *		Stati der entsprechenden Listenelemente
  *****************************************************
  * input parameter:
  * - (SECTreeCtrl *): Ptr auf das betroffene 
  *		SECTreeCtrl
  *	- (CComTreeItems): Liste der zu 
  *		aktualisierenden CCOMTreeItems
  * output parameter:
  * - none
  *****************************************************
  * Created:        10.09.98  TWI
  * Last modified:  10.09.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

void CStdCtrlDlg::UpdateExpandedItems(
	CComTreeItems &objList)
{
	CComTreeItems::iterator	_Icti;
	HTREEITEM						_hti;
	CCOMTreeItem					_item;

// Attribut m_expanded bei allen Listenelementen zurücksetzen
	for (_Icti = objList.begin(); _Icti != objList.end(); ++_Icti)
	{
		(*_Icti).second.m_selected = FALSE;
	}

// expandierte Elemente ermitteln und Attribut m_expanded bei den entsprechenden Listenelementen setzen
	if (0 < m_SECTreeCtrl.GetItemCount()) {
		_hti = m_SECTreeCtrl.GetFirstVisibleItem();
		while (_hti != NULL)
		{
			if (m_SECTreeCtrl.IsExpanded(_hti))
			{
				// zugehöriges Listenelement ermitteln
				GetListElement(objList, _hti, _item);
				_item.m_expanded = TRUE;
				UpdateListElement(objList, _item);
			}
			_hti = m_SECTreeCtrl.GetNextVisibleItem(_hti);
		}
	}
}

/*
  *****************************************************
  * Routine:	UpdateTabCtrl
  *
  * Function:  Aktualisierung der Anzeige der 
  *		PropertyPages im TabCtrl
  *****************************************************
  * input parameter:
  *	- (unsigned long): Anzahl der betroffenen Objekte
  *	- (IUnknown **): Ptr auf Array der IUnknown's der 
  *		COM-Objekte
  *- (CAUUID *): Ptr auf CAUUID-Struktur der 
  *		gemeinsamen Eigenschaften der COM-Objekte
  * output parameter:
  *	- (HRESULT): Ergebnis der Funktion
  *****************************************************
  * Created:        18.09.98  TWI
  * Last modified:  02.10.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 02.10.98
  *****************************************************
*/

HRESULT CStdCtrlDlg::UpdateTabCtrl(
	unsigned long cObjects,				// in:	Anzahl der betroffenen Objekte
	IUnknown ** ppUnk,					// in:	Ptr auf Array der IUnknown's der COM-Objekte
	CAUUID * pPages)					// in:	Ptr auf CAUUID-Struktur der gemeinsamen Eigenschaften der COM-Objekte
{
HRESULT	_hr = E_FAIL;

	if (cObjects == 0)
		return E_FAIL;

	if (ppUnk == NULL)
		return E_POINTER;

	if (pPages == NULL)
		return E_POINTER;

// Aufräumen:
// (1) Liste von IPropertyPage-Ptr löschen
	ClearIPPList(m_IPPList);

// (2) eingehängte PropertyPages löschen
	VERIFY(m_PropSheet.DeleteAllItems());

	// Initialisieren

// (1) Schalterzustände
	if (GetHasApply())
		m_ApplyBtn.EnableWindow(FALSE);
//	m_HelpBtn.EnableWindow(FALSE);

	// (2) alle Seiten
	_hr = InitPages(m_IPropPageSite, pPages, cObjects, ppUnk, m_IPPList, m_curMaxPageSize);
	if (_hr != S_OK)
	{
		ClearIPPList(m_IPPList);
		VERIFY(m_PropSheet.DeleteAllItems());
		return _hr;
	}

	///////////////////////////////////
	// TODO:
	///////////////////////////////////

	// Dialogfenstergröße anpassen
	// ...

	// Größe und Position des TabCtrls und der Schalter anpassen
	// ...

	// Anzeigen der ersten Seite
CRect _tabRect;
CRect _rect;

	m_PropSheet.GetClientRect(&_tabRect);
	CalcPageRect(_tabRect, m_curMaxPageSize, _rect);

	_hr = (m_IPPList.front())->Activate(m_PropSheet.m_hWnd, &_rect, TRUE);
	if (_hr != S_OK)
	{
		ClearIPPList(m_IPPList);
		VERIFY(m_PropSheet.DeleteAllItems());
		return _hr;
	}

	HandleEmptyPage(FALSE);
	_hr = (m_IPPList.front())->Show(SW_SHOW);
	if (_hr != S_OK)
	{
		ClearIPPList(m_IPPList);
		VERIFY(m_PropSheet.DeleteAllItems());
		return _hr;
	}

// Zustand des Hilfeschalters aktualisieren
	UpdatePropHelpBtn();

// TreeCtrl fokussieren
	m_SECTreeCtrl.SetFocus();

	return _hr;
}

/*
  *****************************************************
  * Routine:	CalcPageRect
  *
  * Function:  berechnet Lage und Größe der Property-
  *		Pages
  *****************************************************
  * input parameter:
  *	- (CRect): Rectangle des TabControls
  *	- (SIZE): maximale Größe der einzuhängenden 
  *		PropertyPages
  *	- (CRect): Rectangle der Seite
  *
  * output parameter:
  *	- none
  *****************************************************
  * Created:        01.10.98  TWI
  * Last modified:  01.10.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 02.10.98
  *****************************************************
*/

void CStdCtrlDlg::CalcPageRect(
	CRect &tabRect,						// in:	Rectangle des TabControls
	CSize &maxSize,						// in:	maximale Größe der einzuhängenden PropertyPages
	CRect &rect)						// out:	Rectangle der Seite
{
long iFrameX = ::GetSystemMetrics(SM_CXFIXEDFRAME);
long iFrameY = ::GetSystemMetrics(SM_CYFIXEDFRAME);
long	_iDeltaX = 2 * iFrameX;
long	_iDeltaY = 2 * iFrameY + ::GetSystemMetrics(SM_CYCAPTION);

	rect.left = _iDeltaX;
	rect.top = _iDeltaY;
	rect.right = min(maxSize.cx+_iDeltaX, long(tabRect.Width() - iFrameX));
	rect.bottom = min(maxSize.cx+_iDeltaY, long(tabRect.Height() - iFrameY));
}

/*
  *****************************************************
  * Routine:	InitPages
  *
  * Function:  initialisiert alle übergebenen Property-
  *		Pages durch Aufrufe der entsprechenden Inter-
  *		face-Methoden
  *****************************************************
  * input parameter:
  *	- (IPropertyPageSite *): Ptr auf IPropertyPageSite-
  *		Interface des Rahmens
  * - (CAUUID *): Ptr auf Array der CLSIDs der 
  *		darzustellenden PropertyPages
  * - (unsigned long): Anzahl der COM-Objekte
  * - (IUnknown **): Ptr auf Array der IUnknown's der 
  *		COM-Objekte
  * - (list<WPropertyPage>): Liste der IPropertyPage-
  *		Interface-Ptr der PropertyPage-Objekte
  *	- (SIZE): Maße der größten Property Page in pPages
  *
  * output parameter:
  *	- (HRESULT): Ergebnis der Funktion
  *****************************************************
  * Created:        29.09.98  TWI
  * Last modified:  01.10.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 02.10.98
  *****************************************************
*/

HRESULT CStdCtrlDlg::InitPages(
	IPropertyPageSite * pIPPS,			// in:	Ptr auf IPropertyPageSite-Interface des Rahmens
	CAUUID * pPages,					// in:	Ptr auf Array der CLSIDs der darzustellenden PropertyPages
	unsigned long cObjects,				// in:	Anzahl der COM-Objekte
	IUnknown ** ppUnk,					// in:	Ptr auf Array der IUnknown's der COM-Objekte
	list<WPropertyPage> &ippList,		// out:	Liste der IPropertyPage-Interface-Ptr der PropertyPage-Objekte
	SIZE &maxSize)						// out:	Maße der größten Property Page in pPages
{
HRESULT _hr = S_OK;
CString _tempStr;

	maxSize.cx = 0;
	maxSize.cy = 0;

	if (pIPPS == NULL)
		return E_POINTER;

	if (pPages == NULL)
		return E_POINTER;

	if (cObjects == 0)
		return E_FAIL;

	if (ppUnk == NULL)
		return E_POINTER;

	if (ippList.size() > 0)
	{
		ClearIPPList(ippList);
	}

	for (unsigned int i = 0; i < pPages->cElems; i++) {
	WPropertyPage IPP;
	WUnknown Unk;

	// PropertyPage-Objekt instantiieren
		RETURN_FAILED_HRESULT(::InstantiateCOMObject(pPages->pElems[i], Unk.ppu()));

	// #HK020315: ggf. ContextHandle durchreichen
		if (NULL != m_ContextHandle) {
		WUIContextHandle Ctx;

			if (SUCCEEDED(Unk -> QueryInterface(Ctx.ppi()))) {
				RETURN_FAILED_HRESULT(Ctx -> put_ContextHandle(m_ContextHandle));
			}
		}

	// IPropertyPage-Ptr holen
		RETURN_FAILED_HRESULT(::GetIPP(Unk, IPP.ppi()));

	// allen PropertyPages des Objektes den gemeinsamen Rahmen und das COM-Objekt zuweisen
		RETURN_FAILED_HRESULT(IPP->SetPageSite(pIPPS));
		RETURN_FAILED_HRESULT(IPP->SetObjects(cObjects, ppUnk)); 

	// PROPPAGEINFO-Struktur füllen
	CPropPageInfo _PPI;

		RETURN_FAILED_HRESULT(IPP->GetPageInfo(&_PPI));

	// maximale Seitengröße aktualisieren
		maxSize.cx = max(maxSize.cx, _PPI.size.cx);
		maxSize.cy = max(maxSize.cy, _PPI.size.cy);

	// TC_ITEM füllen
	TC_ITEM	_tabItem;

		memset(&_tabItem, '\0', sizeof(TC_ITEM));
		_tabItem.mask = TCIF_TEXT;
		
		_tempStr = _PPI.pszTitle;
		_tabItem.pszText = (LPSTR)(LPCSTR)_tempStr;
		_tabItem.cchTextMax = _tempStr.GetLength();

	// TC_ITEM einfügen
		if (m_PropSheet.InsertItem(i, &_tabItem) == -1)
			return E_FAIL;

	// IPropertyPage-Ptr der PropertyPage halten
		ippList.push_back(IPP);
	}
	return _hr;
}

/*
  *****************************************************
  * Routine:	ClearIPPList
  *
  * Function:  löscht die übergebene Liste (STL: list)
  *		von IPropertyPage-Ptr; Release()'ed
  *****************************************************
  * input parameter:
  * - (list<WPropertyPage>): Liste der Ptr

  * output parameter:
  *	- none
  *****************************************************
  * Created:        29.09.98  TWI
  * Last modified:  01.10.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 02.10.98
  *****************************************************
*/

void CStdCtrlDlg::ClearIPPList(list<WPropertyPage> &ippList)
{
	ippList.clear();
}

/*
  *****************************************************
  * Routine:	ClearCTIList
  *
  * Function:  löscht die übergebene Liste (STL: list)
  *		von CCOMTreeItem's; Release()'ed
  *****************************************************
  * input parameter:
  * - (CComTreeItems): Liste der CCOMTreeItem's

  * output parameter:
  *	- none
  *****************************************************
  * Created:        29.09.98  TWI
  * Last modified:  01.10.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 02.10.98
  *****************************************************
*/

void CStdCtrlDlg::ClearCTIList(CComTreeItems &ctiList)
{
	if (0 != ctiList.size())
		ctiList.clear();	// Liste löschen
}

/*
  *****************************************************
  * Routine:	GetCurIPPOfTab
  *
  * Function:  ermittelt den IPropertyPage-Ptr der 
  *		aktuell angezeigten PropertyPage
  *****************************************************
  * input parameter:
  * - (IPropertyPage *): Ptr auf das Interface

  * output parameter:
  *	- (HRESULT): Ergebnis der Funktion
  *****************************************************
  * Created:        29.09.98  TWI
  * Last modified:  01.10.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 02.10.98
  *****************************************************
*/

HRESULT CStdCtrlDlg::GetCurIPPOfTab(
	IPropertyPage **ppIPP)				// out:	Ptr auf IPropertyPage-Interface der aktuellen PropertyPage
{
	if (m_IPPList.size() == 0)
		return E_FAIL;

	if (NULL == ppIPP)
		return E_POINTER;

int _curIndex = m_PropSheet.GetCurSel();
list<WPropertyPage>::iterator _IIPP = m_IPPList.begin();

	advance(_IIPP, _curIndex);

	if (_IIPP != m_IPPList.end()) {
	WPropertyPage Page (*_IIPP);

		*ppIPP = Page.detach();
		return S_OK;
	}
	return E_UNEXPECTED;
}

/*
  *****************************************************
  * Routine:	OnSelChangingTab
  *
  * Function:	Event-Handler für TCN_SELCHANGING:
  *		versteckt die aktuelle Seite und deaktiviert
  *		sie
  *****************************************************
  * input parameter:
  *	- (NMHDR*): 
  * - (LRESULT*): 
  *
  * output parameter:
  *	- none
  *****************************************************
  * Created:        18.09.98  TWI
  * Last modified:  18.09.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

void CStdCtrlDlg::OnSelChangingTab(NMHDR* pNMHDR, LRESULT* pResult)
{
// aktuelle Seite verstecken und deaktivieren
WPropertyPage IPP;
HRESULT _hr = GetCurIPPOfTab(IPP.ppi());

	if (_hr != S_OK) {
		*pResult = 0;
		return;
	}

	VERIFY(SUCCEEDED(IPP -> Show(FALSE)));
	VERIFY(SUCCEEDED(IPP -> Deactivate()));

	*pResult = 0;
}

/*
  *****************************************************
  * Routine:	OnSelChangeTab
  *
  * Function:	Event-Handler für TCN_SELCHANGE:
  *		aktiviert eine neue PropertyPage und zeigt sie
  *		im TabControl an;
  *		setzt den Status des 'Hilfe'-Schalters 
  *		(enabled/disabled) abhängig davon, ob die 
  *		selektierte TabPage über einen Eintrag für
  *		die Hilfedatei enthält;
  *****************************************************
  * input parameter:
  *	- (NMHDR*): 
  * - (LRESULT*): 
  * output parameter:
  *	- none
  *****************************************************
  * Created:        01.10.98  TWI
  * Last modified:  01.10.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 02.10.98
  *****************************************************
*/

void CStdCtrlDlg::OnSelChangeTab(NMHDR* pNMHDR, LRESULT* pResult) 
{
WPropertyPage IPP;
CRect _tabRect;
CRect _rect;

	m_PropSheet.GetClientRect(&_tabRect);
	CalcPageRect(_tabRect, m_curMaxPageSize, _rect);

	// aktuelle Seite aktivieren und anzeigen
	VERIFY(SUCCEEDED(GetCurIPPOfTab(IPP.ppi())));
	VERIFY(SUCCEEDED(IPP -> Activate(m_PropSheet.m_hWnd, &_rect, TRUE)));
	VERIFY(SUCCEEDED(IPP -> Show(SW_SHOW)));

// Zustand des Übernehmen-Schalters setzen
	UpdatePropApplyBtn();

// Zustand des Hilfe-Schalters setzen
	VERIFY(SUCCEEDED(UpdatePropHelpBtn()));

	*pResult = 0;
}

/*
  *****************************************************
  * Routine:	UpdatePropApplyBtn
  *
  * Function:	setzt den Status des 'Übernehmen'-
  *		Schalters in Abhängigkeit vom Status der 
  *		PropertyPage
  *****************************************************
  * input parameter:
  *	- none
  *
  * output parameter:
  *	- (HRESULT): Ergebnis der Funktion
  *****************************************************
  * Created:        01.10.98  TWI
  * Last modified:  01.10.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 02.10.98
  *****************************************************
*/

HRESULT CStdCtrlDlg::UpdatePropApplyBtn()
{
	if (GetHasApply()) {
	WPropertyPage IPP;

		if (SUCCEEDED(GetCurIPPOfTab(IPP.ppi())))
			m_ApplyBtn.EnableWindow(S_OK == IPP->IsPageDirty() ? TRUE : FALSE);
		else
			m_ApplyBtn.EnableWindow(FALSE);
	}
	return S_OK;
}

/*
  *****************************************************
  * Routine:	UpdatePropHelpBtn
  *
  * Function:	setzt den Status des 'Hilfe'-
  *		Schalters in Abhängigkeit von der Verfügbarkeit
  *		der Hilfe für die aktuelle Seite
  *****************************************************
  * input parameter:
  *	- none
  *
  * output parameter:
  *	- (HRESULT): Ergebnis der Funktion
  *****************************************************
  * Created:        01.10.98  TWI
  * Last modified:  01.10.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 02.10.98
  *****************************************************
*/

HRESULT CStdCtrlDlg::UpdatePropHelpBtn()
{
HRESULT				_hr;
WPropertyPage		IPP;
CString				_tempStr;

	RETURN_FAILED_HRESULT(GetCurIPPOfTab(IPP.ppi()));

CPropPageInfo _PPI;

	_hr = IPP->GetPageInfo(&_PPI);

// LPOLESTR nach CString konvertieren, um Länge feststellen zu können
//	_tempStr = _pPPI->pszHelpFile;

//	if (_tempStr.GetLength() > 0)
//	{
//		m_HelpBtn.EnableWindow(TRUE);
//	}
//	else
//	{
//		m_HelpBtn.EnableWindow(FALSE);
//	}
	return _hr;
}

/*
  *****************************************************
  * Routine:	OnApply
  *
  * Function:	Event-Handler für BN_CLICKED:
  *		ruft Apply für die aktuell ausgewählte TabPage
  *		auf
  *****************************************************
  * input parameter:
  *	- none
  * output parameter:
  *	- none
  *****************************************************
  * Created:        18.09.98  TWI
  * Last modified:  18.09.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

void CStdCtrlDlg::OnApply() 
{
	Apply();
	m_SECTreeCtrl.SetFocus();
}

/*
  *****************************************************
  * Routine:	Apply
  *
  * Function:	ruft Apply des IPropertyPage-Interfaces 
  *		der aktuell selektierten TabPage auf und 
  *		disabled danach den 'Übernehmen'-Schalter
  *****************************************************
  * input parameter:
  *	- none
  * output parameter:
  *	- none
  *****************************************************
  * Created:        18.09.98  TWI
  * Last modified:  18.09.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

HRESULT CStdCtrlDlg::Apply()
{
// Änderungen auf den Seiten zurückschreiben
	for (list<WPropertyPage>::iterator _IIPP = m_IPPList.begin();
		 _IIPP != m_IPPList.end(); ++_IIPP)
	{
	WPropertyPage Page (*_IIPP);

		if (S_OK == Page -> IsPageDirty())
			VERIFY(SUCCEEDED(Page -> Apply()));
	}

// derzeit bearbeitetes Item neu darstellen (evtl. Bildchen korrigieren)
HTREEITEM hItem = m_SECTreeCtrl.GetCaretItem();

	if (NULL != hItem) {
	CCOMTreeItem item;

		if (GetElementOfHandle (hItem, item) && item.m_Unk.IsValid())
			RefreshItem(item.m_id);
	}

// Apply-Knopf wieder grau
	if (GetHasApply()) 
		m_ApplyBtn.EnableWindow(FALSE);
	return S_OK;
}

/*
  *****************************************************
  * Routine:	OnPropPageHelp
  *
  * Function:	Event-Handler für BN_CLICKED:
  *		ruft PropPageHelp für das aktuell ausgewählte
  *		TabPage auf
  *****************************************************
  * input parameter:
  *	- none
  * output parameter:
  *	- none
  *****************************************************
  * Created:        18.09.98  TWI
  * Last modified:  18.09.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

//void CStdCtrlDlg::OnPropPageHelp() 
//{
//	PropPageHelp();
//}

/*
  *****************************************************
  * Routine:	PropPageHelp
  *
  * Function:	ruft Help des IPropertyPage-Interfaces 
  *		der aktuell selektierten TabPage auf
  *****************************************************
  * input parameter:
  *	- none
  * output parameter:
  *	- none
  *****************************************************
  * Created:        18.09.98  TWI
  * Last modified:  18.09.98  TWI   
  *****************************************************
  * Automated generated by D&P Documenter
  * DV: 1.0 *** FV: 1.0 *** Last documented: 22.09.98
  *****************************************************
*/

void CStdCtrlDlg::PropPageHelp() 
{
WPropertyPage	IPP;

	if (FAILED(GetCurIPPOfTab(IPP.ppi())))
		return;

CPropPageInfo _PPI;

	if (FAILED(IPP -> GetPageInfo(&_PPI)))
		return;
		
	IPP -> Help ((LPCOLESTR)_PPI.pszHelpFile);
}

void CStdCtrlDlg::SetStateLoadedFlag(BOOL state)
{
	m_StateLoaded = state;
}

BOOL CStdCtrlDlg::StateWasLoaded()
{
	return m_StateLoaded ? TRUE : FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// 
HRESULT CStdCtrlDlg::SelectItem (ULONG ulItem, BOOL fSelect)
{
	if (!IsWindow(GetSafeHwnd()))
		return E_UNEXPECTED;

HTREEITEM hItem = GetHandleOfElement (ulItem);

	if (NULL == hItem)
		return E_FAIL;

	return m_SECTreeCtrl.SelectItemRange (hItem, hItem, fSelect) ? S_OK : E_FAIL;
}

HRESULT CStdCtrlDlg::SetFirstVisible (ULONG ulItem)
{
	if (!IsWindow(GetSafeHwnd()))
		return E_UNEXPECTED;

HTREEITEM hItem = GetHandleOfElement (ulItem);

	if (NULL == hItem)
		return E_FAIL;

HTREEITEM hParent = m_SECTreeCtrl.GetParentItem(hItem);

	if (NULL != hParent)
		m_SECTreeCtrl.Expand(hParent, TVE_EXPAND); 
	return m_SECTreeCtrl.SelectSetFirstVisible (hItem);
}

HRESULT CStdCtrlDlg::get_ActItem (ULONG *pulActItem)
{
	if (!IsWindow(GetSafeHwnd()))
		return E_UNEXPECTED;
	if (NULL == pulActItem)
		return E_POINTER;
	*pulActItem = 0;

HTREEITEM hSelected = m_SECTreeCtrl.GetNextItem (TVI_ROOT, TVGN_FIRSTSELECTED);

	if (NULL != hSelected) {
	CCOMTreeItem item;

		if (GetElementOfHandle (hSelected, item))
			*pulActItem = item.m_id;
	}
	return S_OK;
}

HRESULT CStdCtrlDlg::GetChildItem (ULONG ulParent, ULONG *pulItem)
{
	if (!IsWindow(GetSafeHwnd()))
		return E_UNEXPECTED;
	
HTREEITEM hItem = GetHandleOfElement (ulParent);

	if (NULL == hItem)
		return E_FAIL;

HTREEITEM hChild = m_SECTreeCtrl.GetChildItem (hItem);

	if (NULL != hChild) {
	CCOMTreeItem item;

		if (GetElementOfHandle (hChild, item))
			*pulItem = item.m_id;
	}
	return S_OK; 
}

HRESULT CStdCtrlDlg::GetParentItem (ULONG ulChild, ULONG *pulItem)
{
	if (!IsWindow(GetSafeHwnd()))
		return E_UNEXPECTED;
	if (NULL == pulItem)
		return E_POINTER;
	*pulItem = 0;
		
HTREEITEM hItem = GetHandleOfElement (ulChild);

	if (NULL == hItem)
		return E_FAIL;

HTREEITEM hParent = m_SECTreeCtrl.GetParentItem (hItem);

	if (NULL != hParent) {
	CCOMTreeItem item;

		if (GetElementOfHandle (hParent, item))
			*pulItem = item.m_id;
	}
	return S_OK; 
}

HRESULT CStdCtrlDlg::GetNextItem (ULONG ulItem, DWORD dwMode, ULONG *pulNextItem)
{
	if (!IsWindow(GetSafeHwnd()))
		return E_UNEXPECTED;
		
HTREEITEM hItem = GetHandleOfElement (ulItem);

	if (NULL == hItem)
		return E_FAIL;

HTREEITEM hNext = m_SECTreeCtrl.GetNextItem (hItem, dwMode);

	*pulNextItem = 0;
	if (NULL != hNext) {
	CCOMTreeItem item;

		if (GetElementOfHandle (hNext, item))
			*pulNextItem = item.m_id;
	}
	return S_OK;
}

BOOL CStdCtrlDlg::GetItemName (ULONG ulItem, CString &rStr)
{
	if (!IsWindow(GetSafeHwnd()))
		return FALSE;

HTREEITEM hItem = GetHandleOfElement (ulItem);

	if (NULL == hItem)
		return FALSE;

	rStr = m_SECTreeCtrl.GetItemText (hItem);
	return rStr.GetLength() > 0 ? TRUE : FALSE;
}

HRESULT CStdCtrlDlg::GetItemObject (ULONG ulItem, IUnknown **ppIObj)
{
	if (!IsWindow(GetSafeHwnd()))
		return E_UNEXPECTED;

CCOMTreeItem _item;

	if (!GetListElement(m_CTIList, ulItem, _item))
		return E_FAIL;

WUnknown Unk (_item.m_Unk);

	*ppIObj = Unk.detach();
	return (NULL != *ppIObj) ? S_OK : S_FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// MenuButton wurde gedrückt
LRESULT CStdCtrlDlg::OnPreparePopupMenu(WPARAM wParam, LPARAM lParam)
{
CMenu *pMenu = (CMenu *)wParam;

	ASSERT(pMenu -> IsKindOf(RUNTIME_CLASS(CMenu)));

	ASSERT(NULL == m_pPopup);
	ATLTRY(m_pPopup = new CPopUpMenu(this, pMenu));
	if (NULL == m_pPopup) return FALSE;

	return InitPopupMenu (m_pPopup, TRUE);
}

// Menu ist wieder weg
LRESULT CStdCtrlDlg::OnDestroyPopupMenu (WPARAM wParam, LPARAM lParam)
{
LRESULT lResult = ExecuteCommand ((UINT)lParam);

	if (NULL != m_pPopup) {
		delete m_pPopup;
		m_pPopup = NULL;
	}

// Button neu setzen
	if (lResult)
		PostMessage(uiInitCoolButton, TRUE);
	return lResult;
}

LRESULT CStdCtrlDlg::OnInitCoolButton (WPARAM wParam, LPARAM lParam)
{
	InitCoolButton(0 != wParam ? TRUE : FALSE);
	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// auf rechten Mausklick reagieren
void CStdCtrlDlg::OnRclickTree(NMHDR* pNMHDR, LRESULT* pResult) 
{
// Rückgabewert wird ignoriert
	*pResult = 0;

// Popupmenu anzeigen
	ASSERT(NULL == m_pPopup);
	ATLTRY(m_pPopup = new CPopUpMenu(this, IDR_TREE_POPUPMENU));
	if (NULL == m_pPopup) return;

	if (!InitPopupMenu (m_pPopup))
		return;

// dummy-Punkt aus Resource entfernen, ggf. ersten Separator auch
	m_pPopup -> GetSubMenu() -> DeleteMenu(ID_DUMMY, MF_BYCOMMAND);
	if (MF_SEPARATOR & m_pPopup -> GetSubMenu() -> GetMenuState(0, MF_BYPOSITION))
		m_pPopup -> GetSubMenu() -> DeleteMenu(0, MF_BYPOSITION);

HTREEITEM hItem = MatchPositionToHTreeItem();
CCOMTreeItem item;

	if (!GetElementOfHandle (hItem, item))
		return;

UINT uiCmd = m_pPopup -> Track (TPM_LEFTALIGN|TPM_LEFTBUTTON|TPM_NONOTIFY|TPM_RETURNCMD);

	ExecuteCommand (uiCmd);

	if (m_pPopup) {
		delete m_pPopup;
		m_pPopup = NULL;
	}

// Button neu setzen
	PostMessage(uiInitCoolButton);
}

LRESULT CStdCtrlDlg::ExecuteCommand (UINT uiCmd) 
{
LRESULT lResult = FALSE;
HTREEITEM hItem = m_SECTreeCtrl.GetCaretItem();

	_ASSERTE(NULL != hItem);
	
	switch (uiCmd) {
	case IDM_COLLAPSE:
	case IDM_EXPAND:
		m_SECTreeCtrl.Expand (hItem, TVE_TOGGLE);
		lResult = TRUE;
		break;

	default:	// zusätzlich reingehängte Menupunkte bearbeiten
		{
		CCOMTreeItem item;

			if (!GetElementOfHandle (hItem, item)) 
				break;
			lResult = m_pTarget -> Fire_OnInvokeCommand (item.m_id, reinterpret_cast<INT_PTR>(GetSafeHwnd()), uiCmd);
		}
		break;

	case IDCANCEL:
	case 0:		// do nothing
		break;
	}

	return lResult;
}

BOOL CStdCtrlDlg::InitPopupMenu (CPopUpMenu *pPopup, BOOL fMenuBtn)
{
// rausfinden, welches Item aktiv ist
HTREEITEM hItem = MatchPositionToHTreeItem();
HTREEITEM hCurrItem = m_SECTreeCtrl.GetCaretItem();

	if (NULL == hItem) {
		if (fMenuBtn) {
			if (!m_MultiSelectEnabled && NULL == hCurrItem)		// single selection
				hCurrItem = m_SECTreeCtrl.GetFirstSelectedItem();
			hItem = hCurrItem;
		}
		if (NULL == hItem)
			return FALSE;			// kein Item getroffen
	}

// Item evtl. selektieren

	if (hCurrItem != hItem) {
		m_SECTreeCtrl.SelectItem(hItem);
		m_SECTreeCtrl.Select(hItem, TVGN_CARET);
	}

	if (m_SECTreeCtrl.ItemHasChildren(hItem)) {
		if (!(m_SECTreeCtrl.GetItemState (hItem, TVIS_EXPANDED) & TVIS_EXPANDED)) {
		CString strExpand;

			VERIFY(strExpand.LoadString(IDS_EXPAND));
			pPopup -> GetSubMenu() -> AppendMenu(MF_BYCOMMAND, IDM_EXPAND, strExpand);
			pPopup -> GetSubMenu() -> SetDefaultItem(IDM_EXPAND);
		} else {
		CString strCollapse;

			VERIFY(strCollapse.LoadString(IDS_COLLAPSE));
			pPopup -> GetSubMenu() -> AppendMenu(MF_BYCOMMAND, IDM_COLLAPSE, strCollapse);
			pPopup -> GetSubMenu() -> SetDefaultItem(IDM_COLLAPSE);
		}
	} 
//	else {
//	// Zusammenfassen/Expandieren rausnehmen
//		pPopup -> GetSubMenu() -> DeleteMenu (IDM_COLLAPSE, MF_BYCOMMAND);
//	}

// evtl. weitere Menupunkte einhängen
CCOMTreeItem item;

	if (GetElementOfHandle (hItem, item)) {
	UINT uiLast = IDM_POPUPFIRST;

		m_pTarget -> Fire_OnQueryContextMenu (item.m_id, 
			reinterpret_cast<INT_PTR>(pPopup -> GetSubMenu() -> GetSafeHmenu()), IDM_POPUPFIRST, IDM_POPUPLAST, &uiLast);
		pPopup -> SetMenuData (item.m_id);
		ASSERT(uiLast <= IDM_POPUPLAST);
	}

// Menu anzeigen, 'Abbrechen' anfügen (evtl. mit Separator)
	if (pPopup -> GetSubMenu() -> GetMenuItemCount() > 0) 
		pPopup -> GetSubMenu() -> InsertMenu ((UINT)-1, MF_BYPOSITION|MF_SEPARATOR);

CString strCancel;

	m_CancelBtn.GetWindowText (strCancel);
	pPopup -> GetSubMenu() -> InsertMenu ((UINT)-1, MF_BYPOSITION, IDCANCEL, strCancel);

	return TRUE;
}

HTREEITEM CStdCtrlDlg::MatchPositionToHTreeItem (UINT *puiFlags)
{
CPoint pt;

	::GetCursorPos (&pt);
	m_SECTreeCtrl.ScreenToClient (&pt);

	if (NULL == puiFlags) {
	UINT uiFlags = 0;

		return m_SECTreeCtrl.HitTest (pt, &uiFlags);
	}
	return m_SECTreeCtrl.HitTest (pt, puiFlags);
}

///////////////////////////////////////////////////////////////////////////////
// MenuHandler
void CStdCtrlDlg::OnMenuSelect(UINT nItemID, UINT nFlags, HMENU hSysMenu) 
{
	switch (nItemID) {
	case IDM_EXPAND:
	case IDM_COLLAPSE:
		((CFrameWnd *)AfxGetMainWnd()) -> SetMessageText (nItemID);
		break;

	case 0:		// do nothing
		break;

	default:
		{
		CComBSTR bstr;

			USES_CONVERSION;
			ASSERT(NULL != m_pPopup);
			ASSERT(nItemID >= IDM_POPUPFIRST && nItemID <= IDM_POPUPLAST);

			if (S_OK == m_pTarget -> Fire_OnGetCommandString (m_pPopup -> GetMenuData(), nItemID, 0, &bstr))
				((CFrameWnd *)AfxGetMainWnd()) -> SetMessageText (OLE2A(bstr));
		}
		break;
	}
}

HRESULT CStdCtrlDlg::RefreshItem(ULONG ulItem)
{
CCOMTreeItem _item;

	if (!GetListElement(m_CTIList, ulItem, _item))
		return E_FAIL;

// Bildchen zurücksetzen
	_item.m_imageIndex = _item.m_imageIndexExp = -1;

// geändertes Parent-Objekt in der Liste aktualisieren
	UpdateListElement(m_CTIList, _item);

	m_SECTreeCtrl.SetItemImage (_item.m_hItem, I_IMAGECALLBACK, I_IMAGECALLBACK);

//	m_SECTreeCtrl.InvalidateItem (_item.m_hItem);

	m_SECTreeCtrl.Invalidate();
	m_SECTreeCtrl.UpdateWindow();
	return S_OK;
}

HRESULT CStdCtrlDlg::RefreshAllItems()
{
	return E_NOTIMPL;
}

void CStdCtrlDlg::OnActions() 
{
	if ((UINT)-1 != m_uiDefault) {
		ExecuteCommand (m_uiDefault);

	// die Seite(n) neu erzeugen
	bool fHideEmptyPP = false;

		VERIFY(SUCCEEDED(FreeCurrentPages(&fHideEmptyPP)));

	// die selektierten Items ermitteln...
	CComTreeItems _selItems;

		GetSelectedItems(m_CTIList, _selItems);
		if (0 == _selItems.size())
			ShowEmptyPP(IDS_NOSELECTEDITEM);
		else {
		// evtl. PP wieder einblenden
			if (fHideEmptyPP)
				HandleEmptyPage(FALSE);

		// ...und deren Eigenschaften anzeigen
		HRESULT _hr = ShowObjectProps(_selItems);

			if (FAILED(_hr)) {
			CString strError;

				strError.Format (IDS_ERROR_SHOWPROPERTIES, _hr);
				ShowEmptyPP(strError);
			}
			ClearCTIList(_selItems);
		}

		PostMessage(uiInitCoolButton, TRUE);
	}
}
