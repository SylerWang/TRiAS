// $Header: $
// Copyright© 1999 TRiAS GmbH Potsdam, All rights reserved
// Created: 14.07.99 11:09:17 
//
// @doc
// @module TRiASDBInterfaces.idl | IDL source for TRiASDB base interfaces 
// @group In diesem Modul definierte Interfaces
// @index | INTERFACE & TRIASDB

#if !defined(_TRIASDBINTERFACES_IDL__C750A280_39CB_11D3_94FA_0080C786297B__INCLUDED_)
#define _TRIASDBINTERFACES_IDL__C750A280_39CB_11D3_94FA_0080C786297B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// Header include diagnostics
#if defined(_TRIAS_DBG_HEADER_DIAGNOSTICS)
#pragma message(__TIME__": include " __FILE__ )
#endif

#include "idl/VisInfoInterfaces.idl"	// VisInfo's etc.
#include "idl/StringHandling.idl"		// StringParsing/StringHandling
#include "idl/TRiASDBEvents.idl"

#include "TRiASDBDispIds.h"			// Feste DispatchID's

///////////////////////////////////////////////////////////////////////////////
// Sonstige hier benötigte Konstanten
#if !defined(VARIANT_TRUE)
#define VARIANT_TRUE	((VARIANT_BOOL)0xffff)
#define VARIANT_FALSE	((VARIANT_BOOL)0)
#endif // !VARIANT_TRUE

#if !defined(_DEFINED_HPROJECT)
#define _DEFINED_HPROJECT
	cpp_quote("#if !defined(_DEFINED_HPROJECT)")
	cpp_quote("#define _DEFINED_HPROJECT")
	cpp_quote("#define HACTPROJECT		((HPROJECT)(-1))		// aktuelles Projekt")
	cpp_quote("#define HACTCONNECTION	((HPROJECT)(NULL))		// aktuelle Datenquelle")
		typedef [hidden] struct HPROJECT__ { int unused; } *HPROJECT;
	cpp_quote("#endif // _DEFINED_HPROJECT")
#endif // _DEFINED_HPROJECT

#if !defined(_DEFINED_HOBJECTS)
#define _DEFINED_HOBJECTS
	cpp_quote("#if !defined(_DEFINED_HOBJECTS)")
	cpp_quote("#define _DEFINED_HOBJECTS")
	cpp_quote("#define INVALID_HOBJECTS		((HOBJECTS)(NULL))		// ungültiges Handle")
#if defined(_USE_REAL_HANDLES)
		typedef [hidden] struct HOBJECTS__ { int unused; } *HOBJECTS;
#else
		typedef [hidden] INT_PTR HOBJECTS;
#endif // defined(_USE_REAL_HANDLES)
	cpp_quote("#endif // _DEFINED_HOBJECTS")
#endif // _DEFINED_HPROJECT

#if !defined(_DEFINED_HOBJECT)
#define _DEFINED_HOBJECT
	cpp_quote("#if !defined(_DEFINED_HOBJECT)")
	cpp_quote("#define _DEFINED_HOBJECT")
	cpp_quote("#define INVALID_HOBJECT		((HOBJECT)(NULL))		// ungültiges Handle")
#if defined(_USE_REAL_HANDLES)
		typedef [hidden] struct HOBJECT__ { int unused; } *HOBJECT;
#else
		typedef [hidden] INT_PTR HOBJECT;
#endif // defined(_USE_REAL_HANDLES)
	cpp_quote("#endif // _DEFINED_HOBJECT")
#endif // _DEFINED_HPROJECT

#if !defined(_DEFINED_HFEATURE)
#define _DEFINED_HFEATURE
	cpp_quote("#if !defined(_DEFINED_HFEATURE)")
	cpp_quote("#define _DEFINED_HFEATURE")
	cpp_quote("#define INVALID_HFEATURE		((HFEATURE)(NULL))		// ungültiges Handle")
#if defined(_USE_REAL_HANDLES)
		typedef [hidden] struct HFEATURE__ { int unused; } *HFEATURE;
#else
		typedef [hidden] INT_PTR HFEATURE;
#endif // defined(_USE_REAL_HANDLES)
	cpp_quote("#endif // _DEFINED_HFEATURE")
#endif // _DEFINED_HFEATURE

///////////////////////////////////////////////////////////////////////////////
// forward declaration of defined interfaces
interface ITRiASDBEngine;
interface ITRiASProjects;
interface ITRiASProject;
interface ITRiASConnections;
interface ITRiASConnection;
interface ITRiASDatabase;
interface ITRiASAccessDatabase;

interface ITRiASViews;
interface ITRiASView;
interface ITRiASViewItems;
interface ITRiASViewItem;

interface ITRiASObjects;
interface ITRiASObjectsEx;
interface ITRiASObjectsCallback;
interface ITRiASObjectsCollection;
interface ITRiASObjectsCollectionCallback;
interface ITRiASObjectsOperations;
interface ITRiASObject;
interface ITRiASObjectCallback;

interface ITRiASFeatures;
interface ITRiASFeaturesCallback;
interface ITRiASFeature;
interface ITRiASFeatureCallback;

interface ITRiASRelations;
interface ITRiASRelation;

interface ITRiASProperties;
interface ITRiASProperty;
interface ITRiASPropertySupport;
interface ITRiASPropertyBase;

interface ITRiASDataServerRegEntries;
interface ITRiASDataServerRegEntry;
interface ITRiASObjectHandleMap;

interface ITRiASSearchObjects;
interface ITRiASQueryVisInfo;

interface ITRiASConnectionFilters;
interface ITRiASConnectionFilter;

interface IReconnectDialog;
interface ICreateDatabase;

///////////////////////////////////////////////////////////////////////////////
// @doc INTERFACE TRIASDB
// @interface ITRiASDBEngine | Die Mutter aller Dinge: Das Objekt, welches das Interface
// ITRiASDBEngine implementiert hat, steht an der Spitze der Objekthierarchie aller
// Zugriffsobjekte eines TRiASDB Schnittstellenmodules. Es dient zur Initialisierung/
// Deinitialiserung der gesamten Datenbank-Engine, der Abfrage aller installierten Datenquellentypen, 
// sowie der Voreinstellung diverser globaler Eigenschaften.
// @supby <o TRiASDBEngine>, <o TRiASGDOEngine>
// @xref <o TRiASDBEngine>, <o TRiASGDOEngine>, <i ITRiASMainDBEngine>
// @devnote Dieses Interface muß von jedem Objekt implementiert werden, welches einen
// TRiASDB- Schnittstellenmodul repräsentiert.
// @group Methoden und Eigenschaften von <i ITRiASDBEngine> 
// @index | IDBENGINE
// @doc IDBENGINE
	[
		object,
		uuid(1CB3AB7B-2E87-11D1-969D-00A024D6F582),
		dual,
		helpstring("ITRiASDBEngine Interface"),
		pointer_default(unique)
	]
	interface ITRiASDBEngine : IDispatch
	{
	cpp_quote("#if !defined(_STARTMODE_DEFINED)")
	cpp_quote("#define _STARTMODE_DEFINED")
	// @doc STARTDBENGINEENUMS 
	// @enum STARTMODE | Der Mode, in dem die DBEngine gestartet wurde.
	// @xref <i ITRiASDBEngine>, <om ITRiASDBEngine.Start>
		typedef [public, v1_enum, helpstring("Modi zum Starten eines Datenbankschnittstellen-Modules")]
		enum _tagSTARTMODE {
			[helpstring("Starten im Standard-Modus")]
				STARTMODE_Normal = 0,		// @emem Das Datenbankschnittstellen-Modul wird im Standard-Modus gestartet
			[helpstring("Starten im SysAdmin-Modus")]
				STARTMODE_SysAdmin = 1,		// @emem Das Datenbankschnittstellen-Modul wird im SysAdmin-Modus gestartet.
			[helpstring("Bei Öffnen Backup der Datenbankdatei anlegen")]
				STARTMODE_BackupDatafile = 2,		// @emem Bei Öffnen Backup der Datenbankdatei anlegen.
			[helpstring("Uralte Datenbanken (*.stb) verfügbar machen")]
				STARTMODE_CompatibleWithStb = 0x80,		// @emem Uralte Datenbanken (*.stb) verfügbar machen.
		} STARTMODE;
	cpp_quote("#endif // _STARTMODE_DEFINED")

	// @doc IDBENGINE
	// @property BSTR | ITRiASDBEngine | Version | Liefert die Version 
	// dieses Datenbankschnittstellen-Modules (readonly)
	// @supby <o TRiASDBEngine>, <o TRiASGDOEngine>
	// @xref <i ITRiASDBEngine>
		[propget, id(1), helpstring("Liefert die Version dieses Modules.")] HRESULT Version([out, retval] BSTR *pVal);
	
	// @property BSTR | ITRiASDBEngine | Password | Voreinstellen eines 
	// Passwortes für zu öffnende Datenbanken. Dieses Password wird beim Öffnen 
	// von Datenbanken verwendet, sofern dabei kein anderes explizit vorgegeben 
	// wird (writeonly).
	// @supby <o TRiASDBEngine>, <o TRiASGDOEngine>
	// @xref <i ITRiASDBEngine>
		[propput, id(2), helpstring("Voreinstellen eines Passwortes für zu öffnende Datenbanken.")] HRESULT Password([in] BSTR newVal);
	
	// @property BSTR | ITRiASDBEngine | UserName | Setzt den Nutzernamen 
	// für zu öffnende Datenbanken. Dieser Nutzername wird beim Öffnen 
	// von Datenbanken verwendet, sofern dabei kein anderer explizit vorgegeben 
	// wird (writeonly).
	// @supby <o TRiASDBEngine>, <o TRiASGDOEngine>
	// @xref <i ITRiASDBEngine>
		[propput, id(3), helpstring("Setzt den Nutzernamen für zu öffnende Datenbanken.")] HRESULT UserName([in] BSTR newVal);
	
	// @property BSTR | ITRiASDBEngine | Description | Liefert eine etwas 
	// ausführlichere Beschreibung der DBEngine (readonly).
	// @supby <o TRiASDBEngine>, <o TRiASGDOEngine>
	// @xref <i ITRiASDBEngine>
		[propget, id(DISPID_DEFAULT), helpstring("Liefert eine etwas ausführlichere Beschreibung der DBEngine.")] HRESULT Description([out, retval] BSTR *pVal);

	// @method HRESULT | ITRiASDBEngine | Start | Initialisiert diesen TRiASDB-Schnittstellenmodul.
	// @parm <t STARTMODE> | StartMode | Der Parameter <p StartMode> enthält den Mode, in dem der
	// Datenbankschnittstellen-Modul gestartet werden soll.
	// @comm Diese Methode muß als erste Funktion gerufen werden, da hier alle notwendigen
	// internen Modul-Initialisierungen erfolgen. Jeder Aufruf einer anderen Funktion vor
	// dem Aufruf von <om .Start> schlägt fehl und liefert den Fehlercode TRIASDB_E_NOT_STARTED.
	// Das Gegenstück zur Methode <om .Start> ist die Methode <om .Stop>, welche nach Beendigung
	// sämtlicher Operationen mit diesem TRiASDB-Schnittstellenmodul gerufen werden
	// sollte, damit die gesamten Resourcen freigegeben werden können, die ducrch diesen Modul
	// verwendet worden sind.
	// @supby <o TRiASDBEngine>, <o TRiASGDOEngine>
	// @xref <om .Stop>, <i ITRiASDBEngine>, <t STARTMODE>
		[id(100), helpstring("Initialisiert die Datenbankmaschine.")] HRESULT Start([in] STARTMODE Mode);

	// @method HRESULT | ITRiASDBEngine | EnumDataBaseTypes | Liefert einen Enumerator, der alle derzeit durch diesen 
	// Schnittstellenmodul unterstützten Projekttypen enthält.
	// @parm IUnknown ** | ppIEnum | Zeiger auf eine Variable vom Typ IUnknown *, welche nach erfolgreicher 
	// Abarbeitung der Methode <om .EnumDataBaseTypes> den Ergebnis-Enumerator enthält.
	// @comm Der gelieferte Enumerator ist vom Typ IEnumString. Daher sollte der Rückgabewert
	// explizit durch einen QueryInterface-Aufruf konvertiert werden.
	// @ex Das folgende Beispiel verdeutlicht die empfohlene Vorgehensweise |
	// IEnumString *pIEnum = NULL;
	// IUnknown *pIUnk = NULL;
	// HRESULT hr = pIDBEngine -> EnumDataBaseTypes (&pIUnk);
	//
	//	if (SUCCEEDED(hr)) {
	//		hr = pIUnk -> QueryInterface(IID_IEnumString, (LPVOID *)&pIEnum);
	//		pIUnk -> Release();
	//	}
	//	...
	// @supby <o TRiASDBEngine>, <o TRiASGDOEngine>
	// @xref <i ITRiASDBEngine>
		[id(101), helpstring("Liefert einen Enumerator, der alle unterstützten Projekttypen enthält.")] HRESULT EnumDataBaseTypes([out, retval] IUnknown **ppIEnum);

	// @method HRESULT | ITRiASDBEngine | Stop | Deinitialisiert diesen TRiASDB-Schnittstellenmodul.
	// @comm Diese Methode muß als letzte Funktion gerufen werden, da hier sämtliche durch diesen
	// Schnittstellenmodul angeforderten Resourcen freigegeben werden. Jeder Aufruf einer Funktion
	// nach dem Aufruf von <om .Stop> schlägt fehl und liefert den Fehlercode
	// TRIASDB_E_NOT_STARTED.
	// @supby <o TRiASDBEngine>, <o TRiASGDOEngine>
	// @xref <om .Start>, <i ITRiASDBEngine>
		[id(102), helpstring("Deinitialisiert die Datenbankmaschine.")] HRESULT Stop();
	};

///////////////////////////////////////////////////////////////////////////////
// @doc INTERFACE TRIASDB
// @interface ITRiASBase | Das Interface <i ITRiASBase> dient der Verkettung der Objekte 
// in der Objekthierarchie.
// @group Methoden und Eigenschaften von <i ITRiASBase> 
// @index | ITRIASBASE
// @doc ITRIASBASE
	[
		object,
		uuid(710B2C36-890F-11D2-9EFB-006008447800),
		dual,
		helpstring("ITRiASBase Interface"),
		pointer_default(unique)
	]
	interface ITRiASBase : IDispatch
	{
	// @property IDispatch * | ITRiASBase | Application | Die <op .Application>- Eigenschaft
	// setzt bzw. liefert das zugehörige Application-Objekt
		[propget, id(DISPID_APPLICATION), helpstring("Application.")] HRESULT Application([out, retval] IDispatch **pVal);
		[propput, id(DISPID_APPLICATION), hidden, restricted, helpstring("Application.")] HRESULT Application([in] IDispatch *newVal);

	// @property IDispatch * | ITRiASBase | Parent | Die <op .Parent>- Eigenschaft
	// setzt bzw. liefert das übergeordnete Objekt dieses Projektes.
		[propget, id(DISPID_PARENT), helpstring("Parent.")] HRESULT Parent([out, retval] IDispatch **pVal);
		[propput, id(DISPID_PARENT), hidden, restricted, helpstring("Parent.")] HRESULT Parent([in] IDispatch *newVal);
	};

///////////////////////////////////////////////////////////////////////////////
// @doc INTERFACE TRIASDB
// @interface ITRiASPropertyBase | Das Interface <i ITRiASPropertyBase> dient der Verwaltung
// von Instanz-orientierten Eigenschaften eines Objektes. Es ist derzeit ein Basisinterface
// von <i ITRiASDatabase>, <i ITRiASProject> und <i ITRiASView>.
// @comm Dieses Interface dient zur Kapselung der Funktionalitäten, die zur Verwaltung von 
// Instanz-orientierten Eigenschaften eines COM-Objektes notwendig sind.
// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>, <o TRiASProject>
// @xref <i ITRiASDatabase>, <i ITRiASProject>, <i ITRiASProperty>, <i ITRiASProperties>, <i ITRiASView>
// @devnote Dieses Interface muß immer dann implementiert werden, wenn es notwendig ist, einem
// COM-Objekt Eigenschaften zuzuordnen, die von Instanz zu Instanz dieses Objektes wechseln
// können. Eigenschaften, die jede Instanz eines derartigen COM-Objektes besitzt, können
// selbstverständlich ebenfalls verwaltet werden, sind aber in separaten Funktionen 
// (Properties) sicher besser augehoben. Eine Einzelne derartige Eigenschaft wird über 
// ein separates COM-Objekt verwaltet, welches zumindest das Interface ITRiASProperty
// implementiert.
// @group Methoden und Eigenschaften von <i ITRiASPropertyBase> 
// @index | IPROPERTYBASE
// @doc IPROPERTYBASE
	[
		object,
		uuid(97993C78-5FE6-11D1-B9E6-080036D63803),
		dual,
		helpstring("ITRiASPropertyBase Interface"),
		pointer_default(unique)
	]
	interface ITRiASPropertyBase : IDispatch
	{
	// @property <i ITRiASProperties> ** | ITRiASPropertyBase | Properties | Die <op .Properties>- 
	// Eigenschaft liefert bzw. setzt die Sammlung aller zu diesem COM-Objekt gehörenden Properties (Eigenschaften).
	// @supby <o TRiASProperty>
	// @xref <i ITRiASPropertyBase>, <i ITRiASProperties>
		[propget, id(50), helpstring("Liefert die Sammlung aller zu diesem Objekt gehörenden Properties (Eigenschaften).")] HRESULT Properties([out, retval] ITRiASProperties **pVal);
		[propput, id(50), helpstring("Setzt die Sammlung aller zu diesem Objekt gehörenden Properties (Eigenschaften).")] HRESULT Properties([in] ITRiASProperties *pVal);

	// @property <i ITRiASProperty> ** | ITRiASPropertyBase | Property | Die <op .Property>- Eigenschaft
	// liefert eine zu diesem Objekt gehörenden Property (Eigenschaft).
	// @parm BSTR | Name | Der Bezeichner der zu liefernden Property (Eigenschaft).
	// @comm Die Eigenschaft <op .Property> kann nicht gesetzt werden.
	// @supby <o TRiASProperty>
	// @xref <i ITRiASPropertyBase>, <i ITRiASProperty>
		[propget, id(51), helpstring("Liefert eine zu diesem Objekt gehörenden Property (Eigenschaft).")] HRESULT Property([in] BSTR Which, [out, retval] ITRiASProperty **pVal);

	// @method HRESULT | ITRiASPropertyBase | CreateProperty | Die <om .CreateProperty>- Methode 
	// erzeugt eine zu diesem Objekt gehörenden Property (Eigenschaft) neu und liefert diese.
	// @parm BSTR | Name | Der Bezeichner der zu erzeugenden Property (Eigenschaft).
	// @parm <i ITRiASProperty> ** | Prop | Die Adresse des Zeigers, wohin die neue Property (Eigenschaft) 
	// bei erfolgreicher Bearbeitung der <om .CreateProperty>- Methode abgelegt werden soll.
	// @supby <o TRiASProperty>
	// @xref <i ITRiASPropertyBase>, <i ITRiASProperty>
		[id(60), helpstring("Erzeugt und liefert eine zu diesem Objekt gehörenden Property (Eigenschaft).")] HRESULT CreateProperty([in] BSTR Which, [out, retval] ITRiASProperty **Prop);

	// @method HRESULT | ITRiASPropertyBase | RemoveProperty | Die <om .RemoveProperty>- Methode 
	// löscht eine zu diesem Objekt gehörenden Property (Eigenschaft).
	// @parm BSTR | Name | Der Bezeichner der zu löschenden Property (Eigenschaft).
	// @supby <o TRiASProperty>
	// @xref <i ITRiASPropertyBase>
		[id(61), helpstring("Löscht eine zu diesem Objekt gehörenden Property (Eigenschaft).")] HRESULT RemoveProperty([in] BSTR Name);
	};

// @doc INTERFACE TRIASDB
// @interface ITRiASProject | Das Interface <i ITRiASProject> dient der Verwaltung 
// eines Projektes.  
// @comm Dieses Interface dient zur Kapselung der Funktionalitäten, die zur Verwaltung von 
// allen Daten die eine aktuelle Arbeitsumgebung betreffen dienen.
// @supby <o TRiASProject>
// @devnote Dieses Interface ist am Objekt TRiASProject implementiert und muß sicherlich nicht 
// an anderer Stelle zur Verfügung gestellt werden.
// @group Methoden und Eigenschaften von <i ITRiASProject> 
// @index | IPROJECT
// @doc IPROJECT
	[
		object,
		uuid(1CB3AB62-2E87-11D1-969D-00A024D6F582),
		dual,
		helpstring("ITRiASProject Interface"),
		pointer_default(unique)
	]
	interface ITRiASProject : ITRiASBase
	{
#if !defined(_OPENMODE_DEFINED)
#define _OPENMODE_DEFINED
	cpp_quote("#if !defined(_OPENMODE_DEFINED)")
	cpp_quote("#define _OPENMODE_DEFINED")
	// @doc OPENMODEENUMS 
	// @enum OPENMODE | Der Mode, in dem dieses Projekt eröffnet werden soll bzw. eröffnet worden ist.
	// @xref <i ITRiASProject>, <op ITRiASProject.Mode>
		typedef [public, v1_enum, helpstring("Modi zum Eröffnen eines Projektes")]
		enum _tagOPENMODE {
			[helpstring("Unbekannte Schreib- bzw. Leserechte.")]
				OPENMODE_Unknown = 0xffff,		// @emem Unbekannte Schreib- bzw. Leserechte
			[helpstring("Eröffnen mit Schreib- und Leserechten")]
				OPENMODE_Normal = 0,		// @emem Das Projekt wird mit normalen Schreibrechten 
					// eröffnet.
			[helpstring("Eröffnen mit Leserechten")]
				OPENMODE_ReadOnly = 1,		// @emem Das Projekt wird mit Schreibschutz eröffnet.
			[helpstring("Standardansicht nach eröffnen nicht anzeigen")]
				OPENMODE_NoDefaultView = 2,	// @emem Nach dem Eröffnen des Projektes wird eine 
					// evtl. existierende Startansicht nicht automatisch aktiviert.
			[helpstring("Projektfenster nicht anzeigen")]
				OPENMODE_HideDocument = 4,	// @emem Das Hauptfenster des Projektes ist derzeit nicht 
					// angezeigt (<tr> befindet sich im /Automation-Mode), daher darf es nach dem
					// Eröffnen dieses Projektes nicht zur Anzeige gebracht werden.
			[helpstring("Dieses Projekt ist ab sofort das aktuelle Projekt."), hidden, restricted]
				OPENMODE_Activate = 8,		// @emem Das neu eröffnete Projekt wird sofort gleichzeitig 
					// zum aktuellen Projekt.
			[helpstring("Dieses Projekt nicht zum MRU-Menu hizufügen."), hidden, restricted]
				OPENMODE_DoNotAddToMRU = 0x10,		// @emem Dieses Projekt nicht zum MRU-Menu hizufügen 
					// zum aktuellen Projekt.
			[helpstring("Dieses Projekt nicht zum MRU-Menu hizufügen."), hidden]
				OPENMODE_CreateInternalDatasource = 0x100,		// @emem Bei Erzeugen des Projektes sofort eine
				// interne Datenquelle miterzeugen
			[helpstring("Neues Projekt muß 16Bit kompatibel sein.")]
				OPENMODE_16BitCompatible = 0x2040,	// @emem Das neue Projekt muß kompatibel
					// zur 16-Bit Version von <tr> sein.
		} OPENMODE;
	cpp_quote("#endif // _OPENMODE_DEFINED")
#endif // _OPENMODE_DEFINED

	// @doc IPROJECT
	// @property long | ITRiASProject | Version | Die <op .Version>- Eigenschaft liefert die Versionsnummer
	// des zugehörigen TRiASDB-Projektes.
	// @comm Die Eigenschaft <op .Version> kann nicht gesetzt werden.
	// @comm Derzeit wird als Versionsnummer immer '0x0300' geliefert.
	// @supby <o TRiASProject> 
	// @xref <i ITRiASProject>
		[propget, id(3), helpstring("Liefert die Version der zugehörigen Datenbank.")] HRESULT Version([out, retval] long *pVal);

	// @property BSTR | ITRiASProject | Name | Die <op .Name>- Eigenschaft liefert bzw. setzt den 
	// Namen des zugehörigen TRiASDB-Projektes.
	// @comm Der gegebene Name wird als Dateipfad ausgewertet, unter dem die Projektdatei zufinden
	// ist.
	// @supby <o TRiASProject> 
	// @xref <i ITRiASProject>
		[propget, id(DISPID_DEFAULT), helpstring("Liefert den Namen der zugehörigen Datenbank.")] HRESULT Name([out, retval] BSTR *pVal);
		[propput, id(DISPID_DEFAULT), helpstring("Setzt den Namen der zugehörigen Datenbank."), hidden] HRESULT Name([in] BSTR newVal);

	// @property VARIANT_BOOL | ITRiASProject | Updatable | Die <op .Updatable>- Eigenschaft liefert,
	// ob die angebundenen Projektdatei beschreibbar ist (nicht schreibgeschützt).
	// @comm Die Eigenschaft <op .Updatable> kann nicht gesetzt werden (readonly).
	// @supby <o TRiASProject>, <o TRiASConnection> 
	// @xref <i ITRiASProject>
		[propget, id(5), helpstring("Liefert, ob die zugehörige Datenbank beschreibbar ist.")] HRESULT Updatable([out, retval] VARIANT_BOOL *pVal);
		[propput, id(5), helpstring("Setzt, ob die zugehörige Datenbank beschreibbar ist."), hidden] HRESULT Updatable([in] VARIANT_BOOL newVal);

	// @property VARIANT_BOOL | ITRiASProject | OpenedAsCopy | Die <op .OpenedAsCopy>- Eigenschaft gibt
	// an, ob die Datenbank beim Öffnen kopiert wurde, um Zugriffskonflikte oder Zugriffsrechts-Konflikte
	// zu lösen. 
	// @comm Diese Eigenschaft darf nur dann den Wert '<cv True>' haben, wenn gleichzeitig die Methoden
	// <om .Save>, <om .SaveAs> sowie die Eigenschaft <op .CouldOpenTarget> unterstützt werden.
	// @comm Die Eigenschaft <op .OpenedAsCopy> kann nicht gesetzt werden.
	// @supby <o TRiASProject> 
	// @xref <i ITRiASProject>
		[propget, id(6), helpstring("Liefert, ob die zugehörige Datei als Kopie der Originaldatei geöffnet wurde.")] HRESULT OpenedAsCopy([out, retval] VARIANT_BOOL *pVal);
		[propput, id(6), helpstring("Setzt, ob die zugehörige Datei als Kopie der Originaldatei geöffnet wurde."), hidden] HRESULT OpenedAsCopy([in] VARIANT_BOOL newVal);

	// @property VARIANT_BOOL | ITRiASProject | CouldOpenTarget | Die <op .CouldOpenTarget>- Eigenschaft
	// gibt an, ob beim Öffnen der Ausgangs-Datenbank, die ihrerseits beim Öffnen kopiert worden ist, 
	// um einen Zugriffskonflikt bzw. Zugriffsrechtskonflikt zu lösen, immer noch eben dieser
	// Zugriffs- bzw. Zugriffsrechts-Konflikt auftreten würde.
	// @comm Diese Eigenschaft wird lediglich dann sinnvolle Ergebnisse liefern, wenn die 
	// <op .OpenedAsCopy>- Eigenschaft den Wert '<cv True>' besitzt. 
	// @comm Die Eigenschaft <op .CouldOpenTarget> kann nicht gesetzt werden.
	// @supby <o TRiASProject>
	// @xref <i ITRiASDatabase>
		[propget, id(7), helpstring("Liefert ob die Bezugsdatenbank jetzt ohne Konflikte geöffnet werden könnte.")] HRESULT CouldOpenTarget([out, retval] VARIANT_BOOL *pVal);

	// @property <t OPENMODE> | ITRiASProject | Mode | Die <op .Mode>- Eigenschaft
	// @supby <o TRiASProject> 
	// @xref <i ITRiASProject>, <t OPENMODE>
		[propget, id(8), helpstring("Liefert den Mode in dem die zugehörige Datenbank geöffnet werden soll.")] HRESULT Mode([out, retval] OPENMODE *pVal);
		[propput, id(8), helpstring("Setzt den Mode in dem die zugehörige Datenbank geöffnet werden soll.")] HRESULT Mode([in] OPENMODE newVal);

	// @property <i ITRiASConnections> * | ITRiASProject | Connections | Die <op .Connections>- Eigenschaft
	// @supby <o TRiASProject> 
	// @xref <i ITRiASProject>, <i ITRiASConnections>
		[propget, id(9), helpstring("Liefert die Sammlung aller zu diesem Projekt gehörenden Connections (Datenquellen).")] HRESULT Connections([out, retval] ITRiASConnections **pVal);

	// @property <i ITRiASConnection> * | ITRiASProject | Connection | Die <op .Connection>- 
	// Eigenschaft liefert eine zu diesem Projekt gehörende Connection.
	// @parm VARIANT | Item | Der Name bzw. die Nummer  in der <o TRiASConnections>- Objektmenge dieses
	// Projektes der zu liefernden Connection.
	// @supby <o TRiASProject> 
	// @xref <i ITRiASProject>, <i ITRiASConnection>, <o TRiASConnections>
		[propget, id(10), helpstring("Liefert eine zu diesem Projekt gehörende Connection.")] HRESULT Connection([in] VARIANT vItem, [out, retval] ITRiASConnection **pVal);

	// @property <i ITRiASViews> * | ITRiASProject | Views | Die <op .Views>- Eigenschaft liefert die
	// Sammlung aller zu diesem Projekt gehörenden Views (Ansichten).
	// @comm Die Eigenschaft <op .Views> kann nicht gesetzt werden.
	// @supby <o TRiASProject> 
	// @xref <i ITRiASProject>, <i ITRiASViews>
		[propget, id(11), helpstring("Liefert die Sammlung aller zu diesem Projekt gehörenden Views (Ansichten).")] HRESULT Views([out, retval] ITRiASViews **pVal);

	// @property <i ITRiASView> * | ITRiASProject | View | Die <op .View>- Eigenschaft liefert eine
	// zu diesem Projekt gehörende View (Ansicht).
	// @parm BSTR | Name | Der Name der zu liefernden View (Ansicht).
	// @parm VARIANT_BOOL | fCreate | Die Ansicht soll neu erzeugt werden, wenn sie noch nicht existiert.
	// @comm Die Eigenschaft <op .View> kann nicht gesetzt werden.
	// @rvalue <cv S_OK> | Die Operation war erfolgreich (die Ansicht existierte bereits).
	// @rvalue <cv S_FALSE> | Die Operation war erfolgreich aber die Ansicht mußte neu erzeugt werden.
	// Dieser Rückgabewert kann nur dann geliefert werden, wenn der Parameter <p fCreate> den Wert 
	// <cv True> hatte.
	// @supby <o TRiASProject> 
	// @xref <i ITRiASProject>, <i ITRiASView>
	// @end
		[propget, id(12), helpstring("Liefert eine zu diesem Projekt gehörende View (Ansicht).")] HRESULT View([in] BSTR Name, [in /*, optional*/, defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fCreate, [out, retval] ITRiASView **pVal);

	// @property VARIANT_BOOL | ITRiASProject | Temporary | Die <op .Temporary>- Eigenschaft 
	// liefert bzw. setzt, ob dieses Projekt temporär erzeugt wurde.
	// @supby <o TRiASProject> 
	// @xref <i ITRiASProject>
		[propget, id(13), helpstring("Liefert, ob dieses Projekt temporär erzeugt wurde.")] HRESULT Temporary([out, retval] VARIANT_BOOL *pVal);
		[propput, id(13), helpstring("Setzt, ob dieses Projekt temporär erzeugt wurde."), hidden] HRESULT Temporary([in] VARIANT_BOOL newVal);

	// @property INT_PTR | ITRiASProject | Handle | Die <op .Handle>- Eigenschaft liefert eine
	// eindeutige Zugriffsnummer für dieses Projekt (readonly).
	// @comm Die Eigenschaft <op .Handle> kann nicht gesetzt werden.
	// @supby <o TRiASProject>
	// @xref <i ITRiASProject>
		[propget, id(14), helpstring("Liefert eine eindeutige Zugriffsnummer für dieses Projekt."), hidden, restricted] HRESULT Handle([out, retval] INT_PTR *pVal);

	// @property VARIANT_BOOL | ITRiASProject | Dirty | Die <op .Dirty>- Eigenschaft 
	// liefert bzw. setzt, ob dieses Projekt gespeichert werden muß (modifiziert wurde).
	// @supby <o TRiASProject> 
	// @xref <i ITRiASProject>
		[propget, id(15), helpstring("Liefert, ob dieses Projekt gespeichert werden muß (modifiziert wurde).")] HRESULT Dirty([out, retval] VARIANT_BOOL *pVal);
		[propput, id(15), helpstring("Setzt, ob dieses Projekt gespeichert werden muß (modifiziert wurde).")] HRESULT Dirty([in] VARIANT_BOOL newVal);

	// @property VARIANT_BOOL | ITRiASProject | Activated | Die <op .Activated>- Eigenschaft setzt bzw. 
	// liefert, ob dieses Projekt derzeit das aktivierte ist (ob das zugehörige Fenster den Eingabefokus
	// besitzt).
	// @supby <o TRiASProject>
	// @xref <i ITRiASProject>
		[propget, id(16), helpstring("Liefert, ob dieses Projekt derzeit das aktive ist.")] HRESULT Activated([out, retval] VARIANT_BOOL *pVal);
		[propput, id(16), helpstring("Setzt, ob dieses Projekt derzeit das aktive ist.")] HRESULT Activated([in] VARIANT_BOOL newVal);

	// @property <i ITRiASObjectsCollection> * | ITRiASProject | ObjectsDefs |
	// Die <op .ObjectsDefs>- Eigenschaft liefert eine Sammlung aller in diesem Projekt
	// definierten Objektklassen.
	// @comm Die Eigenschaft <op .ObjectsDefs> kann nicht gesetzt werden.
	// @comm Im Gegensatz zur gleichnamigen Eigenschaft des <i ITRiASAccessDatabase>- Interfaces liefert die
	// <op .ObjectsDefs>- Eigenschaft des <i ITRiASProject>- Interfaces die Sammlung aller Datenquellen- 
	// übergreifenden bzw. -unabhängigen Objektmengen.
	// @supby <o TRiASProject>
	// @xref <i ITRiASProject>
		[propget, id(17), helpstring("Liefert eine Sammlung aller in diesem Projekt definierten Objektklassen")] HRESULT ObjectsDefs([out, retval] ITRiASObjectsCollection * *pVal);

	// @property <i ITRiASObjects> * | ITRiASProject | ObjectsDef |
	// Die <op .ObjectsDef>- Eigenschaft liefert eine bestimmte zu diesem Projekt gehörenden 
	// Objektklasse.
	// @parm VARIANT | Item | Der Bezeichner der zu liefernden Objektmende (TRiASObjects).
	// @parm VARIANT_BOOL | fCreate | Die Objektemenge soll neu erzeugt werden, wenn sie
	// noch nicht existiert.
	// @parm BSTR | Type | Wenn der Parameter <p fCreate> den Wert <cv True> besitzt und die gegebene 
	// Objektmenge nicht existiert, dann wird eine neue Objektmenge mit dem hier vorgegeben Typ
	// neu erzeugt (ProgID). Ist der hier gegebene Typ ungültig oder nicht gegeben, dann wird eine 
	// Objektmenge vom Typ <o TRiASObjects> erzeugt.
	// @comm Die Eigenschaft <op .ObjectsDef> kann nicht gesetzt werden.
	// @rvalue <cv S_OK> | Die Operation war erfolgreich (die Objektmenge existierte bereits).
	// @rvalue <cv S_FALSE> | Die Operation war erfolgreich aber die Objektmenge mußte neu 
	// erzeugt werden. Dieser Rückgabewert kann nur dann geliefert werden, wenn der 
	// Parameter <p fCreate> den Wert <cv True> hatte.
	// @supby <o TRiASProject>
	// @xref <i ITRiASProject>
	// @end
		[propget, id(18), helpstring("Liefert eine bestimmte zu diesem Projekt gehörenden Objektklasse.")] HRESULT ObjectsDef([in] VARIANT vItem, [in /*, optional*/, defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fCreate, [in /*, optional*/, defaultvalue("")] BSTR Type, [out, retval] ITRiASObjects **pIObjsDef);

	// @method HRESULT | ITRiASProject | Close | Die <om .Close>- Methode
	// @parm VARIANT_BOOL | Commit | (optional) Der Parameter <p Coomit> gibt an, ob eventuelle 
	// Änderungen vor dem Schließen des Projektes gespeichert werden sollen. Der Standardwert für 
	// diesen Parameter ist <cv False>.
	// @supby <o TRiASProject> 
	// @xref <i ITRiASProject>
	// @end
		[id(100), helpstring("Schließt die Verbindung zur zugehörigen Projektdatei.")] HRESULT Close([in /*, optional*/, defaultvalue(VARIANT_FALSE)] VARIANT_BOOL Commit);

	// @method HRESULT | ITRiASProject | NewPassword | Die <om .NewPassword>- Methode
	// @parm BSTR | OldPassword | 
	// @parm BSTR | NewPassword | 
	// @supby <o TRiASProject> 
	// @xref <i ITRiASProject>
		[id(101), helpstring("Stellt ein neues Zugriffspasswort für den aktuellen Nutzer dieses Projektes ein.")] HRESULT NewPassword([in] BSTR OldPassword, [in] BSTR NewPassword);

	// @method HRESULT | ITRiASProject | Save | Die <om .Save>- Methode
	// @supby <o TRiASProject> 
	// @xref <i ITRiASProject>
		[id(102), helpstring("Speichern des Projektes.")] HRESULT Save();

	// @method HRESULT | ITRiASProject | SaveAs | Die <om .SaveAs>- Methode speichert das Projekt unter
	// einem neuen Namen.
	// @parm BSTR | NewName | Gibt den vollständigen Pfad vor, unter dem das Projekt gespeichert 
	// werden soll.
	// @comm Die bisherige Kopie des Projektes bleibt in dem Zustand erhhalten, der nach dem letzten
	// erfolgreichen Speichern zurückgelassen wurde. Sämtliche Änderungen seit dem letzten Speichern sind
	// nur in der neuen Kopie des Projektes verfügbar.
	// @supby <o TRiASProject> 
	// @xref <i ITRiASProject>
		[id(103), helpstring("Speichert das Projekt unter einem anderen Namen.")] HRESULT SaveAs(BSTR NewName);

	// @method HRESULT | ITRiASProject | ExportCopyAs | Die <om .ExportCopyAs>- Methode
	// @parm BSTR | NewName | Gibt den vollständigen Pfad vor, unter dem die Kopie des Projektes
	// gespeichert werden soll.
	// Die neu erzeugte Kopie des Projektes enthält alle Änderungen bis zum Zeitpunkt des Aufrufes der
	// <om .ExportCopyAs> Methode. Die Änderungen seit dem letzten Speichern der aktuellen Kopie werden
	// jedoch erst durch einen expliziten Aufruf der <om .Save>- Methode gespeichert.
	// @supby <o TRiASProject> 
	// @xref <i ITRiASProject>
		[id(104), helpstring("Exportiert eine Kopie des Projektes unter einem anderen Namen.")] HRESULT ExportCopyAs(BSTR NewName);

	// @property <i ITRiASConnectionFilters> * | ITRiASProject | ConnectionFilters |
	// Die <op .ObjectsDefs>- Eigenschaft liefert eine Sammlung aller in diesem Projekt
	// definierten Verbindungsfilter.
	// @comm Die Eigenschaft <op .ConnectionFilters> kann nicht gesetzt werden.
	// @supby <o TRiASProject>
	// @xref <i ITRiASProject>
		[propget, id(19), helpstring("Liefert eine Sammlung aller in diesem Projekt definierten Verbindungsfilter")] HRESULT ConnectionFilters([out, retval] ITRiASConnectionFilters **pVal);

	// @property <i ITRiASConnectionFilter> * | ITRiASProject | ConnectionFilter |
	// Die <op .ConnectionFilter>- Eigenschaft liefert ein bestimmtes zu diesem Projekt 
	// gehörendes Verbindungsfilter.
	// @parm VARIANT | Item | Der Bezeichner des zu liefernden Verbindungsfilters (TRiASConnectionFilter).
	// @parm VARIANT_BOOL | fCreate | Der Verbindungsfilter soll neu erzeugt werden, wenn er
	// noch nicht existiert.
	// @comm Die Eigenschaft <op .ConnectionFilter> kann nicht gesetzt werden.
	// @rvalue <cv S_OK> | Die Operation war erfolgreich (das Verbindungsfilter existierte bereits).
	// @rvalue <cv S_FALSE> | Die Operation war erfolgreich aber das Verbindungsfilter mußte neu 
	// erzeugt werden. Dieser Rückgabewert kann nur dann geliefert werden, wenn der 
	// Parameter <p fCreate> den Wert <cv True> hatte.
	// @supby <o TRiASProject>
	// @xref <i ITRiASProject>
	// @end
		[propget, id(20), helpstring("Liefert ein bestimmtes zu diesem Projekt gehörendes Verbindungsfilter.")] HRESULT ConnectionFilter([in] VARIANT vItem, [in /*, optional*/, defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fCreate, [out, retval] ITRiASConnectionFilter **ppVal);
	};

///////////////////////////////////////////////////////////////////////////////
// Collection von TRiASDB-Projekten
// @doc INTERFACE TRIASDB
// @interface ITRiASProjects | 
// @supby <o TRiASProjects>
// @xref <o TRiASProjects>, <i ITRiASProjects>
// @group Methoden und Eigenschaften von <i ITRiASProjects> 
// @index | IPROJECTS
// @doc IPROJECTS
	[
		object,
		uuid(1CB3AB79-2E87-11D1-969D-00A024D6F582),
		dual,
		helpstring("ITRiASProjects Interface"),
		pointer_default(unique)
	]
	interface ITRiASProjects : ITRiASBase
	{
	// @property LONG | ITRiASProjects | Count | Liefert die Anzahl der in dieser Objektsammlungen 
	// enthaltenen Objekte (readonly).
	// @comm Die Eigenschaft <op .Count> kann nicht gesetzt werden.
	// @supby <o TRiASProjects> 
	// @xref <i ITRiASProjects>, <o TRiASProjects>
		[propget, id(3), helpstring("Number of active projects.")] HRESULT Count([out, retval] long *pVal);

	// @method HRESULT | ITRiASProjects | Item | 
	// @supby <o TRiASProjects> 
	// @xref <i ITRiASProjects>
		[id(DISPID_DEFAULT), helpstring("Get the project by name or by index number.")] HRESULT Item([in] VARIANT Index, [out, retval] ITRiASProject **Project);

	// @method HRESULT | ITRiASProjects | _NewEnum | Liefert einen neuen
	// Enumerator, der alle Objekte enthält, die in der vorliegenden Sammlung zusammengefaßt sind.
	// @parm IUnknown ** | Enum | Zeiger auf eine Variable vom Typ IUnknown *, welche nach erfolgreicher 
	// Abarbeitung der Methode <om ._NewEnum> den Ergebnis-Enumerator enthält.
	// @comm Der gelieferte Enumerator ist vom Typ <i IEnumVARIANT>. Daher sollte der Rückgabewert
	// explizit durch einen QueryInterface-Aufruf konvertiert werden.
	// @ex Das folgende Beispiel verdeutlicht die empfohlene Vorgehensweise |
	// IEnumVARIANT *pIEnum = NULL;
	// IUnknown *pIUnk = NULL;
	// HRESULT hr = pIEntries -> _NewEnum (&pIUnk);
	//
	//	if (SUCCEEDED(hr)) {
	//		hr = pIUnk -> QueryInterface(IID_IEnumVARIANT, (LPVOID *)&pIEnum);
	//		pIUnk -> Release();
	//	}
	//	...
	// @comm Normalerweise wird diese Funktion nicht direkt gerufen, Sie ist lediglich
	// für die Nutzung in Automation-Werkzeugen wie z.B. VisualBasic vorgesehen, wo sie
	// für Programmkonstrukte wie 'For Each ...' notwendig ist.
	// @supby <o TRiASProjects> 
	// @xref <i ITRiASProjects>, <o TRiASProjects>
		[id(DISPID_NEWENUM), hidden] HRESULT _NewEnum([out, retval] IUnknown **ppIEnum);

		[id(100), helpstring("Create and add a new project.")] HRESULT Add([in] BSTR Name, [out, retval] ITRiASProject **Connection);
		[id(101), helpstring("Remove a project")] HRESULT Remove([in] VARIANT Index);

	// zusätzliches
		[id(102), helpstring("Add an existing project."), hidden] HRESULT _Add([in] ITRiASProject *Project, [in /*, optional*/, defaultvalue(VARIANT_TRUE)] VARIANT_BOOL FullAdd);

	// @method HRESULT | ITRiASProjects | _Clone | Die <om ._Clone>- Methode liefert eine neue Sammlung 
	// von Objekten, die identisch zur vorliegenden ist.
	// @parm <i ITRiASProjects> ** | Enum | Zeiger auf eine Variable vom Typ <i ITRiASProjects> *, 
	// welche nach erfolgreicher Abarbeitung der Methode <om ._Clone> die Kopie dieser Objektsammlung 
	// enthält.
	// @comm Bei Änderungen an der ursprünglichen Objektsammlung wird die neu erzeugte Kopie
	// nicht modifiziert.
	// @supby <o TRiASProjects>
	// @xref <i ITRiASProjects>
		[id(103), helpstring("Erzeugt eine neue Sammlung von Projekten, die der vorliegenden identisch ist."), hidden] HRESULT _Clone([out, retval] ITRiASProjects **Prjs);
		[id(104), helpstring("Zuordnen des Targetobjektes zur Eventbehandlung."), hidden, restricted] HRESULT SetEventSink ([in] IUnknown *pIUnk, [in] VARIANT_BOOL fAdvise);
		[id(105), helpstring("Remove an existing project."), hidden] HRESULT RemoveProject([in] ITRiASProject *Project);

	// @property <i ITRiASProject> ** | ITRiASProjects | ActiveProject | Die <op .ActiveProject>-
	// Eigenschaft liefert das derzeit aktive Projekt (dessen Fenster den Eingabefokus besitzt.
	// @comm Die Eigenschaft <op .ActiveProject> kann nicht gesetzt werden.
	// @supby <o TRiASProjects>, <o TRiASDBEngine>
	// @xref <i ITRiASMainDBEngine>, <i ITRiASProjects>
		[propget, id(4), helpstring("Liefert das derzeit aktive Projekt.")] HRESULT ActiveProject([out, retval] ITRiASProject **pVal);
	};

///////////////////////////////////////////////////////////////////////////////
// @doc INTERFACE TRIASDB
// @interface ITRiASConnections | Collection von Verbindungen zu einer Datenquelle
// @group Methoden und Eigenschaften von <i ITRiASConnections> 
// @index | ICONNECTIONS
// @doc ICONNECTIONS
	[
		object,
		uuid(191A9AF7-37FE-11D1-96B6-00A024D6F582),
		dual,
		helpstring("ITRiASConnections Interface"),
		pointer_default(unique)
	]
	interface ITRiASConnections : ITRiASBase
	{
	// @property LONG | ITRiASConnections | Count | Liefert die Anzahl der in dieser Objektsammlungen 
	// enthaltenen Objekte (readonly).
	// @comm Die Eigenschaft <op .Count> kann nicht gesetzt werden.
	// @supby <o TRiASConnections>
	// @xref <i ITRiASConnections>
		[propget, id(3), helpstring("Number of connections.")] HRESULT Count([out, retval] long *pVal);

	// @method HRESULT | ITRiASConnections | Item | 
	// @supby <o TRiASConnections>
	// @xref <i ITRiASConnections>
		[id(DISPID_DEFAULT), helpstring("Get the connection by name or by index number.")] HRESULT Item([in] VARIANT Index, [out, retval] ITRiASConnection **Connection);

	// @method HRESULT | ITRiASConnections | _NewEnum | Liefert einen neuen
	// Enumerator, der alle Objekte enthält, die in der vorliegenden Sammlung zusammengefaßt sind.
	// @parm IUnknown ** | Enum | Zeiger auf eine Variable vom Typ IUnknown *, welche nach erfolgreicher 
	// Abarbeitung der Methode <om ._NewEnum> den Ergebnis-Enumerator enthält.
	// @comm Der gelieferte Enumerator ist vom Typ <i IEnumVARIANT>. Daher sollte der Rückgabewert
	// explizit durch einen QueryInterface-Aufruf konvertiert werden.
	// @ex Das folgende Beispiel verdeutlicht die empfohlene Vorgehensweise |
	// IEnumVARIANT *pIEnum = NULL;
	// IUnknown *pIUnk = NULL;
	// HRESULT hr = pIEntries -> _NewEnum (&pIUnk);
	//
	//	if (SUCCEEDED(hr)) {
	//		hr = pIUnk -> QueryInterface(IID_IEnumVARIANT, (LPVOID *)&pIEnum);
	//		pIUnk -> Release();
	//	}
	//	...
	// @comm Normalerweise wird diese Funktion nicht direkt gerufen, Sie ist lediglich
	// für die Nutzung in Automation-Werkzeugen wie z.B. VisualBasic vorgesehen, wo sie
	// für Programmkonstrukte wie 'For Each ...' notwendig ist.
	// @supby <o TRiASConnections>
	// @xref <i ITRiASConnections>
		[id(DISPID_NEWENUM), hidden] HRESULT _NewEnum([out, retval] IUnknown **ppIEnum);

		[id(100), helpstring("Create and add a new connection.")] HRESULT Add([in] BSTR Name, [out, retval] ITRiASConnection **Connection);
		[id(101), helpstring("Remove a Connection")] HRESULT Remove([in] VARIANT Index);

	// zusätzliches
		[id(102), helpstring("Add an existing connection."), hidden] HRESULT _Add([in] ITRiASConnection *Connection, [in /*, optional*/, defaultvalue(VARIANT_TRUE)] VARIANT_BOOL FullAdd);

	// @method HRESULT | ITRiASConnections | _Clone | Die <om ._Clone>- Methode liefert eine neue 
	// Sammlung von Objekten, die identisch zur vorliegenden ist.
	// @parm <i ITRiASConnections> ** | Enum | Zeiger auf eine Variable vom Typ <i ITRiASConnections> *, 
	// welche nach erfolgreicher Abarbeitung der Methode <om ._Clone> die Kopie dieser Objektsammlung 
	// enthält.
	// @comm Bei Änderungen an der ursprünglichen Objektsammlung wird die neu erzeugte Kopie
	// nicht modifiziert.
	// @supby <o TRiASConnections>
	// @xref <i ITRiASConnections>
		[id(103), helpstring("Erzeugt eine neue Sammlung von Datenquellen, die der vorliegenden identisch ist."), hidden] HRESULT _Clone([out, retval] ITRiASConnections **Conns);

	// @method HRESULT | ITRiASConnections | SetEventSink | Die <om .SetEventSink>- Methode erlaubt
	// dieses Objekt bei einem anderen Objekt, welches den Connectionpoint für das Interface 
	// <i ITRiASConnectionEvents> implementiert hat, anzumelden bzw. abzumelden.
	// @parm IUnknown * | Unk | Dieser Parameter muß einen Zeiger auf ein IUnknown-Interface des Objektes
	// sein, bei dem sich unser Objekt an- bzw. abmelden soll. 
	// @parm VARIANT_BOOL | fAdvise | Das Objekt wird angemeldet, wenn dieser Parameter den Wert
	// <cv VARIANT_TRUE> enthält, anderenfalls wird das Objekt abgemeldet.
	// @supby <o TRiASConnections> 
	// @xref <i ITRiASConnections>, <i ITRiASConnectionEvents>
		[id(104), helpstring("Zuordnen des Targetobjektes zur Eventbehandlung."), hidden, restricted] HRESULT SetEventSink ([in] IUnknown *Unk, [in] VARIANT_BOOL fAdvise);

		[id(105), helpstring("Remove an existing connection."), hidden] HRESULT RemoveConnection([in] ITRiASConnection *Connection);
	};

///////////////////////////////////////////////////////////////////////////////
// @doc INTERFACE TRIASDB
// @interface ITRiASConnection | Verbindung zu einer Datenquelle
// @group Methoden und Eigenschaften von <i ITRiASConnection> 
// @index | ICONNECTION
// @doc ICONNECTION
	[
		object,
		uuid(191A9AF4-37FE-11D1-96B6-00A024D6F582),
		dual,
		helpstring("ITRiASConnection Interface"),
		pointer_default(unique)
	]
	interface ITRiASConnection : ITRiASBase
	{
	cpp_quote("#if !defined(_CONNECTSTATUS_DEFINED)")
	cpp_quote("#define _CONNECTSTATUS_DEFINED")
	// @doc CONNECTENUMS 
	// @enum CONNECTSTATUS | Status in dem diese Verbindung sich befindet, d.h. ob die Verbindung 
	// derzeit geöffnet oder nicht geöffnet ist (Verbindung zu einer datenbank ist aktiv oder nicht).
	// @xref <i ITRiASConnection>, <op ITRiASConnection.Status>
		typedef [public, v1_enum, helpstring("Status der Verbindung.")]
		enum _tagCONNECTSTATUS {
			[helpstring("Verbindung ist nicht aktiv.")] 
				CONNECTSTATUS_Closed = 0,	// @emem Die Verbindung zu der Datenbank ist nicht aktiv.
				// Sämtliche Operationen, die Datenquelle betreffend schlagen fehl.
			[helpstring("Verbindung ist hergestellt (aktiv).")] 
				CONNECTSTATUS_Opened = 1,	// @emem Die Verbindung zu der Datenbank ist hergestellt.
		} CONNECTSTATUS;
	cpp_quote("#endif // _CONNECTSTATUS_DEFINED")

	cpp_quote("#if !defined(_CONNECTPARAM_DEFINED)")
	cpp_quote("#define _CONNECTPARAM_DEFINED")
	// @enum CONNECTPARAM | Zusätzliche Typinformationen zu einer Verbindung.
	// @xref <i ITRiASConnection>, <op ITRiASConnection.Param>
		typedef [public, v1_enum, helpstring("Typinformationen zu einer Verbindung.")]
		enum _tagCONNECTPARAM {
			[helpstring("Die Typinformationen zur angebundenen Datenbank sind unbekannt.")] 
				CONNECTPARAM_Unknown = 0,		// @emem Die Typinformationen zur angebundenen 
				// Datenbank sind unbekannt.
			[helpstring("Die angebundene Datenbank ist datei- oder verzeichnisbasiert.")] 
				CONNECTPARAM_FileOrDir = 1,		// @emem Die angebundene Datenbank ist 
				// datei- oder verzeichnisbasiert.
			[helpstring("Die angebundene Datenbank setzt sich aus mehreren Einzeldateien zusammen.")] 
				CONNECTPARAM_MultiFile = 2,		// @emem Die angebundene Datenbank setzt 
				// sich aus mehreren Einzeldateien zusammen
			[helpstring("Die angebundene Datenbank ist im Projekt enthalten.")] 
				CONNECTPARAM_Storage = 3,		// @emem Die angebundene Datenbank ist im 
				// Projekt enthalten.
			[helpstring("Die Datenbank ist über eine Verbindungszeichenkette angebundenen.")] 
				CONNECTPARAM_ConnectString = 4,	// @emem Die Datenbank ist über eine 
				// Verbindungszeichenkette angebundenen.
		} CONNECTPARAM;
	cpp_quote("#endif // _CONNECTPARAM_DEFINED")

	cpp_quote("#if !defined(_CONNECTMODE_DEFINED)")
	cpp_quote("#define _CONNECTMODE_DEFINED")
	// @enum CONNECTMODE | Mode, der vorgibt in welcher Form die Verbindung zu einer Datenbank 
	// hergestellt werden soll bzw. wie beim Trennen der Verbindung vorgegangen werden soll.
	// @xref <i ITRiASConnection>, <op ITRiASConnection.Mode>
		typedef [public, v1_enum, helpstring("Mode der zur Datenbank herzustellenden Verbindung.")]
		enum _tagCONNECTMODE {
			[helpstring("Verbindung soll schreibgeschützt hergestellt werden.")] 
				CONNECTMODE_UseDefaultMode = ~0,		// @emem Standardeinstellungen verwenden. 
				// Wird lediglich als Parameter für <om .Connect> bzw. <om .Disconnect> verwendet.
			[helpstring("Verbindung herstellen, wenn dies nach einem Load erforderlich ist.")]
				CONNECTMODE_ConnectAfterLoadIfApplicable = 0x8000,	// @emem Nachholen eines Aufrufes
				// der <om .Connect>- Methode der aus einem vorhergehenden Aufruf der 
				// <om IPersistStorage.Load>- Methode überfällig ist. (Use only if you exactly known
				// what you're doing!). Der dabei verwendete Wert für den <p rgMode> Parameter 
				// entspricht dem Wert <e .CONNECTMODE_UseDefaultMode>.

			[helpstring("Verbindung soll schreibgeschützt hergestellt werden.")] 
				CONNECTMODE_OpenReadOnly = 0,			// @emem Die Verbindung zu der Datenbank soll 
				// schreibgeschützt hergestellt werden.
			[helpstring("Verbindung soll mit Schreibrechten hergestellt werden.")] 
				CONNECTMODE_OpenReadWrite = 1,			// @emem Die Verbindung zu der Datenbank soll
				// möglichst mit Schreibrechten hergestellt werden. Die Verfahrensweise, 
				// die eingeschlagen werden soll, wenn dieser Versuch fehlschlägt wird durch 
				// die zusätzlichen Flags <e .CONNECTMODE_OpenNoResolution>, <e .CONNECTMODE_OpenUserResolves>
				// oder <e .CONNECTMODE_OpenAutoResolution> festgelegt.
			[helpstring("Datenquelle ist physisch schreibgeschützt.")] 
				CONNECTMODE_IsReadOnly = 2,			// @emem Die Datenquelle ist physisch schreibgeschützt.
			[helpstring("Zugriffskonflikte beim Verbinden als Fehler melden.")] 
				CONNECTMODE_OpenNoResolution = 0x0000,	// @emem Wenn die Verbindung nicht mit 
				// Schreibrechten hergestellt werden kann, obwohl das gewünscht war, wird ein 
				// Fehler gemeldet.
			[helpstring("Zugriffskonflikte beim Verbinden interaktiv lösen.")] 
				CONNECTMODE_OpenUserResolves = 0x0100,	// @emem Wenn die Verbindung nicht mit 
				// Schreibrechten hergestellt werden kann, obwohl das gewünscht war, wird der 
				// Nutzer interaktiv gefragt, ob die Verbindung mit Schreibschutz hergestellt 
				// werden soll. In diesem Fall wird die Verbindung hergstellt, als ob 
				// <e .CONNECTMODE_OpenReadOnly> gegeben gewesen wäre.
			[helpstring("Zugriffskonflikte beim Verbinden automatisch lösen.")] 
				CONNECTMODE_OpenAutoResolution = 0x0200,	// @emem Wenn die Verbindung nicht mit 
				// Schreibrechten hergestellt werden kann, obwohl das gewünscht war, wird die 
				// Verbindung automatisch ohne weitere Rückfragen schreibgeschützt hergestellt.

			[helpstring("Maske für OpenFlags beim Verbinden.")]
				CONNECTMODE_OpenFlags = 0x0001,				// @emem Maske für OpenFlags beim Verbinden
			[helpstring("Maske für zusätzliche Flags beim Verbinden.")]
				CONNECTMODE_OpenResolutionFlags = 0x0300,	// @emem Maske für alle zusätzliche Flags 
				// beim Verbinden

			[helpstring("Bei Bedarf beim Trennen der Verbindung nicht nachfragen, ob gespeichert werden soll.")]
				CONNECTMODE_CloseNoResolution = 0x0000,	// @emem Beim Trennen der Verbindung nicht auswerten,
				// ob gespeichert werden sollte. Eventuelle Änderungen am Datenbestand der Datenquelle gehen verloren.
			[helpstring("Bei Bedarf beim Trennen der Verbindung interaktiv nachfragen, ob gespeichert werden soll.")]
				CONNECTMODE_CloseUserResolves = 0x1000,	// @emem Beim Trennen der Verbindung auswerten, ob
				// gespeichert werden sollte und ggf. interaktiv nachfragen, ob gespeichert werden soll bzw.
				// neuen Namen der Datenbank abfragen. 
			[helpstring("Bei Bedarf vor dem Trennen der Verbindung automatisch speichern.")]
				CONNECTMODE_CloseAutoResolution = 0x2000,	// @emem Beim Trennen der Verbindung auswerten,
				// ob gespeichert werden sollte und ggf. automatisch speichern. Wird ein neuer Datenbank-Name 
				// benötigt, weil z.B. die Datenquelle als Kopie geöffnet worden ist und Änderungenen an der
				// Kopie vorgenommen wurden, so wird ein Fehler gemeldet.

			[helpstring("Maske für zusätzliche Flags beim Trennen der Verbindung.")]
				CONNECTMODE_CloseResolutionFlags = 0x3000,		// @emem Maske für zusätzliche Flags 
				// beim Trennen der Verbindung
			[helpstring("Maske für alle zusätzliche Flags.")]	
				CONNECTMODE_ResolutionFlags = CONNECTMODE_OpenResolutionFlags|CONNECTMODE_CloseResolutionFlags,	// @emem 
				// Maske für alle zusätzliche Flags

		// internen Askmode vor der Aktion zurücksetzen
			[hidden] CONNECTMODE_ResetConnectAskMode = 0x0400,
			[hidden] CONNECTMODE_ResetDisconnectAskMode = 0x4000,
			[hidden] CONNECTMODE_ResetAskMode = CONNECTMODE_ResetConnectAskMode|CONNECTMODE_ResetDisconnectAskMode,

		} CONNECTMODE;
	cpp_quote("#endif // _CONNECTMODE_DEFINED")

	// @doc ICONNECTION
	// @property BSTR | ITRiASConnection | Name | Die <op .Name>- Eigenschaft setzt bzw. liefert
	// den Bezeichner dieser Datenquelle.
	// @supby <o TRiASConnection> 
	// @xref <i ITRiASConnection>
		[propget, id(DISPID_DEFAULT), helpstring("Liefert den Namen der Connection.")] HRESULT Name([out, retval] BSTR *pVal);
		[propput, id(DISPID_DEFAULT), helpstring("Setzt den Namen der Connection.")] HRESULT Name([in] BSTR newVal);

	// @property BSTR | ITRiASConnection | Description | Die <op .Description>- Eigenschaft setzt 
	// bzw. liefert die zusätzliche Beschreibungsinfo zu dieser Datenquelle
	// @supby <o TRiASConnection> 
	// @xref <i ITRiASConnection>
		[propget, id(4), helpstring("Liefert zusätzliche Beschreibungsinfos zu dieser Connection.")] HRESULT Description([out, retval] BSTR *pVal);
		[propput, id(4), helpstring("Setzt zusätzliche Beschreibungsinfos zu dieser Connection.")] HRESULT Description([in] BSTR newVal);

	// @property BSTR | ITRiASConnection | ConnectInfo | Die <op .ConnectInfo>- Eigenschaft setzt 
	// bzw. liefert die ConnectInfo dieser Datenquelle. 
	// @comm Die ConnectInfo ist die Zeichenkette, die beim Aufruf der 
	// <om ITRiASDatabase.OpenDatasource>- Methode als <p Source>- Parameter übergeben wird.
	// @supby <o TRiASConnection> 
	// @xref <i ITRiASConnection>, <om ITRiASDatabase.OpenDatasource>
		[propget, id(5), helpstring("Liefert die ConnectInfo dieser Connection.")] HRESULT ConnectInfo([out, retval] BSTR *pVal);
		[propput, id(5), helpstring("Setzt die ConnectInfo dieser Connection.")] HRESULT ConnectInfo([in] BSTR newVal);

	// @property CONNECTSTATUS | ITRiASConnection | Status | Die <op .Status>- Eigenschaft liefert,
	// die Verbindung zur angebundenen Datenbank geöffnet oder nicht geöffnet ist (readonly).
	// @comm Die Eigenschaft <op .Status> kann nicht gesetzt werden.
	// @supby <o TRiASConnection> 
	// @xref <i ITRiASConnection>, <t CONNECTSTATUS>
		[propget, id(6), helpstring("Liefert, ob die Connection geöffnet ist oder nicht (CONNECTSTATUS).")] HRESULT Status([out, retval] CONNECTSTATUS *pVal);

	// @property CONNECTMODE | ITRiASConnection | Param | Die <op .Param>- Eigenschaft liefert zusätzliche
	// Typinformationen zu dieser Verbindung zu einer Datenquelle.
	// @supby <o TRiASConnection> 
	// @xref <i ITRiASConnection>, <t CONNECTPARAM>
		[propget, id(7), helpstring("Liefert zusätzliche Typinformationen über die Verbindung (CONNECTPARAM).")] HRESULT Param([out, retval] CONNECTPARAM *pVal);

	// @property CONNECTMODE | ITRiASConnection | Mode | Die <op .Mode>- Eigenschaft setzt 
	// bzw. liefert den Mode, in dem die Verbindung zur angebundenen Datenbank 
	// hergestellt/getrennt werden soll,
	// @supby <o TRiASConnection> 
	// @xref <i ITRiASConnection>, <t CONNECTMODE>
		[propget, id(8), helpstring("Liefert den Mode, in dem die Verbindung hergestellt/getrennt werden soll (CONNECTMODE).")] HRESULT Mode([out, retval] CONNECTMODE *pVal);
		[propput, id(8), helpstring("Setzt den Mode, in dem die Verbindung hergestellt/getrennt werden soll (CONNECTMODE).")] HRESULT Mode([in] CONNECTMODE newVal);

	// @property BSTR | ITRiASConnection | Type | Die <op .Type>- Eigenschaft setzt 
	// bzw. liefert den Typ der angebundenen Datenbank.
	// @comm Der Typ der angebundenen Datenbank ist der ProgID des zu dieser Datenbank gehörenden
	// <o TRiASDatabase>- Objektes. Dieser kann verwendet werden, um eine Instanz dieses
	// Objektes zu erzeugen.
	// @supby <o TRiASConnection> 
	// @xref <i ITRiASConnection>, <o TRiASDatabase>
		[propget, id(9), helpstring("Liefert den Typ der angebundenen Datenbank.")] HRESULT Type([out, retval] BSTR *pVal);
		[propput, id(9), helpstring("Setzt den Typ der angebundenen Datenbank.")] HRESULT Type([in] BSTR newVal);

	// @property BSTR | ITRiASConnection | Location | Die <op .Location>- Eigenschaft setzt 
	// bzw. liefert den Dateinamen der angebundenen Datenbank.
	// @comm Die <op .Location>- Eigenschaft kann nur solange modifiziert werden, wie die Verbindung
	// zur angebundenen Datenbank _nicht_ hergestellt ist, d.h. die <op .Status>- Eigenschaft den 
	// Wert <e CONNECTSTATUS.CONNECTSTATUS_Closed> liefert.
	// @supby <o TRiASConnection> 
	// @xref <i ITRiASConnection>, <t CONNECTSTATUS>
		[propget, id(10), helpstring("Liefert den Dateinamen der angebundenen Datenbank.")] HRESULT Location([out, retval] BSTR *pVal);
		[propput, id(10), helpstring("Setzt den Dateinamen der angebundenen Datenbank.")] HRESULT Location([in] BSTR newVal);

	// @property IUnknown * | ITRiASConnection | Locations | Die <op .Locations>- Eigenschaft setzt 
	// bzw. liefert die Dateinamen der angebundenen Datenbank.
	// @comm Hinter dem IUnknown verbirgt sich ein <i IEnumString>
	// @comm Die <op .Locations>- Eigenschaft kann nur solange modifiziert werden, wie die Verbindung
	// zur angebundenen Datenbank _nicht_ hergestellt ist, d.h. die <op .Status>- Eigenschaft den 
	// Wert <e CONNECTSTATUS.CONNECTSTATUS_Closed> liefert.
	// @supby <o TRiASConnection> 
	// @xref <i ITRiASConnection>, <t CONNECTSTATUS>
		[propget, id(11), helpstring("Liefert die Dateinamen der angebundenen Datenbank.")] HRESULT Locations([out, retval] IUnknown **pVal);
		[propput, id(11), helpstring("Setzt die Dateinamen der angebundenen Datenbank.")] HRESULT Locations([in] IUnknown *newVal);

	// @property <i ITRiASDatabase> * | ITRiASConnection | Database | Die <op .Database>- Eigenschaft 
	// liefert die angebundene Datenbank (readonly).
	// @comm Die Eigenschaft <op .Database> kann nicht gesetzt werden.
	// @supby <o TRiASConnection> 
	// @xref <i ITRiASConnection>, <i ITRiASDatabase>
		[propget, id(12), helpstring("Liefert die angebundene Datenbank.")] HRESULT Database([out, retval] ITRiASDatabase **pVal);

	// @property VARIANT_BOOL | ITRiASConnection | Updatable | Die <op .Updatable>- Eigenschaft liefert,
	// ob die angebundenen Datenbank beschreibbar ist (nicht schreibgeschützt).
	// @comm Die Eigenschaft <op .Updatable> kann nicht gesetzt werden (readonly).
	// @supby <o TRiASConnection> 
	// @xref <i ITRiASConnection>
		[propget, id(13), helpstring("Liefert, ob die angebundenen Datenbank beschreibbar ist (nicht schreibgeschützt).")] HRESULT Updatable([out, retval] VARIANT_BOOL *pVal);

	// @property VARIANT_BOOL | ITRiASConnection | SchemaUpdatable | Die <op .SchemaUpdatable>- Status liefert,
	// ob die Struktur der angebundenen Datenbank modifiziert werden kann (readonly).
	// @comm Die Eigenschaft <op .SchemaUpdatable> kann nicht gesetzt werden.
	// @supby <o TRiASConnection> 
	// @xref <i ITRiASConnection>
		[propget, id(14), helpstring("Liefert, ob die Struktur der angebundenen Datenbank modifiziert werden kann.")] HRESULT SchemaUpdatable([out, retval] VARIANT_BOOL *pVal);

	// @property VARIANT_BOOL | ITRiASConnection | Transactions | Die <op .Transactions>- Status liefert,
	// ob die angebundene Datenbank Transaktionen unterstützt.
	// @comm Die Eigenschaft <op .Transactions> kann nicht gesetzt werden.
	// @supby <o TRiASConnection> 
	// @xref <i ITRiASConnection>
		[propget, id(15), helpstring("Liefert, ob die angebundene Datenbank Transaktionen unterstützt.")] HRESULT Transactions([out, retval] VARIANT_BOOL *pVal);

	// @property BSTR | ITRiASConnection | Version | Die <op .Version>- Eigenschaft liefert die
	// Version der angebundenen Datenbank als Zeichenkette (readonly).
	// @comm Die Eigenschaft <op .Version> kann nicht gesetzt werden. 
	// @comm Der Wert, der durch die <op .Version>- Eigenschaft geliefert wird, ist im Gegensatz zur
	// <op. VersionLong>- Eigenschaft für die Benutzung im Nutzerinterface bestimmt.
	// @supby <o TRiASConnection> 
	// @xref <i ITRiASConnection>, <op ITRiASConnection.VersionLong>
		[propget, id(16), helpstring("Liefert die Version der angebundenen Datenbank.")] HRESULT Version([out, retval] BSTR *pVal);

	// @property LONG | ITRiASConnection | VersionLong | Die <op .VersionLong>- Status liefert,
	// die Verbindung zur angebundenen Datenbank geöffnet oder nicht geöffnet ist (readonly).
	// @comm Die Eigenschaft <op .VersionLong> kann nicht gesetzt werden.
	// @comm Der Wert, der durch die <op .VersionLong>- Eigenschaft geliefert wird, ist im Gegensatz zur
	// <op. Version>- Eigenschaft für die programminterne Benutzung bestimmt.
	// @supby <o TRiASConnection> 
	// @xref <i ITRiASConnection>, <op ITRiASConnection.Version>
		[propget, id(17), restricted, hidden, helpstring("Liefert die Versionsnummer der angebundenen Datenbank.")] HRESULT VersionLong([out, retval] LONG *pVal);

	// @property LONG | ITRiASConnection | GuidPath | Die <op .GuidPath>- Status liefert
	// einen Guid als Zeichenkette, der diese Connection eindeutig über ihrer gesamten Lebensdauer 
	// begleitet (readonly).
	// @comm Die Eigenschaft <op .GuidPath> kann nicht gesetzt werden.
	// @comm Der Wert, der durch die <op .GuidPath>- Eigenschaft geliefert wird, ist im Gegensatz zur
	// <op. Name>- Eigenschaft unveränderlich, selbst wenn unter einem anderen Namen gespeichert wird.
	// @supby <o TRiASConnection> 
	// @xref <i ITRiASConnection>, <op ITRiASConnection.Name>
		[propget, id(18), helpstring("Liefert einen eindeutigen Guid als Zeichenkette.")] HRESULT GuidPath([out, retval] BSTR *pVal);

	// @method HRESULT | ITRiASConnection | Connect | Die <om .Connect>- Methode öffnet die Verbindung 
	// zur Datenbank entsprechend den eingestellten Parametern.
	// @parm CONNECTMODE | Mode | Dieser Parameter erlaubt es, den zu verwendenden Mode für die 
	// Herstellung der Verbindung vorzugeben. Besitzt dieser Parameter den Wert 
	// <e CONNECTMODE.CONNECTMODE_UseDefaultMode>, so wird der über die <op .Mode>- Eigenschaft 
	// voreingestellte Wert verwendet.
	// @comm Wenn die zugehörige Datenbank nicht schreibgeschützt geöffnet werden soll und
	// ein Zugriffskonflikt auftritt weil die Datenbank bereits mit Schreibrechten geöffnet ist, 
	// bzw. die Datenbank selbst schreibgeschützt ist, dann wird interaktiv abgefragt, ob die
	// Datenbank evtl. mit schreibschutz geöffnet werden soll.
	// @supby <o TRiASConnection> 
	// @xref <i ITRiASConnection>, <t CONNECTMODE>, <op ITRiASConnection.Mode>
	// @end
		[id(100), helpstring("Stellt die Verbindung zu einer Datenbank entsprechend den eingestellten Parametern her.")] HRESULT Connect([in /*, optional*/, defaultvalue(CONNECTMODE_UseDefaultMode)] CONNECTMODE rgMode);

	// @method HRESULT | ITRiASConnection | Disconnect | Die <om .Disconnect>- Methode trennt die Verbindung 
	// zur Datenbank entsprechend den eingestellten Parametern.
	// @parm CONNECTMODE | Mode | Dieser Parameter erlaubt es, den zu verwendenden Mode für das
	// Trennen der Verbindung vorzugeben. Besitzt dieser Parameter den Wert 
	// <e CONNECTMODE.CONNECTMODE_UseDefaultMode>, so wird der über die <op .Mode>- Eigenschaft 
	// voreingestellte Wert verwendet.
	// @supby <o TRiASConnection> 
	// @xref <i ITRiASConnection>, <t CONNECTMODE>, <op ITRiASConnection.Mode>
	// @end
		[id(101), helpstring("Trennt die Verbindung zur angebundenen Datenbank.")] HRESULT Disconnect([in /*, optional*/, defaultvalue(CONNECTMODE_UseDefaultMode)] CONNECTMODE rgMode);

	// @method HRESULT | ITRiASConnection | Remove | Die <om .Remove>- Methode wird gerufen,
	// wenn die Datenquelle aus dem aktuellen Projekt entfernt werden soll.
	// @comm Insbesondere bei Datenquellen, die in der Projektdatei gespeichert sind, ist die
	// <om .Remove>- Methode zu rufen, da in diesem Fall der Speicherplatz innerhalb der Datei wieder
	// freigegeben werden kann.
	// @supby <o TRiASConnection> 
	// @xref <i ITRiASConnection>
	// @end
		[id(102), helpstring("Trennt die Verbindung zur angebundenen Datenbank.")] HRESULT Remove();

	// @method HRESULT | ITRiASConnection | SaveConnectedDatabase | Die <om .SaveConnectedDatabase>- Methode
	// speichert die angehängte Datenquelle (Commit) 
	// @supby <o TRiASConnection> 
	// @xref <i ITRiASConnection>
	// @end
		[id(103), helpstring("Speichern der zugehörigen Datenquelle.")] HRESULT SaveConnectedDatabase([in] CONNECTMODE Mode);

	// @method HRESULT | ITRiASConnection | SaveAsConnectedDatabase | Die <om .SaveAsConnectedDatabase>- Methode
	// speichert die angehängte Datenquelle unter einem anderen Namen.
	// @supby <o TRiASConnection> 
	// @xref <i ITRiASConnection>
	// @end
		[id(104), helpstring("Speichern der zugehörigen Datenquelle unter einem anderen Namen.")] HRESULT SaveAsConnectedDatabase([in] CONNECTMODE Mode);
	};

///////////////////////////////////////////////////////////////////////////////
// @doc INTERFACE TRIASDB
// @interface ITRiASRefreshChangesCallback | Das Interface <i ITRiASRefreshChangesCallback> 
// wird bei der Abarbeitung von Veränderungen in einer Datenbank an Hand des
// ModifikationsLogs verwendet. 
// @group Methoden und Eigenschaften von <i ITRiASRefreshChangesCallback> 
// @index | ITRIASREFRESHCHANGESCALLBACK
// @doc ITRIASREFRESHCHANGESCALLBACK
	[
		object,
		uuid(4A4E2AB2-9212-443E-A3A8-4251E6D70D58),
		dual,
		helpstring("ITRiASRefreshChangesCallback Interface"),
		pointer_default(unique)
	]
	interface ITRiASRefreshChangesCallback : IDispatch
	{

	};

///////////////////////////////////////////////////////////////////////////////
// @doc INTERFACE TRIASDB
// @interface ITRiASDatabase | Das Interface <i ITRiASDatabase> dient der Verwaltung
// einer TRiASDB-Datenbank, die über einen TRiASDB-DataServer angesprochen wird. 
// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>
// @group Methoden und Eigenschaften von <i ITRiASDatabase> 
// @index | IDATABASE
// @doc IDATABASE
	[
		object,
		uuid(6ACC24A3-3969-11D1-96B8-00A024D6F582),
		dual,
		helpstring("ITRiASDatabase Interface"),
		pointer_default(unique)
	]
	interface ITRiASDatabase : ITRiASBase
	{
	cpp_quote("#if !defined(_RELOADDATABASE_DEFINED)")
	cpp_quote("#define _RELOADDATABASE_DEFINED")
	// @doc RELOADDATABASE
	// @enum RELOADDATABASE | Definiert den neu einzulesenden Datenbank-Parameter
	// @xref <i ITRiASDatabase>, <om ITRiASDatabase.ReLoad>
		typedef [public, v1_enum, helpstring("Neu einzulesender Datenbank-Parameter")] 
		enum _tagRELOADDATABASE {
		[helpstring("Umschließendes Rechteck neu einlesen.")] 
			RELOADDATABASE_Envelope = 1,						// @emem Umschließendes Rechteck neu einlesen
		[helpstring("Umschließendes Rechteck neu einlesen.")] 
			RELOADDATABASE_Objects = 2,							// @emem Objektklassen neu einlesen
		[helpstring("Aktuelles Lookupwindow zurücksetzen.")] 
			RELOADDATABASE_ResetLookupWindow = 4,				// @emem Aktuelles Lookupwindow zurücksetzen
		[helpstring("Objekteigenschaften neu einlesen.")] 
			RELOADDATABASE_Features = 8,						// @emem Objekteigenschaften neu einlesen
		[helpstring("Objekteigenschaften sicherstellen.")] 
			RELOADDATABASE_EnsureFeatures = 0x100,				// @emem Objekteigenschaften sicherstellen
		[helpstring("Alles neu einlesen.")] 
			RELOADDATABASE_All = 0x0f,							// @emem Alles neu einlesen

		// sonstige Notifikationen			
		[helpstring("Connection wurde (neu) initialisiert.")] 
			RELOADDATABASE_ConnectionInitialized = 0x10,		// @emem Connection wurde (neu) initialisiert
		} RELOADDATABASE;
	cpp_quote("#endif // _RELOADDATABASE_DEFINED")

	cpp_quote("#if !defined(_DATABASESTORAGEMODE_DEFINED)")
	cpp_quote("#define _DATABASESTORAGEMODE_DEFINED")
	// @doc DATABASESTORAGEMODE
	// @enum DATABASESTORAGEMODE | Definiert den Speichertyp einer Datenbank
	// @xref <i ITRiASDatabase>, <om ITRiASDatabase.StorageMode>
		typedef [public, v1_enum, helpstring("Speichertyp einer Datenbank")] 
		enum _tagDATABASESTORAGEMODE {
			[helpstring("Unbekannter Speichertyp.")] 
				DATABASESTORAGEMODE_Unknown = 0,		// @emem Unbekannter Speichertyp
			[helpstring("Datenbank ist dateibasiert (eine Datei).")] 
				DATABASESTORAGEMODE_FileBased = 1,		// @emem Datenbank ist dateibasiert (eine Datei)
			[helpstring("Datenbank ist dateibasiert (mehrere Dateien).")] 
				DATABASESTORAGEMODE_MultiFileBased = 2,		// @emem Datenbank ist dateibasiert (mehrere Dateien)
			[helpstring("Datenbank ist verzeichnisbasiert.")] 
				DATABASESTORAGEMODE_DirectoryBased = 3,		// @emem Datenbank ist verzeichnisbasiert
			[helpstring("Datenbank ist storagebasiert.")] 
				DATABASESTORAGEMODE_StorageBased = 4,		// @emem Datenbank ist storagebasiert (wird gemeinsam mit 
					// der Projektdatei gespeichert
			[helpstring("Datenbank ist hauptspeicherbasiert.")] 
				DATABASESTORAGEMODE_MemoryBased = 5,		// @emem Datenbank ist hauptspeicherbasiert 
			[helpstring("Datenbank basiert auf sonstigen Verbindungsinformationen.")] 
				DATABASESTORAGEMODE_ConnectStringBased = 6,		// @emem Datenbank basiert auf sonstigen Verbindungsinformationen
		} DATABASESTORAGEMODE;
	cpp_quote("#endif // _DATABASESTORAGEMODE_DEFINED")

	// @doc IDATABASE
	// @property LONG | ITRiASDatabase | VersionLong | Die <op .VersionLong>- Eigenschaft liefert die 
	// vollständige Versionsnummer dieser Datenbank (readonly).
	// @comm Die Eigenschaft <op .VersionLong> kann nicht gesetzt werden.
	// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>
	// @xref <om GDatabase.Version>, <i ITRiASDatabase>
		[propget, id(3), helpstring("Liefert die Versionsnummer dieser Datenbank.")] HRESULT VersionLong([out, retval] LONG *pVal);

	// @property LONG | ITRiASDatabase | Handle | Die <op .Handle>- Eigenschaft liefert eine
	// eindeutige Zugriffsnummer für diese Datenbank (readonly).
	// @comm Die Eigenschaft <op .Handle> kann nicht gesetzt werden.
	// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>
	// @xref <i ITRiASDatabase>
		[propget, id(4), helpstring("Liefert eine eindeutige Zugriffsnummer für diese Datenbank."), hidden, restricted] HRESULT Handle([out, retval] INT_PTR *pVal);

	// @property VARIANT_BOOL | ITRiASDatabase | IsDirty | Die <op .IsDirty>- Eigenschaft erlaubt die
	// Abfrage und Vorgabe, ob diese Datenbank derzeit gespeichert werden muß (ob die Datenbank 
	// geändert worden ist) oder nicht.
	// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>
	// @xref <i ITRiASDatabase>
		[propget, id(5), helpstring("Liefert, ob diese Datenbank gespeichert werden muß.")] HRESULT IsDirty([out, retval] VARIANT_BOOL *pVal);
		[propput, id(5), helpstring("Setzt, ob diese Datenbank gespeichert werden muß.")] HRESULT IsDirty([in] VARIANT_BOOL newVal);

	// @property VARIANT_BOOL | ITRiASDatabase | OpenedAsCopy | Die <op .OpenedAsCopy>- Eigenschaft gibt
	// an, ob die Datenbank beim Öffnen kopiert wurde, um Zugriffskonflikte oder Zugriffsrechts-Konflikte
	// zu lösen. 
	// @comm Diese Eigenschaft darf nur dann den Wert '<cv True>' haben, wenn gleichzeitig die Methoden
	// <om .Save>, <om .SaveAs> sowie die Eigenschaft <op .CouldOpenTarget> unterstützt werden.
	// @comm Die Eigenschaft <op .OpenedAsCopy> kann nicht gesetzt werden.
	// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>
	// @xref <i ITRiASDatabase>
		[propget, id(6), helpstring("Liefert, ob diese Datenbank als Kopie geöffnet worden ist.")] HRESULT OpenedAsCopy([out, retval] VARIANT_BOOL *pVal);

	// @property VARIANT_BOOL | ITRiASDatabase | CouldOpenTarget | Die <op .CouldOpenTarget>- Eigenschaft
	// gibt an, ob beim Öffnen der Ausgangs-Datenbank, die ihrerseits beim Öffnen kopiert worden ist, 
	// um einen Zugriffskonflikt bzw. Zugriffsrechtskonflikt zu lösen, immer noch eben dieser
	// Zugriffs- bzw. Zugriffsrechts-Konflikt auftreten würde.
	// @comm Diese Eigenschaft wird lediglich dann sinnvolle Ergebnisse liefern, wenn die 
	// OpenedAsCopy-Eigenschaft den Wert '<cv True>' besitzt. 
	// @comm Die Eigenschaft <op .CouldOpenTarget> kann nicht gesetzt werden.
	// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>
	// @xref <i ITRiASDatabase>
		[propget, id(7), helpstring("Liefert ob die Bezugsdatenbank jetzt ohne Konflikte geöffnet werden könnte.")] HRESULT CouldOpenTarget([out, retval] VARIANT_BOOL *pVal);

	// @property VARIANT_BOOL | ITRiASDatabase | SchemaUpdatable | Die <op .SchemaUpdatable>- Eigenschaft gibt an, 
	// ob Veränderungen der Tabellendefinitionen der Datanbank (Schema) zulässig sind. Wenn diese 
	// Eigenschaft den Wert '<cv True>' hat, sind Veränderungen des Schemas zulässig.
	// @comm Die Eigenschaft <op .SchemaUpdateable> kann nicht gesetzt werden.
	// @supby <o TRiASDatabase>, <c TRiASCompatibleDatabase>
	// @xref <i ITRiASDatabase>
	// @end
		[propget, id(8), helpstring("Liefert ob Veränderungen der Tabellendefinitionen der Datenbank zulässig sind.")] HRESULT SchemaUpdatable([out, retval] VARIANT_BOOL *pVal);

	// @property BSTR | ITRiASDatabase | Name | Die <op .Name>- Eigenschaft liefert eine Zeichenfolge 
	// mit dem Pfad und Dateinamen der Datenbank. 
	// @comm Die Eigenschaft <op .Name> kann nicht gesetzt werden.
	// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>
	// @xref <i ITRiASDatabase>
		[propget, id(DISPID_DEFAULT), helpstring("Liefert den Dateinamen der Datenbank.")] HRESULT Name([out, retval] BSTR *pVal);

	// @property BSTR | ITRiASDatabase | Version | Mit der <op .Version>- Eigenschaft wird die Versionsnummer 
	// der Datenbank ausgegeben.
	// @comm Die Eigenschaft <op .Version> kann nicht gesetzt werden.
	// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>
	// @xref <i ITRiASDatabase>
		[propget, id(10), helpstring("Liefert die Versionsnummer der Datenbank als Zeichenkette.")] HRESULT Version([out, retval] BSTR *pVal);

cpp_quote("#if !defined(_lint)")
	// @property LONG | ITRiASDatabase | CollatingOrder | Die <op .CollatingOrder>- Eigenschaft gibt die 
	// Sortierreihenfolge zurück, die beim Vergleich oder bei der Sortierung von Zeichenfolgen 
	// zur Anwendung kommt.
	// @comm Die Eigenschaft <op .CollatingOrder> kann nicht gesetzt werden.
	// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>
	// @xref <i ITRiASDatabase>
	// @group Folgende Werte für die Sortierreihenfolge werden unterstützt.
	// @index | COLLATEORDER
	// @doc COLLATEORDER
	// @constv long | COLLATEORDER_Neutral | 1024 | Sortierreihenfolge: neutral
	// @xref <op ITRiASDatabase.CollatingOrder>
        [helpstring("CollatingOrder (Database, Field)")] const long COLLATEORDER_Neutral = 1024;

	// @constv long | COLLATEORDER_Arabic | 1025 | Sortierreihenfolge: arabisch
	// @xref <op ITRiASDatabase.CollatingOrder>
        [helpstring("CollatingOrder (Database, Field)")] const long COLLATEORDER_Arabic = 1025;

	// @constv long | COLLATEORDER_Cyrillic | 1049 | Sortierreihenfolge: cyrillisch
	// @xref <op ITRiASDatabase.CollatingOrder>
        [helpstring("CollatingOrder (Database, Field)")] const long COLLATEORDER_Cyrillic = 1049;

	// @constv long | COLLATEORDER_Czech | 1029 | Sortierreihenfolge: tschechisch
	// @xref <op ITRiASDatabase.CollatingOrder>
        [helpstring("CollatingOrder (Database, Field)")] const long COLLATEORDER_Czech = 1029;

	// @constv long | COLLATEORDER_Dutch | 1043 | Sortierreihenfolge: dänisch
	// @xref <op ITRiASDatabase.CollatingOrder>
        [helpstring("CollatingOrder (Database, Field)")] const long COLLATEORDER_Dutch = 1043;

	// @constv long | COLLATEORDER_General | 1033 | Sortierreihenfolge: international
	// @xref <op ITRiASDatabase.CollatingOrder>
        [helpstring("CollatingOrder (Database, Field)")] const long COLLATEORDER_General = 1033;

	// @constv long | COLLATEORDER_Greek | 1032 | Sortierreihenfolge: griechisch
	// @xref <op ITRiASDatabase.CollatingOrder>
        [helpstring("CollatingOrder (Database, Field)")] const long COLLATEORDER_Greek = 1032;

	// @constv long | COLLATEORDER_Hebrew | 1037 | Sortierreihenfolge: hebräisch
	// @xref <op ITRiASDatabase.CollatingOrder>
        [helpstring("CollatingOrder (Database, Field)")] const long COLLATEORDER_Hebrew = 1037;

	// @constv long | COLLATEORDER_Hungarian | 1038 | Sortierreihenfolge: ungarisch
	// @xref <op ITRiASDatabase.CollatingOrder>
        [helpstring("CollatingOrder (Database, Field)")] const long COLLATEORDER_Hungarian = 1038;

	// @constv long | COLLATEORDER_Icelandic | 1039 | Sortierreihenfolge: isländisch
	// @xref <op ITRiASDatabase.CollatingOrder>
        [helpstring("CollatingOrder (Database, Field)")] const long COLLATEORDER_Icelandic = 1039;

	// @constv long | COLLATEORDER_Norwdan | 1030 | Sortierreihenfolge: norwegisch
	// @xref <op ITRiASDatabase.CollatingOrder>
        [helpstring("CollatingOrder (Database, Field)")] const long COLLATEORDER_Norwdan = 1030;

	// @constv long | COLLATEORDER_PDXIntl | 1033 | Sortierreihenfolge: international
	// @xref <op ITRiASDatabase.CollatingOrder>
        [helpstring("CollatingOrder (Database, Field)")] const long COLLATEORDER_PDXIntl = 1033;

	// @constv long | COLLATEORDER_PDXNor | 1030 | Sortierreihenfolge: norwegisch
	// @xref <op ITRiASDatabase.CollatingOrder>
        [helpstring("CollatingOrder (Database, Field)")] const long COLLATEORDER_PDXNor = 1030;

	// @constv long | COLLATEORDER_PDXSwe | 1053 | Sortierreihenfolge: schwedisch
	// @xref <op ITRiASDatabase.CollatingOrder>
        [helpstring("CollatingOrder (Database, Field)")] const long COLLATEORDER_PDXSwe = 1053;

	// @constv long | COLLATEORDER_Polish | 1045 | Sortierreihenfolge: polnisch
	// @xref <op ITRiASDatabase.CollatingOrder>
        [helpstring("CollatingOrder (Database, Field)")] const long COLLATEORDER_Polish = 1045;

	// @constv long | COLLATEORDER_Spanish | 1034 | Sortierreihenfolge: spanisch
	// @xref <op ITRiASDatabase.CollatingOrder>
        [helpstring("CollatingOrder (Database, Field)")] const long COLLATEORDER_Spanish = 1034;

	// @constv long | COLLATEORDER_SwedFin | 1053 | Sortierreihenfolge: schwedisch
	// @xref <op ITRiASDatabase.CollatingOrder>
        [helpstring("CollatingOrder (Database, Field)")] const long COLLATEORDER_SwedFin = 1053;

	// @constv long | COLLATEORDER_Turkish | 1055 | Sortierreihenfolge: türkisch
	// @xref <op ITRiASDatabase.CollatingOrder>
        [helpstring("CollatingOrder (Database, Field)")] const long COLLATEORDER_Turkish = 1055;

	// @constv long | COLLATEORDER_Japanese | 1041 | Sortierreihenfolge: japanisch
	// @xref <op ITRiASDatabase.CollatingOrder>
        [helpstring("CollatingOrder (Database, Field)")] const long COLLATEORDER_Japanese = 1041;

	// @constv long | COLLATEORDER_ChineseSimplified | 2052 | Sortierreihenfolge: chinesisch vereinfacht
	// @xref <op ITRiASDatabase.CollatingOrder>
        [helpstring("CollatingOrder (Database, Field)")] const long COLLATEORDER_ChineseSimplified = 2052;

	// @constv long | COLLATEORDER_ChineseTraditional | 1028 | Sortierreihenfolge: chinesisch traditionell
	// @xref <op ITRiASDatabase.CollatingOrder>
        [helpstring("CollatingOrder (Database, Field)")] const long COLLATEORDER_ChineseTraditional = 1028;

	// @constv long | COLLATEORDER_Korean | 1036 | Sortierreihenfolge: koreanisch
	// @xref <op ITRiASDatabase.CollatingOrder>
        [helpstring("CollatingOrder (Database, Field)")] const long COLLATEORDER_Korean = 1036;

	// @constv long | COLLATEORDER_Thai | 4126 | Sortierreihenfolge: thai
	// @xref <op ITRiASDatabase.CollatingOrder>
        [helpstring("CollatingOrder (Database, Field)")] const long COLLATEORDER_Thai = 4126;

	// @constv long | COLLATEORDER_Undefined | -1 | Sortierreihenfolge: nicht definiert
	// @xref <op ITRiASDatabase.CollatingOrder>
        [helpstring("CollatingOrder (Database, Field)")] const long COLLATEORDER_Undefined = -1;
cpp_quote("#endif // !defined(_lint)")
	// @doc IDATABASE
		[propget, id(11), helpstring("Liefert die Sortierreihenfolge von Zeichenketten in dieser Datenbank.")] HRESULT CollatingOrder([out, retval] long *pVal);

	// @property BSTR | ITRiASDatabase | Connect | Die <op .Connect>- Eigenschaft liefert Informationen, 
	// die mit dem <p Source>- Argument der <om .OpenDatabase> -Methode gespeichert wurden.
	// @comm Die Eigenschaft <op .Connect> kann nicht gesetzt werden.
	// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>
	// @xref <i ITRiASDatabase>
		[propget, id(12), helpstring("Liefert die Zeichenkette, die bei Opendatabase als Source übergeben wurde.")] HRESULT Connect([out, retval] BSTR *pVal);

	// @property VARIANT_BOOL | ITRiASDatabase | Transactions | Die <op .Transactions>- Eigenschaft zeigt an, 
	// ob Transaktionen unterstützt werden. Wenn diese Eigenschaft den Wert '<cv True>' hat, werden 
	// Veränderungen an der Datenbank aufgezeichnet. Dadurch können Veränderungen rückgängig gemacht 
	// (verworfen) oder bestätigt (gespeichert) werden. Wenn die <op .Transactions>- Eigenschaft den 
	// Wert '<cv False>' hat, werden Veränderungen der Datenbank nicht aufgezeichnet.
	// @comm Die Eigenschaft <op .Transactions> kann nicht gesetzt werden.
	// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>
	// @xref <i ITRiASDatabase>
		[propget, id(13), helpstring("Liefert, ob durch diese Datenbank Transaktionen unterstützt werden.")] HRESULT Transactions([out, retval] VARIANT_BOOL *pVal);

	// @property VARIANT_BOOL | ITRiASDatabase | Updateable | Die <op .Updatable>- Eigenschaft gibt an, ob 
	// Änderungen an der Datenbank vorgenommen werden können. Wenn diese Eigenschaft den Wert '<cv True>'
	// hat, sind Änderungen zulässig.
	// @comm Die Eigenschaft <op .Updatable> kann nicht gesetzt werden.
	// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>
	// @xref <i ITRiASDatabase>
		[propget, id(14), helpstring("Liefert ob Veränderungen der Datenbank zulässig sind.")] HRESULT Updatable([out, retval] VARIANT_BOOL *pVal);

	// @property VARIANT_BOOL | ITRiASDatabase | Temporary | Die <op .Temporary>- Eigenschaft liefert
	// bzw. setzt, ob die Datenbank nach dem Schließen automatisch gelöscht werden soll.
	// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>
	// @xref <i ITRiASDatabase>
		[propget, id(15), helpstring("Liefert, ob die Datenbank nach dem Schließen gelöscht werden soll.")] HRESULT Temporary([out, retval] VARIANT_BOOL *pVal);
		[propput, id(15), helpstring("Setzt, ob die Datenbank nach dem Schließen gelöscht werden soll.")] HRESULT Temporary([in] VARIANT_BOOL newVal);

	// @property BSTR | ITRiASDatabase | TemporaryName | Die <op .TemporaryName>- Eigenschaft 
	// liefert den Namen der Datenbankbankdatei auch dann, wenn die Datenbank temporär erzeugt worden ist.
	// @comm Die Eigenschaft <op .TemporaryName> kann nicht gesetzt werden.
	// @comm Wenn die <op .Temporary>- Eigenschaft den Wert <cv False> liefert, dann ist der Wert der 
	// <op .TemporaryName>- Eigenschaft identisch mit dem Wert der <op .Name>- Eigenschaft.
	// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>
	// @xref <i ITRiASDatabase>
		[propget, id(16), helpstring("Liefert den Namen der Datenbank auch, wenn diese temporär erzeugt worden ist.")] HRESULT TemporaryName([out, retval] BSTR *pVal);

	// @property BSTR | ITRiASDatabase | Type | Die <op .Type>- Eigenschaft liefert den ProgID des 
	// Objektes, welches diese Datenbank als Targetdokument repräsentiert.
	// @comm Die Eigenschaft <op .Type> kann nicht gesetzt werden.
	// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>
	// @xref <i ITRiASDatabase>, <l Registryeinträge für einen TRiASDB-DataServer>
		[propget, id(17), helpstring("Liefert den Typ (ProgID) des Targetobjektes dieser Datenbank.")] HRESULT Type([out, retval] BSTR *pVal);

	// @property DATABASESTORAGEMODE | ITRiASDatabase | Type | Die <op .StorageMode>- Eigenschaft Liefert den Speichertyp 
	// dieser Datenbank.
	// @comm Die Eigenschaft <op .StorageMode> kann nicht gesetzt werden.
	// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>
	// @xref <i ITRiASDatabase>, <l Registryeinträge für einen TRiASDB-DataServer>
		[propget, id(18), helpstring("Liefert den Speichertyp dieser Datenbank.")] HRESULT StorageMode([out, retval] DATABASESTORAGEMODE *pVal);

	// @method HRESULT | ITRiASDatabase | CreateDatabase | Mit der <om .CreateDataBase>- Methode wird 
	// eine neue Datenbank angelegt.
	// @parm BSTR | Name | Der Dateiname der neu zu erzeugenden Datenbank. Wenn die Datenbank nicht 
	// im aktuellen Arbeitsverzeichnis abgelegt werden soll, muß der vollständige Pfad und Dateiname 
	// angegeben werden. Wenn keine Dateinamenerweiterung angegeben wird, wird automatisch die in 
	// der Registry für den gewünschten Datenbanktyp angegebene Dateiendung verwendet.
	// @parm BSTR | Locale | Die beim Anlegen der Datenbank verwendete Sortierfolge. Nach Anlegen der 
	// Datenbank kann die Sortierfolge über die CollatingOrder-Eigenschaft abgefragt werden.
	// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>
	// @xref <i ITRiASDatabase>
	// @parm BSTR | Source | Eine (optionale) Zeichenfolge, die angibt, welche Argumente für ODBC 
	// (Open Database Connectivity) eingestellt werden sollen. Dies ist nur dann anwendbar, 
	// wenn die Argumente exclusive und readonly so eingestellt sind, daß eine Quell-Zeichenfolge 
	// zur Verfügung steht.

cpp_quote("#if !defined(_lint)")
	// @group Folgende Werte für den <p Locale>- Parameter werden unterstützt.
	// @index | LOCALEORDER
	// @doc LOCALEORDER
	// @constv LPSTR | LOCALE_Arabic | ";LANGID=0x0401;CP=1256;COUNTRY=0" | Landesinformation: arabisch
	// @xref <om ITRiASDatabase.CreateDatabase>
		[helpstring("locale argument (CreateDatabase)")] const LPSTR LOCALE_Arabic = ";LANGID=0x0401;CP=1256;COUNTRY=0";

	// @constv LPSTR | LOCALE_Czech | ";LANGID=0x0405;CP=1250;COUNTRY=0" | Landesinformation: tschechisch
	// @xref <om ITRiASDatabase.CreateDatabase>
		[helpstring("locale argument (CreateDatabase)")] const LPSTR LOCALE_Czech = ";LANGID=0x0405;CP=1250;COUNTRY=0";

	// @constv LPSTR | LOCALE_Dutch | ";LANGID=0x0413;CP=1252;COUNTRY=0" | Landesinformation: dänisch
	// @xref <om ITRiASDatabase.CreateDatabase>
		[helpstring("locale argument (CreateDatabase)")] const LPSTR LOCALE_Dutch = ";LANGID=0x0413;CP=1252;COUNTRY=0";

	// @constv LPSTR | LOCALE_General | ";LANGID=0x0409;CP=1252;COUNTRY=0" | Landesinformation: internation (allgemein)
	// @xref <om ITRiASDatabase.CreateDatabase>
		[helpstring("locale argument (CreateDatabase)")] const LPSTR LOCALE_General = ";LANGID=0x0409;CP=1252;COUNTRY=0";

	// @constv LPSTR | LOCALE_Greek | ";LANGID=0x0408;CP=1253;COUNTRY=0" | Landesinformation: griechisch
	// @xref <om ITRiASDatabase.CreateDatabase>
		[helpstring("locale argument (CreateDatabase)")] const LPSTR LOCALE_Greek = ";LANGID=0x0408;CP=1253;COUNTRY=0";

	// @constv LPSTR | LOCALE_Hebrew | ";LANGID=0x040D;CP=1255;COUNTRY=0" | Landesinformation: hebräisch
	// @xref <om ITRiASDatabase.CreateDatabase>
		[helpstring("locale argument (CreateDatabase)")] const LPSTR LOCALE_Hebrew = ";LANGID=0x040D;CP=1255;COUNTRY=0";

	// @constv LPSTR | LOCALE_Hungarian | ";LANGID=0x040E;CP=1250;COUNTRY=0" | Landesinformation: ungarisch
	// @xref <om ITRiASDatabase.CreateDatabase>
		[helpstring("locale argument (CreateDatabase)")] const LPSTR LOCALE_Hungarian = ";LANGID=0x040E;CP=1250;COUNTRY=0";

	// @constv LPSTR | LOCALE_Icelandic | ";LANGID=0x040F;CP=1252;COUNTRY=0" | Landesinformation: isländisch
	// @xref <om ITRiASDatabase.CreateDatabase>
		[helpstring("locale argument (CreateDatabase)")] const LPSTR LOCALE_Icelandic = ";LANGID=0x040F;CP=1252;COUNTRY=0";

	// @constv LPSTR | LOCALE_Nordic | ";LANGID=0x041D;CP=1252;COUNTRY=0" | Landesinformation: nordisch
	// @xref <om ITRiASDatabase.CreateDatabase>
		[helpstring("locale argument (CreateDatabase)")] const LPSTR LOCALE_Nordic = ";LANGID=0x041D;CP=1252;COUNTRY=0";

	// @constv LPSTR | LOCALE_NorwDan | ";LANGID=0x0414;CP=1252;COUNTRY=0" | Landesinformation: norwegisch/dänisch
	// @xref <om ITRiASDatabase.CreateDatabase>
		[helpstring("locale argument (CreateDatabase)")] const LPSTR LOCALE_NorwDan = ";LANGID=0x0414;CP=1252;COUNTRY=0";

	// @constv LPSTR | LOCALE_Polish | ";LANGID=0x0415;CP=1250;COUNTRY=0" | Landesinformation: polnisch
	// @xref <om ITRiASDatabase.CreateDatabase>
		[helpstring("locale argument (CreateDatabase)")] const LPSTR LOCALE_Polish = ";LANGID=0x0415;CP=1250;COUNTRY=0";

	// @constv LPSTR | LOCALE_Cyrillic | ";LANGID=0x0419;CP=1251;COUNTRY=0" | Landesinformation: cyrillsch
	// @xref <om ITRiASDatabase.CreateDatabase>
		[helpstring("locale argument (CreateDatabase)")] const LPSTR LOCALE_Cyrillic = ";LANGID=0x0419;CP=1251;COUNTRY=0";

	// @constv LPSTR | LOCALE_Spanish | ";LANGID=0x040A;CP=1252;COUNTRY=0" | Landesinformation: spanisch
	// @xref <om ITRiASDatabase.CreateDatabase>
        [helpstring("locale argument (CreateDatabase)")] const LPSTR LOCALE_Spanish = ";LANGID=0x040A;CP=1252;COUNTRY=0";

	// @constv LPSTR | LOCALE_SwedFin | ";LANGID=0x040B;CP=1252;COUNTRY=0" | Landesinformation: schwedisch
	// @xref <om ITRiASDatabase.CreateDatabase>
        [helpstring("locale argument (CreateDatabase)")] const LPSTR LOCALE_SwedFin = ";LANGID=0x040B;CP=1252;COUNTRY=0";

	// @constv LPSTR | LOCALE_Turkish | ";LANGID=0x041F;CP=1254;COUNTRY=0" | Landesinformation: türkisch
	// @xref <om ITRiASDatabase.CreateDatabase>
        [helpstring("locale argument (CreateDatabase)")] const LPSTR LOCALE_Turkish = ";LANGID=0x041F;CP=1254;COUNTRY=0";

	// @constv LPSTR | LOCALE_Japanese | ";LANGID=0x0411;CP=932;COUNTRY=0" | Landesinformation: japanisch
	// @xref <om ITRiASDatabase.CreateDatabase>
        [helpstring("locale argument (CreateDatabase)")] const LPSTR LOCALE_Japanese = ";LANGID=0x0411;CP=932;COUNTRY=0";

	// @constv LPSTR | LOCALE_ChineseSimplified | ";LANGID=0x0804;CP=936;COUNTRY=0" | Landesinformation: chinesisch vereinfacht
	// @xref <om ITRiASDatabase.CreateDatabase>
        [helpstring("locale argument (CreateDatabase)")] const LPSTR LOCALE_ChineseSimplified = ";LANGID=0x0804;CP=936;COUNTRY=0";

	// @constv LPSTR | LOCALE_ChineseTraditional | ";LANGID=0x0404;CP=950;COUNTRY=0" | Landesinformation: chinesisch traditionell
	// @xref <om ITRiASDatabase.CreateDatabase>
        [helpstring("locale argument (CreateDatabase)")] const LPSTR LOCALE_ChineseTraditional = ";LANGID=0x0404;CP=950;COUNTRY=0";

	// @constv LPSTR | LOCALE_Korean | ";LANGID=0x040C;CP=494;COUNTRY=0" | Landesinformation: koreanisch
	// @xref <om ITRiASDatabase.CreateDatabase>
        [helpstring("locale argument (CreateDatabase)")] const LPSTR LOCALE_Korean = ";LANGID=0x040C;CP=494;COUNTRY=0";

	// @constv LPSTR | LOCALE_Thai | ";LANGID=0x101E;CP=874;COUNTRY=0" | Landesinformation: thailändisch
	// @xref <om ITRiASDatabase.CreateDatabase>
        [helpstring("locale argument (CreateDatabase)")] const LPSTR LOCALE_Thai = ";LANGID=0x101E;CP=874;COUNTRY=0";
cpp_quote("#endif // !defined(_lint)")

	// @doc IDATABASE
		[id(100), helpstring("Erzeugen einer neuen Datenbank.")] HRESULT CreateDatabase([in] BSTR Name, [in] BSTR Locale, [in] BSTR Source);

	// @method HRESULT | ITRiASDatabase | CreateDatabaseFromFiles | Mit der <om .CreateDatabaseFromFiles>- 
	// Methode wird eine neue Datenbank angelegt.
	// @parm IUnknown * | FileNames | Die Dateinamen der Dateien, die der neu zu erzeugenden Datenbank
	// zugrunde liegen. Sind keine Dateinamenserweiterungen gegeben, so werden die Dateien entsprechend
	// dem Typ des <o TRiASDatabase>- Objektes interpretiert.
	// @parm BSTR | Locale | Die beim Anlegen der Datenbank verwendete Sortierfolge. Nach Anlegen der 
	// Datenbank kann die Sortierfolge über die CollatingOrder-Eigenschaft abgefragt werden.
	// @parm BSTR | Source | Eine (optionale) Zeichenfolge, die angibt, welche Argumente für ODBC 
	// (Open Database Connectivity) eingestellt werden sollen. Dies ist nur dann anwendbar, 
	// wenn die Argumente exclusive und readonly so eingestellt sind, daß eine Quell-Zeichenfolge 
	// zur Verfügung steht.
	// @comm Die möglichen Werte für den <p Locale> sind bei der <om ITRiASDatabase.CreateDatabase>- 
	// Methode beschrieben.
	// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>
	// @xref <i ITRiASDatabase>, <om ITRiASDatabase.CreateDatabase>
		[id(101), helpstring("Erzeugen einer neuen Datenbank aus den übergebenen Dateien.")] HRESULT CreateDatabaseFromFiles([in] IUnknown *FileNames, [in] BSTR Locale, [in] BSTR Source);

	// @method HRESULT | ITRiASDatabase | OpenDatabase | Öffnen der Datenbank entsprechend den 
	// übergebenen Parametern.
	// @parm BSTR | Name | Der vollständige Pfad (Name) der zu eröffnenden Datanbank.
	// @parm VARIANT_BOOL | Exclusive | Durch diese optionale Einstellung wird angegeben, ob die Datenbank 
	// für ausschließlichen oder gemeinsamen Zugriff geöffnet werden soll. Der Wert '<cv True>' steht 
	// für ausschließlichen und der Wert '<cv False>' für gemeinsamen Zugriff. Die Standardeinstellung 
	// ist ausschließlicher Zugriff ('<cv True>').
	// @parm VARIANT_BOOL | ReadOnly | Gibt (optional) an, ob die Datenbank mit Lese- oder mit Schreibzugriff 
	// geöffnet wird. Der Wert '<cv True>' steht für Lesezugriff; und der Wert '<cv False>' für Schreibzugriff. 
	// Die Standardeinstellung ist Schreibzugriff ('<cv False>').
	// @parm VARIANT_BOOL | ModTrack | Gibt (optional) an, ob Modification Tracking gewünscht ist. Die 
	// Standardeinstellung ist '<cv True>' (Modification Tracking aktiviert). Die Einstellung '<cv False>'
	// garantiert jedoch nicht, daß der Server kein internes Tracking vornimmt. Diese 
	// Einstellung sagt lediglich aus, daß Modification Tracking nicht ausdrücklich aktiviert wurde.
	// Hinweis: Wenn der Server Modification Tracking nicht unterstützt, ist die Einstellung 
	// dieses Arguments wirkungslos. 
	// @parm BSTR | Source | Eine (optionale) Zeichenfolge, die angibt, welche Argumente für ODBC 
	// (Open Database Connectivity) eingestellt werden sollen. Dies ist nur dann anwendbar, 
	// wenn die Argumente exclusive und readonly so eingestellt sind, daß eine Quell-Zeichenfolge 
	// zur Verfügung steht.
	// @devnote Der <p Source>- Parameter enthält zur Zeit zumindest folgende Informationen:
	// "TRiASDB;PROGID=prodid" (ohne Anführungszeichen), wobei 'progid' der ProgID des Target-COM-Objektes
	// ist, welches für die zu behandelnden Daten zuständig ist. Diese Information erlaubt, auch für
	// mehrere unterschiedliche Datenquellen/Datenformate ein und das selbe <o TRiASDatabase>-Objekt
	// zu verwenden. 
	// <nl>Weiterhin enthält der <p Source> zusätzliche Informationen, die evtl. von einer Dialogseite
	// generiert wurden, die zusätzlich im OpenDialog eingehängt worden ist. Die Dialoginformationen
	// liegen in einem identischen Key/Value-Paar Format vor: ';Key1=Value1;...;KeyN=ValueN'. Weitere 
	// Informationen zu zusätzlichen Dialogseiten sind hier: <i ITRiASOpenWizardPropExt>.
	// @rvalue <cv S_OK> | Die Datanbank wurde erfolgreich geöffnet.
	// @rvalue <cv TRIASDB_E_NOTAPROJECT> | Der angegebene <p Name> identifiziert keine <tr> Datenbank
	// @rvalue <cv TRIASDB_E_FILENOTEXISTS> | Die Datenbank <p Name> existiert nicht unter dem vorgegebenen
	// Pfad.
	// @rvalue <cv TRIASDB_S_MUSTOPENASCOPY> | Die Datenbank ist schreibgeschützt und kann daher nicht mit 
	// den gewünschten Zugriffrechten geöffnet werden. Die Datenbank sollte schreibgeschützt geöffnet 
	// werden (<p ReadOnly> auf '<cv True>' setzen).
	// @rvalue <cv TRIASDB_S_MUSTOPENASCOPY_SHAREVIOLATION> | Die Datenbank ist bereits mit vollen 
	// Zugriffsrechten geöffnet und kann daher nicht mit den gewünschten Zugriffrechten geöffnet 
	// werden. Die Datenbank sollte schreibgeschützt geöffnet werden (<p ReadOnly> auf '<cv True>' setzen).
	// @rvalue <cv TRIASDB_W_ALREADY_OPENED> | Dieses <o TRiASDatabase>-Objekt ist bereits mit einer
	// geöffneten Datenbank verknüpft.
	// @rvalue <cv TRIASDB_E_COULD_NOT_OPEN> | Die Datenbank <p Name> konnte nicht eröffnet werden 
	// (sonstige Gründe).
	// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>
	// @xref <i ITRiASDatabase>
	// @end
		[id(102), helpstring("Öffnen einer Datenbank.")] HRESULT OpenDatabase([in] BSTR Name, [in /*, optional*/, defaultvalue(VARIANT_TRUE)] VARIANT_BOOL Exclusive, [in /*, optional*/, defaultvalue(VARIANT_FALSE)] VARIANT_BOOL ReadOnly, [in /*, optional*/, defaultvalue(VARIANT_FALSE)] VARIANT_BOOL ModTrack, [in /*, optional*/, defaultvalue("")] BSTR Source);

	// @method HRESULT | ITRiASDatabase | OpenFilesAsDatabase | Öffnen der Datenbank entsprechend den 
	// übergebenen Parametern.
	// @parm IUnknown * | FileNames | Die vollständige Pfade der zur zu eröffnenden Datanbank gehörenden
	// Dateien. Hinter dem Parameter <p FileNames> verbirgt sich ein IEnumString
	// @parm VARIANT_BOOL | Exclusive | Durch diese optionale Einstellung wird angegeben, ob die Datenbank 
	// für ausschließlichen oder gemeinsamen Zugriff geöffnet werden soll. Der Wert '<cv True>' steht 
	// für ausschließlichen und der Wert '<cv False>' für gemeinsamen Zugriff. Die Standardeinstellung 
	// ist ausschließlicher Zugriff ('<cv True>').
	// @parm VARIANT_BOOL | ReadOnly | Gibt (optional) an, ob die Datenbank mit Lese- oder mit Schreibzugriff 
	// geöffnet wird. Der Wert '<cv True>' steht für Lesezugriff; und der Wert '<cv False>' für Schreibzugriff. 
	// Die Standardeinstellung ist Schreibzugriff ('<cv False>').
	// @parm VARIANT_BOOL | ModTrack | Gibt (optional) an, ob Modification Tracking gewünscht ist. Die 
	// Standardeinstellung ist '<cv True>' (Modification Tracking aktiviert). Die Einstellung '<cv False>'
	// garantiert jedoch nicht, daß der Server kein internes Tracking vornimmt. Diese 
	// Einstellung sagt lediglich aus, daß Modification Tracking nicht ausdrücklich aktiviert wurde.
	// Hinweis: Wenn der Server Modification Tracking nicht unterstützt, ist die Einstellung 
	// dieses Arguments wirkungslos. 
	// @parm BSTR | Source | Eine (optionale) Zeichenfolge, die angibt, welche Argumente für ODBC 
	// (Open Database Connectivity) eingestellt werden sollen. Dies ist nur dann anwendbar, 
	// wenn die Argumente exclusive und readonly so eingestellt sind, daß eine Quell-Zeichenfolge 
	// zur Verfügung steht.
	// @devnote Der <p Source>- Parameter enthält zur Zeit zumindest folgende Informationen:
	// "TRiASDB;PROGID=prodid" (ohne Anführungszeichen), wobei 'progid' der ProgID des Target-COM-Objektes
	// ist, welches für die zu behandelnden Daten zuständig ist. Diese Information erlaubt, auch für
	// mehrere unterschiedliche Datenquellen/Datenformate ein und das selbe <o TRiASDatabase>-Objekt
	// zu verwenden.
	// @rvalue <cv S_OK> | Die Datanbank wurde erfolgreich geöffnet.
	// @rvalue <cv TRIASDB_E_NOTAPROJECT> | Der angegebene <p Name> identifiziert keine <tr> Datenbank
	// @rvalue <cv TRIASDB_E_FILENOTEXISTS> | Die Datenbank <p Name> existiert nicht unter dem vorgegebenen
	// Pfad.
	// @rvalue <cv TRIASDB_S_MUSTOPENASCOPY> | Die Datenbank ist schreibgeschützt und kann daher nicht mit 
	// den gewünschten Zugriffrechten geöffnet werden. Die Datenbank sollte schreibgeschützt geöffnet 
	// werden (<p ReadOnly> auf '<cv True>' setzen).
	// @rvalue <cv TRIASDB_S_MUSTOPENASCOPY_SHAREVIOLATION> | Die Datenbank ist bereits mit vollen 
	// Zugriffsrechten geöffnet und kann daher nicht mit den gewünschten Zugriffrechten geöffnet 
	// werden. Die Datenbank sollte schreibgeschützt geöffnet werden (<p ReadOnly> auf '<cv True>' setzen).
	// @rvalue <cv TRIASDB_W_ALREADY_OPENED> | Dieses <o TRiASDatabase>-Objekt ist bereits mit einer
	// geöffneten Datenbank verknüpft.
	// @rvalue <cv TRIASDB_E_COULD_NOT_OPEN> | Die Datenbank <p Name> konnte nicht eröffnet werden 
	// (sonstige Gründe).
	// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>
	// @xref <i ITRiASDatabase>
	// @end
		[id(103), helpstring("Öffnen der übergebenen Dateien als eine Datenbank.")] HRESULT OpenFilesAsDatabase([in] IUnknown *FileNames, [in /*, optional*/, defaultvalue(VARIANT_TRUE)] VARIANT_BOOL Exclusive, [in /*, optional*/, defaultvalue(VARIANT_FALSE)] VARIANT_BOOL ReadOnly, [in /*, optional*/, defaultvalue(VARIANT_FALSE)] VARIANT_BOOL ModTrack, [in /*, optional*/, defaultvalue("")] BSTR Source);

	// @method HRESULT | ITRiASDatabase | Save | Die <om. Save>- Methode speichert alle Änderungen,
	// die seit dem letzten Aufruf einer der Methoden <om .Save> oder <om .SaveAs> bzw. dem Öffnen dieser
	// Datenbank vorgenommen worden sind.
	// @comm Die <om .Save>- Methode speichert nur dann Daten in der Datenbank, wenn die 
	// <om .IsDirty>- Eigenschaft den Wert <cv True> liefern würde. Es ist kein Fehler, die 
	// <om .Save>- Methode zu verwenden, wenn die <om .IsDirty>- Eigenschaft <cv False> liefert, in diesem
	// Fall macht die Methode nichts.
	// @comm Die <om .Save>- Methode schlägt fehl, wenn die Datenbank nicht beschreibbar ist oder
	// im schreibgeschützten Mode eröffnet wurde, d.h. die <op GDatabase.Updateable>- Eigenschaft 
	// liefert den Wert <cv False> oder die <om GDatabase.OpenDatabase> wurde mit dem Parameter 
	// <p ReadOnly> gleich <cv True> gerufen.
	// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>
	// @xref <i ITRiASDatabase>, <om .SaveAs>, <op GDatabase.Updateable>, <om GDatabase.OpenDatabase>
		[id(104), helpstring("Speichern der Datenbank.")] HRESULT Save();

	// @method HRESULT | ITRiASDatabase | SaveAs | Die <om. SaveAs>- Methode speichert alle Änderungen,
	// die seit dem letzten Aufruf einer der Methoden <om .Save> oder <om .SaveAs> bzw. dem Öffnen dieser
	// Datenbank vorgenommen worden sind.
	// @parm BSTR | NewName | Der Parameter <p NewName> gibt den Namen der Datenbank vor, unter dem 
	// der Inhalt der aktuellen Datenbank gespeichert werden soll. Dieser Parameter wird entweder 
	// als Dateiname oder als Verzeichnisname ausgewertet, je nach dem, welche Werte die entsprechenden
	// <op ITRiASDataServerRegEntry.NameIsFile> bzw. <op ITRiASDataServerRegEntry.NameIsDirectory>- 
	// Eigenschaften besitzen.
	// @comm Die <om .SaveAs>- Methode schlägt fehl, wenn die Datenbank nicht beschreibbar ist.,
	// d.h. die <op GDatabase.Updateable>- Eigenschaft liefert den Wert <cv False>.
	// @comm Nicht alle Datenbanken unterstützen die <om .SaveAs>- Methode.
	// @comm Nach erfolgreichem Abschluß der <om .SaveAs>- Methode bleibt die Datenbank geöffnet,
	// weitere Modifikationen werden jedoch in der neuen Datenbank gespeichert. Die Datenbank
	// aus der heraus diese Methode gerufen wurde, wird geschlossen und alle Änderungen seit dem 
	// letzten Speichern gehen dort verloren.
	// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>
	// @xref <i ITRiASDatabase>, <om .Save>, <op GDatabase.Updateable>, <om GDatabase.OpenDatabase>,
	// <op ITRiASDataServerRegEntry.NameIsFile>, <op ITRiASDataServerRegEntry.NameIsDirectory>
		[id(105), helpstring("Speichern der Datenbank unter neuem Namen.")] HRESULT SaveAs([in] BSTR NewName);

	// @method HRESULT | ITRiASDatabase | Close | Bei der Close-Methode wird für 
	// das gerade geöffnete Database-Objekt geschlossen, die Datenbank wird dabei jedoch nicht 
	// vom Datenträger gelöscht. 
	// @comm Vor Verwendung der Close-Methode sollten die <om .Save> oder  
	// <om .SaveAs> -Methode angewendet werden, damit Änderungen und neu eingegebene 
	// Daten der Datenbank hinzugefügt werden. Sonst gehen alle nicht gespeicherten Änderungen 
	// verloren und die anstehenden Transaktionen werden auf ihren zuletzt gespeicherten Wert zurückgesetzt. 
	// Wenn nach Anwendung der <om .Close>- Methode Operationen an der Database oder 
	// irgendeinem anderen zugehörigen Objekt Änderungen vorgenommen werden, tritt ein Fehler auf. 
	// Ausnahmen hiervon sind der Aufruf der <om .OpenDatabase>- Methode.
	// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>
	// @xref <i ITRiASDatabase>
		[id(106), helpstring("Schließen der Datenbank.")] HRESULT Close();

	// @method HRESULT | ITRiASDatabase | BeginTrans | Mit der <om .BeginTrans>- Methode wird 
	// eine Transaktion begonnen.
	// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>
	// @xref <i ITRiASDatabase>
		[id(107), helpstring("Beginnen einer Transaktion.")] HRESULT BeginTrans();

	// @method HRESULT | ITRiASDatabase | ClearModificationLog | Mit der <om .ClearModificationLog>- 
	// Methode wird das Änderungsprotokoll gelöscht. Veränderungen der Datanbank werden in einer Tabelle 
	// im GTableDefs-Collection-Objekt gespeichert. Die Änderungsprotokoll-Tabelle kann durch Abfragen 
	// der GAliasTable der Tabelle mit dem Wert gdbModifications (bei der Type-Eigenschaft) 
	// gefunden werden.
	// @parm LONG | Entry | Weist mit Hilfe dieses (optionalen) Arguments die Methode an, Einträge 
	// in einem Änderungsprotokoll bis zu einem spezifizierten Eintrag (einschließlich dieses 
	// Eintrags) zu löschen. Das Argument gibt den letzten zu löschenden Eintrag an.
	// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>
	// @xref <i ITRiASDatabase>
		[id(108), helpstring("Löschen des Änderungsprotokolls.")] HRESULT ClearModificationLog([in /*, optional*/, defaultvalue(-1L)] LONG Entry);

	// @method HRESULT | ITRiASDatabase | CommitTrans | Die <om .CommitTrans>- Methode bestätigt 
	// Transaktionen für alle geöffneten Database-Objekte.
	// @comm Die CommitTrans-Methode sollte nur dann angewendet werden, wenn die <op .Transactions>- 
	// Eigenschaft den Wert <cv True> hat und die <om .BeginTrans>- Methode angewendet wurde. 
	// Wenn <om .CommitTrans> verwenden wird, ohne zuerst die <om .BeginTrans>- Methode anzuwenden, 
	// tritt ein Fehler auf. Wenn die <om .CommitTrans>- Methode angewendet wird, solange die 
	// <op .Transactions>- Eigenschaft auf <cv False> gesetzt ist, tritt zwar kein Fehler auf, 
	// die Methode wird jedoch ignoriert. 
	// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>
	// @xref <i ITRiASDatabase>
		[id(109), helpstring("Bestätigen aller Änderungen aller Transaktionen.")] HRESULT CommitTrans();

	// @method HRESULT | ITRiASDatabase | Rollback | Mit der <om .Rollback>- Methode wird eine 
	// Transaktion rückgängig gemacht.
	// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>
	// @xref <i ITRiASDatabase>
		[id(110), helpstring("Rückgängigmachen einer Transaktion.")] HRESULT Rollback();

	// @method HRESULT | ITRiASDatabase | ReLoad | Mit der <om .ReLoad>- Methode wird die Datenbank
	// davon informiert, daß ein oder mehrere Parameter neu eingelesen werden sollten.
	// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>
	// @xref <i ITRiASDatabase>
		[id(111), helpstring("Neu einlesen von Datenbank-Parametern.")] HRESULT ReLoad([in] RELOADDATABASE ToReLoad);

	// @method HRESULT | ITRiASDatabase | CreateDatabaseOnStg | Mit der <om .CreateDatabaseOnStg>- 
	// Methode wird eine neue Datenbank in einem exitierenden Storage angelegt.
	// @parm IUnknown * | Storage | Das Storage in dem die neu zu erzeugenden Datenbank
	// angelegt werden soll. 
	// @parm BSTR | Name | Der Name, unter dem die neue Datenbank geführt wird.
	// @parm BSTR | Locale | Die beim Anlegen der Datenbank verwendete Sortierfolge. Nach Anlegen der 
	// Datenbank kann die Sortierfolge über die CollatingOrder-Eigenschaft abgefragt werden.
	// @parm BSTR | Source | Eine (optionale) Zeichenfolge, die angibt, welche Argumente für ODBC 
	// (Open Database Connectivity) eingestellt werden sollen. Dies ist nur dann anwendbar, 
	// wenn die Argumente exclusive und readonly so eingestellt sind, daß eine Quell-Zeichenfolge 
	// zur Verfügung steht.
	// @comm Die möglichen Werte für den <p Locale> sind bei der <om ITRiASDatabase.CreateDatabase>- 
	// Methode beschrieben.
	// @supby <o TRiASDatabaseOnFile>, <o TRiASDatabaseOnStg>, <o TRiASCompatibleDatabase>
	// @xref <i ITRiASDatabase>, <om ITRiASDatabase.CreateDatabase>
		[id(112), helpstring("Erzeugen einer neuen Datenbank in einem gegebenen Storage.")] HRESULT CreateDatabaseOnStg([in] IUnknown *Storage, [in] BSTR Name, [in] BSTR Locale, [in] BSTR Source);

	// @method HRESULT | ITRiASDatabase | OpenStorageAsDatabase | Öffnen der Datenbank entsprechend den 
	// übergebenen Parametern.
	// @parm IUnknown * | Storage | Das Storage in dem die zu öffnende Datenbank gespeichert ist.
	// @parm VARIANT_BOOL | Exclusive | Durch diese optionale Einstellung wird angegeben, ob die Datenbank 
	// für ausschließlichen oder gemeinsamen Zugriff geöffnet werden soll. Der Wert '<cv True>' steht 
	// für ausschließlichen und der Wert '<cv False>' für gemeinsamen Zugriff. Die Standardeinstellung 
	// ist ausschließlicher Zugriff ('<cv True>').
	// @parm VARIANT_BOOL | ReadOnly | Gibt (optional) an, ob die Datenbank mit Lese- oder mit Schreibzugriff 
	// geöffnet wird. Der Wert '<cv True>' steht für Lesezugriff; und der Wert '<cv False>' für Schreibzugriff. 
	// Die Standardeinstellung ist Schreibzugriff ('<cv False>').
	// @parm VARIANT_BOOL | ModTrack | Gibt (optional) an, ob Modification Tracking gewünscht ist. Die 
	// Standardeinstellung ist '<cv True>' (Modification Tracking aktiviert). Die Einstellung '<cv False>'
	// garantiert jedoch nicht, daß der Server kein internes Tracking vornimmt. Diese 
	// Einstellung sagt lediglich aus, daß Modification Tracking nicht ausdrücklich aktiviert wurde.
	// Hinweis: Wenn der Server Modification Tracking nicht unterstützt, ist die Einstellung 
	// dieses Arguments wirkungslos. 
	// @parm BSTR | Source | Eine (optionale) Zeichenfolge, die angibt, welche Argumente für ODBC 
	// (Open Database Connectivity) eingestellt werden sollen. Dies ist nur dann anwendbar, 
	// wenn die Argumente exclusive und readonly so eingestellt sind, daß eine Quell-Zeichenfolge 
	// zur Verfügung steht.
	// @devnote Der <p Source>- Parameter enthält zur Zeit zumindest folgende Informationen:
	// "TRiASDB;PROGID=prodid" (ohne Anführungszeichen), wobei 'progid' der ProgID des Target-COM-Objektes
	// ist, welches für die zu behandelnden Daten zuständig ist. Diese Information erlaubt, auch für
	// mehrere unterschiedliche Datenquellen/Datenformate ein und das selbe <o TRiASDatabase>-Objekt
	// zu verwenden.
	// @rvalue <cv S_OK> | Die Datenbank wurde erfolgreich geöffnet.
	// @rvalue <cv TRIASDB_E_NOTAPROJECT> | Der angegebene <p Name> identifiziert keine <tr> Datenbank
	// @rvalue <cv TRIASDB_E_FILENOTEXISTS> | Die Datenbank <p Name> existiert nicht unter dem vorgegebenen
	// Pfad.
	// @rvalue <cv TRIASDB_S_MUSTOPENASCOPY> | Die Datenbank ist schreibgeschützt und kann daher nicht mit 
	// den gewünschten Zugriffrechten geöffnet werden. Die Datenbank sollte schreibgeschützt geöffnet 
	// werden (<p ReadOnly> auf '<cv True>' setzen).
	// @rvalue <cv TRIASDB_S_MUSTOPENASCOPY_SHAREVIOLATION> | Die Datenbank ist bereits mit vollen 
	// Zugriffsrechten geöffnet und kann daher nicht mit den gewünschten Zugriffrechten geöffnet 
	// werden. Die Datenbank sollte schreibgeschützt geöffnet werden (<p ReadOnly> auf '<cv True>' setzen).
	// @rvalue <cv TRIASDB_W_ALREADY_OPENED> | Dieses <o TRiASDatabase>-Objekt ist bereits mit einer
	// geöffneten Datenbank verknüpft.
	// @rvalue <cv TRIASDB_E_COULD_NOT_OPEN> | Die Datenbank <p Name> konnte nicht eröffnet werden 
	// (sonstige Gründe).
	// @supby <o TRiASDatabaseOnFile>, <o TRiASDatabaseOnStg>, <o TRiASCompatibleDatabase>
	// @xref <i ITRiASDatabase>
	// @end
		[id(113), helpstring("Öffnen der Datenbank aus dem übergebenen Storage.")] HRESULT OpenStorageAsDatabase([in] IUnknown *Storage, [in /*, optional*/, defaultvalue(VARIANT_TRUE)] VARIANT_BOOL Exclusive, [in /*, optional*/, defaultvalue(VARIANT_FALSE)] VARIANT_BOOL ReadOnly, [in /*, optional*/, defaultvalue(VARIANT_FALSE)] VARIANT_BOOL ModTrack, [in /*, optional*/, defaultvalue("")] BSTR Source);

	// @method HRESULT | ITRiASDatabase | RefreshChangesFromModificationLog | Öffnen der Datenbank entsprechend den 
	// übergebenen Parametern.
	// @parm <i ITRiASRefreshChangesCallback> * | Callback | Das Callback-Interface, über welches
	// sämtliche relevanten Änderungen an dieser Datenbank an den Aufrufer propagiert werden.
	// @supby <o TRiASDatabaseOnFile>, <o TRiASDatabaseOnStg>, <o TRiASCompatibleDatabase>
	// @xref <i ITRiASDatabase>, <i ITRiASRefreshChangesCallback>
	// @end
		[id(114), helpstring("Öffnen der Datenbank aus dem übergebenen Storage.")] HRESULT RefreshChangesFromModificationLog([in] ITRiASRefreshChangesCallback *Callback);
	};

///////////////////////////////////////////////////////////////////////////////
// @doc INTERFACE TRIASDB
// @interface ITRiASAccessDatabase | Das Interface <i ITRiASAccessDatabase> 
// dient dem Zugriff auf die in dieser Datenbank gespeicherten Informationen.
// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>
// @devnote Dieses Interface sollte von allen <o TRiASDatabase>- Objekten implementiert werden.
// @group Methoden und Eigenschaften von <i ITRiASAccessDatabase> 
// @index | IDATABASECONVERSIONHELPER
// @doc IDATABASECONVERSIONHELPER
	[
		object,
		uuid(B7AEB938-922C-11D1-BA01-080036D63803),
		dual,
		helpstring("ITRiASAccessDatabase Interface"),
		pointer_default(unique)
	]
	interface ITRiASAccessDatabase : IDispatch
	{
	cpp_quote("#if !defined(_ENVELOPETYPE_DEFINED)")
	cpp_quote("#define _ENVELOPETYPE_DEFINED")
	// @doc ENVELOPETYPEENUMS 
	// @enum ENVELOPETYPE | Typ des zu liefernden Koordinatenrechteckes.
	// @xref <i ITRiASAccessDatabase>, <op ITRiASAccessDatabase.Envelope>
		typedef [public, v1_enum, helpstring("Modi zum Starten eines Datenbankschnittstellen-Modules")]
		enum _tagENVELOPETYPE {
			[helpstring("Umschließendes Rechteck aller Objektgeometrien.")]
				ENVELOPETYPE_AllGeometries = 0,		// @emem Umschließendes Rechteck aller Objektgeometrien
			[helpstring("Maximal mögliche Koordinaten in dieser Datenbank.")]
				ENVELOPETYPE_MaxPossible = 1,		// @emem Maximal mögliche Koordinaten in dieser Datenbank
		} ENVELOPETYPE;
	cpp_quote("#endif // _ENVELOPETYPE_DEFINED")

	// @property <i ITRiASViews> * | ITRiASAccessDatabase | Views | Die <op .Views>- Eigenschaft 
	// liefert sämtliche Ansichten der Target-Datenbank.
	// @comm Die Eigenschaft <op .Views> kann nicht gesetzt werden.
	// @devnote Die Eigenschaft <op .Views> muß nur dann implementiert werden, wenn dies sinnvoll ist,
	// d.h. die Target-Datenbank Ansichten unterstützt.
	// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>
	// @xref <i ITRiASAccessDatabase>
		[propget, id(1), helpstring("Liefert sämtliche Ansichten der Target-Datenbank.")] HRESULT Views([out, retval] ITRiASViews **pVal);

	// @property BSTR | ITRiASAccessDatabase | StartViewName | Die <op .StartViewName>- Eigenschaft 
	// liefert den evtl. existierenden Namen der beim Öffnen der Target-Datenbank zu anzuzeigenden Ansicht.
	// @comm Die Eigenschaft <op .StartViewName> kann nicht gesetzt werden.
	// @devnote Die Eigenschaft <op .StartViewName> muß nur dann implementiert werden, wenn dies sinnvoll ist,
	// d.h. die Target-Datenbank Ansichten bzw. eine Start-Ansicht unterstützt.
	// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>
	// @xref <i ITRiASAccessDatabase>
		[propget, id(2), helpstring("Liefert die Startansicht der Target-Datenbank.")] HRESULT StartViewName([out, retval] BSTR *pVal);

	// @property <i ITRiASObjectsCollection> * | ITRiASAccessDatabase | ObjectsDefs |
	// Die <op .ObjectsDefs>- Eigenschaft liefert eine Sammlung aller in dieser Datenbank
	// definierten Objektklassen.
	// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>
	// @xref <i ITRiASAccessDatabase>
		[propget, id(3), helpstring("Liefert eine Sammlung mit allen vordefinierten Objektklassen.")] HRESULT ObjectsDefs ([out, retval] ITRiASObjectsCollection **pIObjsDefs);

	// @property <i ITRiASObjectsCollection> * | ITRiASAccessDatabase | ObjectsDef |
	// Die <op .ObjectsDef>- Eigenschaft liefert eine bestimmte zu dieser Datenquelle gehörenden 
	// Objektklasse.
	// @parm BSTR | Name | Der Name der zu liefernden Objektmenge (<o TRiASObjects>).
	// @parm VARIANT_BOOL | fCreate | Die Objektmenge soll neu erzeugt werden, wenn sie 
	// noch nicht existiert.
	// @parm BSTR | Type | Wenn der Parameter <p fCreate> den Wert <cv True> besitzt und die gegebene 
	// Objektmenge nicht existiert, dann wird eine neuer Objektmenge mit dem hier vorgegeben Typ
	// neu erzeugt (ProgID). Ist der hier gegebene Typ ungültig oder nicht gegeben, dann wird eine 
	// Objektmenge vom Typ <o TRiASObjects> erzeugt.
	// @comm Die Eigenschaft <op .ObjectsDef> kann nicht gesetzt werden.
	// @rvalue <cv S_OK> | Die Operation war erfolgreich (die Objektmenge existierte bereits).
	// @rvalue <cv S_FALSE> | Die Operation war erfolgreich aber die Objektmenge mußte neu 
	// erzeugt werden. Dieser Rückgabewert kann nur dann geliefert werden, wenn der 
	// Parameter <p fCreate> den Wert <cv True> hatte.
	// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>
	// @xref <i ITRiASAccessDatabase>
	// @end
		[propget, id(4), helpstring("Liefert eine bestimmte zu dieser Datenquelle gehörenden Objektklasse.")] HRESULT ObjectsDef([in] VARIANT vItem, [in /*, optional*/, defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fCreate, [in /*, optional*/, defaultvalue("")] BSTR Type, [out, retval] ITRiASObjects **pIObjsDef);

	// @property <i ITRiASObjectsCollection> * | ITRiASAccessDatabase | Envelope |
	// Die <op .Envelope>- Eigenschaft liefert verschiedene umschließende Rechtecke der Datenbank.
	// @parm <t ENVELOPETYPE> | Type | Der Parameter  <p Type> legt fest, welches Koordinatenrechteck
	// geliefert werden soll.
	// @parm IDispatch ** | Cont | Der Parameter <p Cont> ist ein Zeiger auf eine Variable vom
	// Typ IDispatch *, wor bei erfolgreicher Abarbeitung der Funktion ein Zeiger auf
	// ein <i _DGMRectangleGeometry>- Interface abgelegt wird.
	// @comm Die Eigenschaft <op .Envelope> kann nicht gesetzt werden.
	// @devnote Wenn die zugrunde liegende Datenbank das umschließende Rechteck aller
	// Objektgeometrien nicht ohne weiteres zur Verfügung stellen kann, dann muß diese
	// Funktion nicht implementiert werden (die Funktion liefert den Rückgabewert 
	// <cv E_NOTIMPL>). In diesem Fall wird das zugehörige Koordinatensystem nach 
	// einem möglichst vernünftigen (sicher maximalen) umschließenden Rechteck
	// gefragt.
	// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>
	// @xref <i ITRiASAccessDatabase>
		[propget, id(5), helpstring("Liefert diverse umschließende Rechtecke der Datenbank.")] HRESULT Envelope ([in] ENVELOPETYPE Type, [out, retval] IDispatch **Rect);

	// @property <i ITRiASObjectsCollection> * | ITRiASAccessDatabase | ObjectCount |
	// Die <op .ObjectCount>- Eigenschaft liefert die Anzahl der in der zugrunde liegenden 
	// Datenbank gespeicherten Objekte.
	// @comm Die Eigenschaft <op .ObjectCount> kann nicht gesetzt werden.
	// @devnote Wenn die zugrunde liegende Datenbank die Objektanzahl aller
	// Objektgeometrien nicht ohne weiteres zur Verfügung stellen kann, dann muß diese
	// Funktion nicht implementiert werden (die Funktion liefert den Rückgabewert 
	// <cv E_NOTIMPL>). Möglicherweise kann die Datenbank in diesem Fall die
	// Information zur Verfügung stellen, ob überhaupt Objekte existieren. Dann
	// kann der Parameter <p ObjCnt> auf den Wert 0 oder 1 gesetzt werden und
	// der Rückgabewert soltte den Wert <cv S_FALSE> haben.
	// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>
	// @xref <i ITRiASAccessDatabase>
		[propget, id(6), helpstring("Liefert die Anzahl aller in der Datenbank enthaltenen Objekte.")] HRESULT ObjectCount ([out, retval] long *ObjCnt);

	// @property <i ITRiASObjectsCollection> * | ITRiASAccessDatabase | AttachedCS |
	// Die <op .AttachedCS>- Eigenschaft liefert das mit dieser Datenquelle assoziierte 
	// Koordinatensystem.
	// @comm Die Eigenschaft <op .AttachedCS> kann nicht gesetzt werden.
	// @comm Der Wert, der durch die Eigenschaft <op .AttachedCS> geliefert wird, wird der
	// Datenquelle beim Öffnen ursprünglich über das ConnectString übergeben.
	// @comm Die <op .AttachedCS> Eigenschaft muß nur implementiert werden, wenn
	// der RegistryEintrag NeedsCoordSysExisting gesetzt ist.
	// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>
	// @xref <i ITRiASAccessDatabase>
		[propget, id(7), helpstring("Liefert das mit dieser Datenquelle assoziierte Koordinatensystem.")] HRESULT AttachedCS ([in] BSTR DbName, [out, retval] BSTR *AssocCS);

	// @property <i IDispatch> * | ITRiASAccessDatabase | ConnectionFilter |
	// Die <op .ConnectionFilter>- Eigenschaft setzt bzw. liefert den mit dieser 
	// Datenquelle assoziierten ConnectFilter.
	// @supby <o TRiASDatabase>, <o TRiASCompatibleDatabase>
	// @xref <i ITRiASAccessDatabase>
		[propget, id(8), helpstring("Liefert den mit dieser Datenquelle assoziierten ConnectFilter.")] HRESULT ConnectionFilter ([out, retval] ITRiASConnectionFilter **Filter);
		[propput, id(8), helpstring("Setzt den mit dieser Datenquelle assoziierten ConnectFilter.")] HRESULT ConnectionFilter ([in] ITRiASConnectionFilter *Filter);
	};

///////////////////////////////////////////////////////////////////////////////
// Ansicht-Collection (LegendenCollection)
// @doc INTERFACE TRIASDB
// @interface ITRiASViews | Das Interface <i ITRiASViews> dient dem Zugriff auf 
// eine Sammlung von  Ansichten.
// @supby <o TRiASViews>
// @group Methoden und Eigenschaften von <i ITRiASViews> 
// @index | IVIEWS
// @doc IVIEWS
	[
		object,
		uuid(1CB3AB67-2E87-11D1-969D-00A024D6F582),
		dual,
		helpstring("ITRiASViews Interface"),
		pointer_default(unique)
	]
	interface ITRiASViews : ITRiASBase
	{
	// @property LONG | ITRiASViews | Count | Liefert die Anzahl der in dieser Objektsammlungen 
	// enthaltenen Objekte (readonly).
	// @comm Die Eigenschaft <op .Count> kann nicht gesetzt werden.
	// @supby <o TRiASViews>
	// @xref <i ITRiASViews>
		[propget, id(3), helpstring("Number of Views.")] HRESULT Count([out, retval] long *pVal);

	// @method HRESULT | ITRiASViews | Item | 
	// @supby <o TRiASViews>
	// @xref <i ITRiASViews>
		[id(DISPID_DEFAULT), helpstring("Get the view by name or by index number.")] HRESULT Item([in] VARIANT Index, [out, retval] ITRiASView **View);

	// @method HRESULT | ITRiASViews | _NewEnum | Liefert einen neuen
	// Enumerator, der alle Objekte enthält, die in der vorliegenden Sammlung zusammengefaßt sind.
	// @parm IUnknown ** | Enum | Zeiger auf eine Variable vom Typ IUnknown *, welche nach erfolgreicher 
	// Abarbeitung der Methode <om ._NewEnum> den Ergebnis-Enumerator enthält.
	// @comm Der gelieferte Enumerator ist vom Typ <i IEnumVARIANT>. Daher sollte der Rückgabewert
	// explizit durch einen QueryInterface-Aufruf konvertiert werden.
	// @ex Das folgende Beispiel verdeutlicht die empfohlene Vorgehensweise |
	// IEnumVARIANT *pIEnum = NULL;
	// IUnknown *pIUnk = NULL;
	// HRESULT hr = pIEntries -> _NewEnum (&pIUnk);
	//
	//	if (SUCCEEDED(hr)) {
	//		hr = pIUnk -> QueryInterface(IID_IEnumVARIANT, (LPVOID *)&pIEnum);
	//		pIUnk -> Release();
	//	}
	//	...
	// @comm Normalerweise wird diese Funktion nicht direkt gerufen, Sie ist lediglich
	// für die Nutzung in Automation-Werkzeugen wie z.B. VisualBasic vorgesehen, wo sie
	// für Programmkonstrukte wie 'For Each ...' notwendig ist.
	// @supby <o TRiASViews>
	// @xref <i ITRiASViews>
		[id(DISPID_NEWENUM), hidden] HRESULT _NewEnum([out, retval] IUnknown **ppIEnum);
		
	// @method HRESULT | ITRiASViews | Add | Die <om .Add>- Methode erzeugt eine neue Ansicht und
	// fügt sie zu dieser Sammlung von Ansichten hinzu.
	// @parm BSTR | Name | Der Parameter <p Name> gibt den Namen der zu erzeugenden Ansicht
	// vor.
	// @parm <i ITRiASView> * | View | Dieser Parameter enthält nach erfolgreicher Abarbeitung der
	// <om .Add>- Methode einen Zeiger auf das neu erzeugte <o TRiASView>- Objekt.
	// @supby <o TRiASViews>
	// @xref <i ITRiASViews>, <o TRiASView>
		[id(100), helpstring("Create and add a new view.")] HRESULT Add([in] BSTR Name, [out, retval] ITRiASView **View);
		[id(101), helpstring("Remove a View")] HRESULT Remove([in] VARIANT Index);

	// zusätzliches
		[id(102), helpstring("Add an existing view."), hidden] HRESULT _Add([in] ITRiASView *View, [in /*, optional*/, defaultvalue(VARIANT_TRUE)] VARIANT_BOOL FullAdd);

	// @method HRESULT | ITRiASViews | _Clone | Die <om ._Clone>- Methode liefert eine neue Sammlung 
	// von Objekten, die identisch zur vorliegenden ist.
	// @parm <i ITRiASViews> ** | Enum | Zeiger auf eine Variable vom Typ <i ITRiASViews> *, welche nach 
	// erfolgreicher Abarbeitung der Methode <om ._Clone> die Kopie dieser Objektsammlung enthält.
	// @comm Bei Änderungen an der ursprünglichen Objektsammlung wird die neu erzeugte Kopie
	// nicht modifiziert.
	// @supby <o TRiASViews>
	// @xref <i ITRiASViews>
		[id(103), helpstring("Erzeugt eine neue Sammlung von Datenquellen, die der vorliegenden identisch ist."), hidden] HRESULT _Clone([out, retval] ITRiASViews **Views);
		[id(104), helpstring("Zuordnen des Targetobjektes zur Eventbehandlung."), hidden, restricted] HRESULT SetEventSink ([in] IUnknown *pIUnk, [in] VARIANT_BOOL fAdvise);
		[id(105), helpstring("Remove an existing view."), hidden] HRESULT RemoveView([in] ITRiASView *View);

	// @property BSTR | ITRiASViews | StartViewName | Die <op .StartViewName> -Eigenschaft liefert bzw. 
	// setzt den Namen der Ansicht, die als Start-Ansicht verwendet werden soll.
	// @supby <o TRiASViews>
	// @xref <i ITRiASViews>
		[propget, id(4), helpstring("Liefert den Namen der Ansicht, die als Start-Ansicht verwendet werden soll.")] HRESULT StartViewName([out, retval] BSTR *pVal);
		[propput, id(4), helpstring("Setzt den Namen der Ansicht, die als Start-Ansicht verwendet werden soll.")] HRESULT StartViewName([in] BSTR newVal);

	// @method HRESULT | ITRiASViews | OnFinalRelease | Die <om .OnFinalRelease>- Methode wird
	// immer dann gerufen, wenn das Objekt logisch freigegeben wird.
	// @supby <o TRiASViews> 
	// @xref <i ITRiASViews>
		[id(106), helpstring("Objekt wird logisch freigegeben.")] HRESULT OnFinalRelease();
	};

///////////////////////////////////////////////////////////////////////////////
// @doc INTERFACE TRIASDB
// @interface ITRiASView | Das Interface <i ITRiASView> dient der Verwaltung
// einer Ansicht (Legende), in der meherere Objektmengen zusammengefaßt sind, und
// die zur Anzeige gebracht werden kann.
// @supint <i ITRiASPropertyBase> | Dieses Interface wird implizit als Basisinterface des
// <i ITRiASView> implemntiert. Eine Ansicht, die über TRiASDB verfügbar gemacht werden soll,
// sollte Properties (Eigenschaften) besitzen, die über dieses Interface zugänglich gemacht werden.
// sind keine derartigen Eigenschaften vorgesehen, dann können die Methoden von <i ITRiASPropertyBase>
// in jedem Fall den Rückkehrwert <cv E_NOTIMPL> liefern.
// @supint <i ITRiASPropertySupport> | Die Implementation der Properties innerhalb der TRiASDB-Modules
// erfordert, daß die Eigenschaften selbst durch das zugehörige Parent-Objekt (in diesem Fall
// <o TRiASView>) verwaltet werden. Die Implementation der Objekte <o TRiASProperties> und
// <o TRiASProperty> basieren auf diesem Mechanismus und sind daher für alle Objekte wiederverwendbar.
// @supby <o TRiASView>
// @group Methoden und Eigenschaften von <i ITRiASView> 
// @index | IVIEW
// @doc IVIEW
	[
		object,
		uuid(1CB3AB65-2E87-11D1-969D-00A024D6F582),
		dual,
		helpstring("ITRiASView Interface"),
		pointer_default(unique)
	]
	interface ITRiASView : ITRiASBase
	{
	// @property BSTR | ITRiASView | Name | Die <op .Name>- Eigenschaft setzt bzw. liefert
	// den Bezeichner dieser Ansicht.
	// @supby <o TRiASView> 
	// @xref <i ITRiASView>
		[propget, id(DISPID_DEFAULT), helpstring("Liefert den Namen der Ansicht.")] HRESULT Name([out, retval] BSTR *pVal);
		[propput, id(DISPID_DEFAULT), helpstring("Setzt den Namen der Ansicht.")] HRESULT Name([in] BSTR newVal);

	// @property <i ITRiASViewItems> * | ITRiASView | ViewItems | Die <op .ViewItems>- 
	// Eigenschaft liefert die Sammlung aller zu dieser Ansicht gehörenden Legendeneinträge.
	// @comm Die Eigenschaft <op .ViewItems> kann nicht gesetzt werden.
	// @supby <o TRiASView>
	// @xref <i ITRiASView>, <i ITRiASViewItems>
		[propget, id(4), helpstring("Liefert die Sammlung aller zu dieser Ansicht gehörenden Legendeneinträge.")] HRESULT ViewItems([out, retval] ITRiASViewItems **pVal);

	// @property <i ITRiASViewItem> * | ITRiASView | ViewItem | Die <op .ViewItem>- 
	// Eigenschaft liefert einen zu dieser Ansicht gehörenden Legendeneintrag.
	// @parm BSTR | Name | Der Name des zu liefernden Legendeneintrages (ViewItem).
	// @parm VARIANT_BOOL | fCreate | Der Legendeneintrag soll neu erzeugt werden, wenn er 
	// noch nicht existiert.
	// @parm BSTR | Type | Wenn der Parameter <p fCreate> den Wert <cv True> besitzt und der gegebene 
	// Legendeneintrag nicht existiert, dann wird ein neuer Legendeneintrag mit dem hier vorgegeben Typ
	// neu erzeugt (ProgID). Ist der hier gegebene Typ ungültig oder nicht gegeben, dann wird ein 
	// Legendeneintrag vom Typ <o TRiASViewItem> erzeugt.
	// @comm Die Eigenschaft <op .ViewItem> kann nicht gesetzt werden.
	// @rvalue <cv S_OK> | Die Operation war erfolgreich (der Legendeneintrag existierte bereits).
	// @rvalue <cv S_FALSE> | Die Operation war erfolgreich aber der Legendeneintrag mußte neu 
	// erzeugt werden. Dieser Rückgabewert kann nur dann geliefert werden, wenn der 
	// Parameter <p fCreate> den Wert <cv True> hatte.
	// @supby <o TRiASView>
	// @xref <i ITRiASView>, <i ITRiASViewItems>
	// @end
		[propget, id(5), helpstring("Liefert einen zu dieser Ansicht gehörenden Legendeneintrag.")] HRESULT ViewItem([in] VARIANT vItem, [in /*, optional*/, defaultvalue(VARIANT_FALSE)] VARIANT_BOOL fCreate, [in /*, optional*/, defaultvalue("")] BSTR Type, [out, retval] ITRiASViewItem **pVal);

	// @property VARIANT_BOOL | ITRiASView | IsStartView | Die <op .IsStartView>- Eigenschaft setzt 
	// bzw. liefert, ob diese Ansicht als Start-Ansicht verwendet werden soll.
	// @comm Die Start-Ansicht ist diejenige Ansicht, die beim Öffnen des Projektes als Erste und ohne
	// weitere Aktionen des Nutzers angezeigt wird.
	// @supby <o TRiASView> 
	// @xref <i ITRiASView>
		[propget, id(6), helpstring("Liefert, ob diese Ansicht als Start-Ansicht verwendet werden soll.")] HRESULT IsStartView([out, retval] VARIANT_BOOL *pVal);
		[propput, id(6), helpstring("Setzt, ob diese Ansicht als Start-Ansicht verwendet werden soll.")] HRESULT IsStartView([in] VARIANT_BOOL newVal);

	// @property <i ITRiASRelations> ** | ITRiASView | Relations | Die <op .Relations>- 
	// Eigenschaft liefert bzw. setzt die Sammlung aller zu diesem COM-Objekt gehörenden Relationen 
	// (Beziehungen zu anderen Objekten).
	// @supby <o TRiASView>
	// @xref <i ITRiASView>, <i ITRiASRelations>
		[propget, id(7), helpstring("Liefert die Sammlung aller zu diesem Objekt gehörenden Relationen (Beziehungen zu anderen Objekten).")] HRESULT Relations([out, retval] ITRiASRelations **pVal);
		[propput, id(7), helpstring("Setzt die Sammlung aller zu diesem Objekt gehörenden Relationen (Beziehungen zu anderen Objekten).")] HRESULT Relations([in] ITRiASRelations *pVal);

	// @method HRESULT | ITRiASView | AddViewItem | 
	// @supby <o TRiASView> 
	// @xref <i ITRiASView>
		[id(100), helpstring("Fügt einen existierenden Einträg zu dieser Ansicht hinzu.")] HRESULT AddViewItem([in] ITRiASViewItem *Item);

	// @property <i ITRiASObjectsCollection> ** | ITRiASView | ObjectsDefs | Die <op .Properties>- 
	// Eigenschaft liefert eine Sammlung aller zu dieser Ansicht gehörenden Objektmengen.
	// @supby <o TRiASView> 
	// @xref <i ITRiASView>, <i ITRiASObjectsCollection>
		[propget, id(8), helpstring("Liefert eine Sammlung aller zu dieser Ansicht gehörenden Objektmengen.")] HRESULT ObjectsDefs([out, retval] ITRiASObjectsCollection * *pVal);

	// @method HRESULT | ITRiASView | OnFinalRelease | Die <om .OnFinalRelease>- Methode wird
	// immer dann gerufen, wenn das Objekt logisch freigegeben wird.
	// @supby <o TRiASView> 
	// @xref <i ITRiASView>
		[id(101), helpstring("Objekt wird logisch freigegeben.")] HRESULT OnFinalRelease();

	// @property BSTR | ITRiASView | RelatedDataSourceName | Die <op .RelatedDataSourceName>- 
	// Eigenschaft liefert bzw. setzt die den Namen der Datenquelle, aus der diese Ansicht 
	// ursprünglich übernommen wurde. 
	// @comm Der Wert der Eigenschaft <op .RelatedDataSourceName> wird lediglich bei der
	// Übernahme von Darstellungsparametern aus einer Datenquelle gesetzt und automatisch zurückgesetzt,
	// wenn diese Ansicht bzw. enthaltene Legendeneinträge modifiziert werden.
	// @supby <o TRiASView>
	// @xref <i ITRiASView>
		[propget, id(9), helpstring("Liefert den Namen der Ursprungs-Datenquelle.")] HRESULT RelatedDataSourceName([out, retval] BSTR *pVal);
		[propput, id(9), helpstring("Setzt den Namen der Ursprungs-Datenquelle.")] HRESULT RelatedDataSourceName([in] BSTR newVal);

	// @property BSTR | ITRiASView | ConnectionFilter | Die <op .ConnectionFilter>- 
	// Eigenschaft liefert bzw. setzt die den Namen des räumlichen Filters, der 
	// dieser Ansicht zugeordnet ist.
	// @supby <o TRiASView>
	// @xref <i ITRiASView>
		[propget, id(10), helpstring("Liefert den Namen des zugeordneten räumlichen Filters.")] HRESULT ConnectionFilter([out, retval] BSTR *pVal);
		[propput, id(10), helpstring("Setzt den Namen des zugeordneten räumlichen Filters.")] HRESULT ConnectionFilter([in] BSTR newVal);
	};

///////////////////////////////////////////////////////////////////////////////
// @doc INTERFACE TRIASDB
// @interface ITRiASViewItems | Das Interface <i ITRiASViewItems> dient der Verwaltung
// aller Einträge (Objektmengen/VisInfos) einer Ansicht (Legende).
// @supby <o TRiASViewItems>
// @group Methoden und Eigenschaften von <i ITRiASViewItems> 
// @index | IVIEWITEMS
// @doc IVIEWITEMS
	[
		object,
		uuid(1CB3AB69-2E87-11D1-969D-00A024D6F582),
		dual,
		helpstring("ITRiASViewItems Interface"),
		pointer_default(unique)
	]
	interface ITRiASViewItems : ITRiASBase
	{
	// @property LONG | ITRiASViewItems | Count | Liefert die Anzahl der in dieser Objektsammlungen 
	// enthaltenen Objekte (readonly).
	// @comm Im Unterschied zur <op .ItemCount>- Eigenschaft liefert die <op .Count>- 
	// Eigenschaft die Anzahl der <b unterschiedlichen Objektmengen>. Diese Unterscheidung ist notwendig, 
	// da eine Objektmenge verschiedene Objekttypen enthalten kann, die jeweils eine separate 
	// Visualisierungsinformation besitzen können.
	// @comm Die Eigenschaft <op .Count> kann nicht gesetzt werden.
	// @supby <o TRiASViewItems> 
	// @xref <i ITRiASViewItems>, <op ITRiASViewItems.ItemCount>
		[propget, id(3), helpstring("Number of viewitems.")] HRESULT Count([out, retval] long *pVal);

	// @method HRESULT | ITRiASViewItems | Item | 
	// @supby <o TRiASViewItems> 
	// @xref <i ITRiASViewItems>, <op ITRiASViewItems.ItemCount>
		[id(DISPID_DEFAULT), helpstring("Get the viewitem by description or by index number.")] HRESULT Item([in] VARIANT Index, [out, retval] ITRiASViewItem **ViewItem);

	// @method HRESULT | ITRiASViewItems | _NewEnum | Liefert einen neuen
	// Enumerator, der alle Objekte enthält, die in der vorliegenden Sammlung zusammengefaßt sind.
	// @parm IUnknown ** | Enum | Zeiger auf eine Variable vom Typ IUnknown *, welche nach erfolgreicher 
	// Abarbeitung der Methode <om ._NewEnum> den Ergebnis-Enumerator enthält.
	// @comm Der gelieferte Enumerator ist vom Typ <i IEnumVARIANT>. Daher sollte der Rückgabewert
	// explizit durch einen QueryInterface-Aufruf konvertiert werden.
	// @ex Das folgende Beispiel verdeutlicht die empfohlene Vorgehensweise |
	// IEnumVARIANT *pIEnum = NULL;
	// IUnknown *pIUnk = NULL;
	// HRESULT hr = pIEntries -> _NewEnum (&pIUnk);
	//
	//	if (SUCCEEDED(hr)) {
	//		hr = pIUnk -> QueryInterface(IID_IEnumVARIANT, (LPVOID *)&pIEnum);
	//		pIUnk -> Release();
	//	}
	//	...
	// @comm Normalerweise wird diese Funktion nicht direkt gerufen, Sie ist lediglich
	// für die Nutzung in Automation-Werkzeugen wie z.B. VisualBasic vorgesehen, wo sie
	// für Programmkonstrukte wie 'For Each ...' notwendig ist.
	// @supby <o TRiASViewItems> 
	// @xref <i ITRiASViewItems>, <i IEnumVARIANT>
		[id(DISPID_NEWENUM), hidden] HRESULT _NewEnum([out, retval] IUnknown **ppIEnum);

	// @property LONG | ITRiASViewItems | ItemCount | Liefert die Anzahl der in dieser Sammlung 
	// von ViewItems enthaltenen Objekttypen (readonly).
	// @comm Im Unterschied zur <op .Count>- Eigenschaft liefert die <op .ItemCount>- 
	// Eigenschaft die Anzahl der <b unterschiedlichen Objekttypen>. Diese Unterscheidung ist notwendig, 
	// da eine Objektmenge verschiedene Objekttypen enthalten kann, die jeweils eine separate 
	// Visualisierungsinformation besitzen können.
	// @comm Die Eigenschaft <op .ItemCount> kann nicht gesetzt werden.
	// @supby <o TRiASViewItems> 
	// @xref <i ITRiASViewItems>, <op ITRiASViewItems.Count>
		[propget, id(4), helpstring("Number of different objecttypes.")] HRESULT ItemCount([out, retval] long *pVal);

	// @method HRESULT | ITRiASViewItems | Add | Die <om .Add>- Methode erzeugt
	// einen neuen Ansichtseintrag und fügt diesen zur vorliegenden Sammlung von 
	// Objekten hinzu.
	// @parm BSTR | Desc |
	// @parm BSTR | Type | 
	// @supby <o TRiASViewItems>
	// @xref <i ITRiASViewItems>, <op ITRiASViewItem.Description>
	// @end
		[id(100), helpstring("Create and add a new viewitem.")] HRESULT Add([in] BSTR Desc, [in /*, optional*/, defaultvalue("")] BSTR Type, [out, retval] ITRiASViewItem **ViewItem);

	// @method HRESULT | ITRiASViewItems | Remove | Die <om .Remove>- Methode entfernt
	// einen Ansichtseintrag aus der gegebenen Sammlung von Objekten.
	// @parm VARIANT | Index | Der Parameter <p Index> kann entweder die Zählummer des
	// (0 <lt> Index <lt>= Count), den Beschreibungstext des zu entfernenden 
	// Ansichtseintrages oder ein Objekt vom Typ <o TRiASObjects> enthalten.
	// @comm Zu Beachten ist, daß wenn eine Zeichenkette als Index übergeben wird, dann wird
	// diese als Beschreibungsinformation eines Ansichtseintrages ausgewertet 
	// (die Beschreibungsinformation wird durch die <op ITRiASViewItem.Description>-
	// Eigenschaft geliefert).
	// @supby <o TRiASViewItems>
	// @xref <i ITRiASViewItems>, <op ITRiASViewItem.Description>
		[id(101), helpstring("Remove a viewitem")] HRESULT Remove([in] VARIANT Index);

	// zusätzliches
		[id(102), helpstring("Add an existing viewitem."), hidden] HRESULT _Add([in] ITRiASViewItem *ViewItem, [in /*, optional*/, defaultvalue(VARIANT_TRUE)] VARIANT_BOOL FullAdd);

	// @method HRESULT | ITRiASViewItems | _Clone | Die <om ._Clone>- Methode liefert eine neue 
	// Sammlung von Objekten, die identisch zur vorliegenden ist.
	// @parm <i ITRiASViewItems> ** | Enum | Zeiger auf eine Variable vom Typ <i ITRiASViewItems> *, 
	// welche nach erfolgreicher Abarbeitung der Methode <om ._Clone> die Kopie dieser 
	// Objektsammlung enthält.
	// @comm Bei Änderungen an der ursprünglichen Objektsammlung wird die neu erzeugte Kopie
	// nicht modifiziert.
	// @supby <o TRiASViewItems>
	// @xref <i ITRiASViewItems>
		[id(103), helpstring("Erzeugt eine neue Sammlung von ViewItems, die der vorliegenden identisch ist."), hidden] HRESULT _Clone([out, retval] ITRiASViewItems **ViewItems);

	// @method HRESULT | ITRiASViewItems | SetEventSink | Die <om .SetEventSink>- Methode erlaubt
	// dieses Objekt bei einem anderen Objekt, welches den Connectionpoint für das Interface 
	// <i ITRiASViewItemEvents> implementiert hat, anzumelden bzw. abzumelden.
	// @parm IUnknown * | Unk | Dieser Parameter muß einen Zeiger auf ein IUnknown-Interface des Objektes
	// sein, bei dem sich unser Objekt an- bzw. abmelden soll. 
	// @parm VARIANT_BOOL | fAdvise | Das Objekt wird angemeldet, wenn dieser Parameter den Wert
	// <cv VARIANT_TRUE> enthält, anderenfalls wird das Objekt abgemeldet.
	// @supby <o TRiASViewItems> 
	// @xref <i ITRiASViewItems>, <i ITRiASViewItemEvents>
		[id(104), helpstring("Zuordnen des Targetobjektes zur Eventbehandlung."), hidden, restricted] HRESULT SetEventSink ([in] IUnknown *Unk, [in] VARIANT_BOOL fAdvise);
	};

///////////////////////////////////////////////////////////////////////////////
// @doc INTERFACE TRIASDB
// @interface ITRiASViewItem | Das Interface <i ITRiASViewItem> dient der Verwaltung
// eines Legendeneintrages (einer Objektmenge, die einer Ansicht zugeordnet wurde.
// @supby <o TRiASViewItem>
// @group Methoden und Eigenschaften von <i ITRiASViewItem> 
// @index | IVIEWITEM
// @doc IVIEWITEM
	[
		object,
		uuid(1CB3AB6B-2E87-11D1-969D-00A024D6F582),
		dual,
		helpstring("ITRiASViewItem Interface"),
		pointer_default(unique)
	]
	interface ITRiASViewItem : ITRiASBase
	{
#if !defined(_OBJECTTYPE_DEFINED)
#define _OBJECTTYPE_DEFINED
	cpp_quote("#if !defined(_OBJECTTYPE_DEFINED)")
	cpp_quote("#define _OBJECTTYPE_DEFINED")
	// @doc OBJECTTYPE
	// @enum OBJECTTYPE | Mögliche Objekttypen (Geometrietypen), die ein einzelnes Objekt 
	// haben kann.
	// @xref <i ITRiASObject>, <op ITRiASObject.Type>, <op ITRiASViewItem.Types>, <op ITRiASObjects.Types>
		typedef [public, v1_enum, helpstring("Mögliche Objekttypen")] 
		enum _tagOBJECTTYPE {
			[helpstring("Punktobjekt.")] 
				OBJECTTYPE_Point = 1,		// @emem Punktobjekt
			[helpstring("Linienobjekt.")] 
				OBJECTTYPE_Line = 2,		// @emem Linienobjekt
			[helpstring("Flächenobjekt.")] 
				OBJECTTYPE_Area = 4,		// @emem Flächenobjekt
			[helpstring("Kreisfläche.")] 
				OBJECTTYPE_Circle = 4,		// @emem Flächenobjekt (Kreis/Ellipse)
			[helpstring("Textobjekt.")] 
				OBJECTTYPE_Text = 8,		// @emem Textobjekt
			[helpstring("Komplexobjekt.")] 
				OBJECTTYPE_Complex = 16,	// @emem Komplexobjekt (hierarchische Verknüpfung 
						// mehrerer Objekte, evtl. ohne eigene Geometrie
			[helpstring("Unbekannter Objekttyp.")] 
				OBJECTTYPE_Unknown = 0,		// @emem Unbekannter Objekttyp
			[helpstring("Alle bekannten einfachen Objekttypen.")] 
				OBJECTTYPE_AllSimple = 0x0f,		// @emem Alle bekannten einfachen Objekttypen
			[helpstring("Alle bekannten Objekttypen.")] 
				OBJECTTYPE_All = 0x1f,		// @emem Alle bekannten Objekttypen
		} OBJECTTYPE;
	cpp_quote("#endif // _OBJECTTYPE_DEFINED")
#endif // _OBJECTTYPE_DEFINED

	// @doc IVIEWITEM
	// @property BSTR | ITRiASViewItem | Description | Die <op .Description>- Eigenschaft setzt bzw. liefert
	// den zusätzlichen Beschreibungstext dieses Legendeneintrages.
	// @comm Dieser Beschreibungstext ist solange identisch mit dem Wert, der durch die <op .Name>-
	// Eigenschaft geliefert wird, bis er zum ersten mal modifiziert (gesetzt) wird.
	// @supby <o TRiASViewItem> 
	// @xref <i ITRiASViewItem>
		[propget, id(3), helpstring("Liefert den Beschreibungstext des Legendeneintrages.")] HRESULT Description([out, retval] BSTR *pVal);
		[propput, id(3), helpstring("Setzt den Beschreibungstext der Legendeneintrages.")] HRESULT Description([in] BSTR newVal);

	// @property <i DVisInfo> * | ITRiASViewItem | VisInfo | Die <op .VisInfo>- Eigenschaft setzt bzw. liefert
	// die Visualisierungsinformation, die diesem Ansichtseintrag zugeordnet ist.
	// @parm <t OBJECTTYPE> | Type | Der optionale Parameter <p Type> legt fest, für welchen Objekttyp die 
	// Visualisierungsinformation gesetzt bzw. abgefragt werden soll.
	// @supby <o TRiASViewItem> 
	// @xref <i ITRiASViewItem>, <i DVisInfo>
	// @end
		[propget, id(4), helpstring("Liefert die Visualisierungsinformation, die diesem Ansichtseintrag zugeordnet ist.")] HRESULT VisInfo([in /*, optional*/, defaultvalue(OBJECTTYPE_Unknown)] OBJECTTYPE Type, [out, retval] DVisInfo * *pVal);
		[propput, id(4), helpstring("Setzt die Visualisierungsinformation, die diesem Ansichtseintrag zugeordnet ist."), hidden, restricted] HRESULT VisInfo([in /*, optional*/, defaultvalue(OBJECTTYPE_Unknown)] OBJECTTYPE Type, [in] DVisInfo * newVal);

	// @property <i ITRiASObjects> * | ITRiASViewItem | Objects | Die <op .Objects>- Eigenschaft setzt bzw. liefert
	// die Objektmenge, die diesem Ansichtseintrag zugeordnet ist.
	// @parm <t OBJECTTYPE> | Type | Die Typen der Objekte, die in der übergebenen bzw. abzufragengenden 
	// Objektmenge enthalten sind (sein sollen).
	// @supby <o TRiASViewItem> 
	// @xref <i ITRiASViewItem>, <i ITRiASObjects>
		[propget, id(5), helpstring("Liefert die Objektmenge, die diesem Ansichtseintrag zugeordnet ist.")] HRESULT Objects([in] OBJECTTYPE Type, [out, retval] ITRiASObjects * *pVal);
		[propput, id(5), helpstring("Setzt die Objektmenge, die diesem Ansichtseintrag zugeordnet ist."), hidden, restricted] HRESULT Objects([in] OBJECTTYPE Type, [in] ITRiASObjects * newVal);

	// @property BSTR | ITRiASViewItem | Name | Die <op .Name>- Eigenschaft liefert
	// den Bezeichner dieses Legendeneintrages.
	// @parm BSTR | Name | Der Bezeichner des Legendeneintrages.
	// @comm Der Bezeichner des Legendeneintrages ist identisch mit dem Namen des zugehörigen
	// <o TRiASObjects>- Objektes, welches in dieses <o TRiASViewItem>- Objekt eingebettet ist.
	// Daher liefert die <op .Name>- Eigenschaft erst dann sinnvolle Werte, wenn das eingebettete 
	// <o TRiASObjects>- Objekt zugeordnet ist. Ansonsten schlägt der Aufruf dieser Funktion fehl.
	// @comm Die Eigenschaft <op .Name> kann nicht gesetzt werden.
	// @supby <o TRiASViewItem> 
	// @xref <i ITRiASViewItem>, <op ITRiASObjects.Name>
		[propget, id(DISPID_DEFAULT), helpstring("Liefert den Namen des Legendeneintrages.")] HRESULT Name([out, retval] BSTR *pVal);

	// @property <t OBJECTTYPE> | ITRiASViewItem | ObjectTypes | Die <op .ObjectType>- Eigenschaft liefert
	// bzw. setzt die Objekttypen, die zu einem Legendeneintrag gehören sollen.
	// @parm <t OBJECTTYPE> | ObjectType | Die Typen der Objekte, die in dem zugehörigen Legendeneintrag
	// enthalten sein sollen.
	// @comm Im Unterschied zur <op .Types>- Eigenschaft liefert die <op .ObjectTypes>- Eigenschaft
	// sämtliche Objekttypen, die durch die unterliegende Objects-collection repräsentiert werden.
	// @comm Das setzen eines Objekttypes mit dieser Funktion ist dann erforderlich, wenn ein 
	// Legendeneintrag zwar einen Objekttyp vordefiniert enthalten soll, jedoch keine entsprechenden Objekte 
	// existieren.
	// @supby <o TRiASViewItem> 
	// @xref <i ITRiASViewItem>, <t OBJECTTYPE>, <op ITRiASObjects.Types>, <op ITRiASViewItem.Types>
		[propget, id(7), helpstring("Liefert die zu diesem Legendeneintrag gehörenden Objekttypen.")] HRESULT ObjectTypes([out, retval] OBJECTTYPE *pVal);
		[propput, id(7), helpstring("Fügt einen Objekttyp zum Legendeneintrag hinzu.")] HRESULT ObjectTypes([in] OBJECTTYPE newVal);

	// @property <t OBJECTTYPE> | ITRiASViewItem | Types | Die <op .Types>- Eigenschaft setzt bzw. liefert
	// die diesem Legendeneintrag zugeordneten Objekttypen.
	// @comm Im Unterschied zur <op .ObjectTypes>- Eigenschaft liefert die <op .Types>- Eigenschaft
	// lediglich die Objekttypen, für die in diesem Legendeneintrag eine Visualisierungsinformation 
	// vorgegeben wurde, bzw. die durch einen entsprechenden Aufruf der <op .Types>-
	// Eigenschaft eingestellt wurden.
	// <nl>Wird ein Objekttyp zu diesem Legendeneintrag hinzugefügt, ohne, daß eine
	// Visualisierungsinformation vorgegeben wird, dann wird eine Standard-Visualisierung
	// verwendet.
	// @comm Der Legendeneintrag kann unter Umständen weniger Objekttypen enthalten, als die
	// zugehörige Objektsammlung.
	// @supby <o TRiASViewItem>
	// @xref <i ITRiASViewItem>, <t OBJECTTYPE>, <op ITRiASObjects.Types>, <op ITRiASViewItem.ObjectTypes>,
	// <op ITRiASViewItem.DefaultTypes>
		[propget, id(8), helpstring("Liefert die diesem Legendeneintrag zugeordneten Objekttypen.")] HRESULT Types([out, retval] OBJECTTYPE *pVal);
		[propput, id(8), helpstring("Setzt die diesem Legendeneintrag zugeordneten Objekttypen.")] HRESULT Types([in] OBJECTTYPE newVal);

	// @property <t OBJECTTYPE> | ITRiASViewItem | DefaultTypes | Die <op .DefaultTypes>- Eigenschaft 
	// setzt bzw. liefert die diesem Legendeneintrag zugeordneten Objekttypen, für die keine
	// Visualisierungsinformation gegeben ist.
	// @comm Im Unterschied zur <op .ObjectTypes>- Eigenschaft liefert die <op .Types>- Eigenschaft
	// lediglich die Objekttypen, für die in diesem Legendeneintrag eine Visualisierungsinformation 
	// vorgegeben wurde, bzw. die durch einen entsprechenden Aufruf der <op .Types>-
	// Eigenschaft eingestellt wurden.
	// <nl>Wird ein Objekttyp zu diesem Legendeneintrag hinzugefügt, ohne, daß eine
	// Visualisierungsinformation vorgegeben wird, dann wird eine Standard-Visualisierung
	// verwendet. In diesem Fall wird automatisch die <op .DefaultTypes>- Eigenschaft
	// beeinflußt.
	// @comm Der Legendeneintrag kann unter Umständen weniger Objekttypen enthalten, als die
	// zugehörige Objektsammlung.
	// @supby <o TRiASViewItem>
	// @xref <i ITRiASViewItem>, <t OBJECTTYPE>, <op ITRiASViewItem.Types>, <op ITRiASViewItem.ObjectTypes>
		[propget, id(9), helpstring("Liefert die diesem Legendeneintrag zugeordneten Objekttypen, für die keine Visualisierungsinformation gesetzt ist.")] HRESULT DefaultTypes([out, retval] OBJECTTYPE *pVal);
		[propput, id(9), helpstring("Setzt die diesem Legendeneintrag zugeordneten Objekttypen, für die keine Visualisierungsinformation gesetzt ist.")] HRESULT DefaultTypes([in] OBJECTTYPE newVal);

	// @property LONG | ITRiASViewItem | ItemCount | Liefert die Anzahl der in diesem 
	// Legendeneintrag enthaltenen <b verschiedenen Objekttypen> (readonly)
	// @comm Die Eigenschaft <op .ItemCount> kann nicht gesetzt werden.
	// @supby <o TRiASViewItem> 
	// @xref <i ITRiASViewItem>
		[propget, id(10), helpstring("Number of different objecttypes.")] HRESULT ItemCount([out, retval] long *pVal);

	// @property <i ITRiASObjects> * | ITRiASViewItem | ObjectsMoniker | Die <op .Objects>- Eigenschaft setzt bzw. liefert
	// den Monikerstring (DisplayName) der Objektmenge, die diesem Ansichtseintrag zugeordnet ist.
	// @parm <t OBJECTTYPE> | Type | Die Typen der Objekte, die durch den übergebenen bzw. abzufragengenden 
	// MonikerString einer Objektmenge enthalten sind (sein sollen).
	// @supby <o TRiASViewItem> 
	// @xref <i ITRiASViewItem>, <i ITRiASObjects>
		[propget, id(11), helpstring("Liefert den Monikerstring (DisplayName) der Objektmenge, die diesem Ansichtseintrag zugeordnet ist.")] HRESULT ObjectsMoniker([in] OBJECTTYPE rgType, [out, retval] BSTR *pVal);
		[propput, id(11), helpstring("Setzt den Monikerstring (DisplayName) der Objektmenge, die diesem Ansichtseintrag zugeordnet ist.")] HRESULT ObjectsMoniker([in] OBJECTTYPE rgType, [in] BSTR newVal);
	};

///////////////////////////////////////////////////////////////////////////////
// Ein Objekt
// @doc INTERFACE TRIASDB
// @interface ITRiASObject | Das Interface <i ITRiASObject> dient der Verwaltung
// eines Objektes eines Datenquelle.
// @supint <i ITRiASPropertyBase> | Dieses Interface wird implizit als Basisinterface des
// <i ITRiASObject> implementiert. Über dieses Interface werden die Eigenschaften 
// des jeweiligen Objektes zugänglich gemacht. Sind keine derartigen Eigenschaften vorgesehen, 
// dann können die Methoden von <i ITRiASPropertyBase> den Rückgabewert <cv E_NOTIMPL> liefern.
// @supby <o TRiASObject>, <o TRiASSimpleObject>
// @group Methoden und Eigenschaften von <i ITRiASObject> 
// @index | IOBJECT
// @doc IOBJECT
	[
		object,
		uuid(1CB3AB6F-2E87-11D1-969D-00A024D6F582),
		dual,
		helpstring("ITRiASObject Interface"),
		pointer_default(unique)
	]
	interface ITRiASObject : ITRiASBase
	{
	// @property OBJECTTYPE | ITRiASObject | Type | Die <op .Type>- Eigenschaft liefert den 
	// Geometrietyp, den dieses Objekt hat.
	// @comm Die Eigenschaft <op .Type> kann nicht gesetzt werden.
	// @supby <o TRiASObject> 
	// @xref <i ITRiASObject>, <t OBJECTTYPE>
		[propget, id(3), helpstring("Liefert den Geometrietyp, den dieses Objekt hat.")] HRESULT Type([out, retval] OBJECTTYPE *pVal);
		[propput, id(3), helpstring("Setzt den Geometrietyp, den dieses Objekt hat."), restricted, hidden] HRESULT Type([in] OBJECTTYPE newVal);

	// @property BSTR | ITRiASObject | Name | Die <op .Name>- Eigenschaft liefert bzw. setzt den 
	// Namen dieses Objektes.
	// @comm Der gegebene Name sollte ein eindeutiger Bezeichner des Objektes sein, der es erlaubt, dieses
	// Objekt eindeutig zu identifizieren und wiederzufinden.
	// @supby <o TRiASObject> 
	// @xref <i ITRiASObject>
		[propget, id(DISPID_DEFAULT), helpstring("Liefert den Namen dieses Objektes.")] HRESULT Name([out, retval] BSTR *pVal);
		[propput, id(DISPID_DEFAULT), helpstring("Setzt den Namen dieses Objektes."), hidden] HRESULT Name([in] BSTR newVal);

	// @property LONG | ITRiASObject | Handle | Die <op .Handle>- Eigenschaft liefert die eindeutige 
	// Zugriffsnummer dieses Objektes. Die Eigenschaft kann gesetzt werden, um eine Voreinstellung
	// für die Zugriffsnummer vorzugeben. Diese Voreinstellung wird immer dann als Zugriffsnummer 
	// für dieses Objekt verwendet werden, wenn diese noch nicht für ein anderes Objekt identischen 
	// Types vergeben worden ist. Das setzen dieser Eigenschaft hat nur dann eine Wirkung, wenn noch
	// keine Zugriffsnummer für dieses Objekt vergeben wurde.
	// @supby <o TRiASObject>
	// @xref <i ITRiASObject>
		[propget, id(5), helpstring("Liefert die eindeutige Zugriffsnummer dieses Objektes."), hidden, restricted] HRESULT Handle([out, retval] INT_PTR *pVal);
		[propput, id(5), helpstring("Setzt eine Voreinstellung für die eindeutige Zugriffsnummer dieses Objektes."), hidden, restricted] HRESULT Handle([in] INT_PTR newVal);

	// @property LONG | ITRiASObject | ObjectsHandle | Die <op .ObjectsHandle>- Eigenschaft setzt bzw. liefert 
	// die eindeutige Zugriffsnummer der Basis-Objektmenge (GeoMedia:Tabelle, ArcInfo:Cover, 
	// TRiAS:Identifikator et.al.), zu der dieses Objekt gehört.
	// @supby <o TRiASObject>
	// @xref <i ITRiASObject>
		[propget, id(6), helpstring("Liefert die eindeutige Zugriffsnummer der zu diesem Objekt gehörenden Objektmenge."), hidden, restricted] HRESULT ObjectsHandle([out, retval] INT_PTR *pVal);
		[propput, id(6), helpstring("Setzt die eindeutige Zugriffsnummer der zu diesem Objekt gehörenden Objektmenge."), hidden, restricted] HRESULT ObjectsHandle([in] INT_PTR newVal);

	// @property <i ITRiASObjectCallback> * | ITRiASObject | ObjectCallback | Die <op .ObjectCallback>- Eigenschaft 
	// initialisiert das Rückrufinterface, über welches die Objektspezifik definiert wird.
	// @comm Das übergebene Objekt wird nicht festgehalten (kein AddRef!).
	// @supby <o TRiASObject> 
	// @xref <i ITRiASObject>, <i ITRiASObjectCallback>
		[propputref, id(7), helpstring("Zuordnen des Objektes, welches die Spezifik dieses Objektes definiert.")] HRESULT ObjectCallback(ITRiASObjectCallback *pICB);

	// @property LONG | ITRiASObject | DatabaseHandle | Die <op .DatabaseHandle>- Eigenschaft 
	// liefert die eindeutige Zugriffsnummer der Datenbank, zu der dieses Objekt gehört.
	// @comm Die Eigenschaft <op .DatabaseHandle> kann nicht gesetzt werden.
	// @supby <o TRiASObject> 
	// @xref <i ITRiASObject>
		[propget, id(8), helpstring("Liefert die eindeutige Zugriffsnummer der Datenbank, zu der dieses Objekt gehört.")] HRESULT DatabaseHandle([out, retval] INT_PTR *pVal);

	// @property <i ITRiASFeatures> * | ITRiASObject | Features | Die <op .Features>- Eigenschaft 
	// liefert bzw. setzt die Menge aller Objekteigenschaften, die durch dieses Objekt unterstützt werden.
	// @supby <o TRiASObject> 
	// @xref <i ITRiASObject>, <i ITRiASFeatures>
		[propget, id(9), helpstring("Liefert die Menge aller Objekteigenschaften, die durch dieses Objekt unterstützt werden.")] HRESULT Features([out, retval] ITRiASFeatures **pVal);
		[propput, id(9), helpstring("Setzt die Menge aller Objekteigenschaften, die durch dieses Objekt unterstützt werden.")] HRESULT Features([in] ITRiASFeatures * newVal);

	// @property <i ITRiASFeatures> * | ITRiASObject | GeometryFeatures | Die <op .GeometryFeatures>- Eigenschaft 
	// liefert bzw. setzt die Menge aller Geometrie-Objekteigenschaften, die durch dieses Objekt unterstützt 
	// werden.
	// @supby <o TRiASObject> 
	// @xref <i ITRiASObject>, <i ITRiASFeatures>
		[propget, id(10), helpstring("Liefert die Menge aller Geometrie-Objekteigenschaften, die durch dieses Objekt unterstützt werden.")] HRESULT GeometryFeatures([out, retval] ITRiASFeatures **pVal);
		[propput, id(10), helpstring("Setzt die Menge aller Geometrie-Objekteigenschaften, die durch dieses Objekt unterstützt werden.")] HRESULT GeometryFeatures([in] ITRiASFeatures * newVal);

	// @method HRESULT | ITRiASObject | Delete | Die <om .Delete>- Methode wird gerufen, wenn
	// das Objekt aus der zugehörigen Datenbank gelöscht werden soll. Gleichzeitigt gibt sie alle 
	// Referenzen auf abhängige Objekte frei.
	// @supby <o TRiASObject> 
	// @xref <i ITRiASObject>
		[id(100), helpstring("Das Objekt soll aus der zugehörigen Datenbank gelöscht werden.")] HRESULT Delete();
	};

///////////////////////////////////////////////////////////////////////////////
// @doc INTERFACE TRIASDB
// @interface ITRiASObjectCallback | Das Interface <i ITRiASObjectCallback> dient der Verwaltung
// eines Objektes.
// @supby <o TRiASSimpleObject>
// @group Methoden und Eigenschaften von <i ITRiASObjectCallback> 
// @index | IOBJECTCALLBACK
// @doc IOBJECTCALLBACK
	[
		object,
		uuid(3F9633F4-C718-11D1-85D6-00600875138A),
		oleautomation,
		helpstring("ITRiASObjectCallback Interface"),
		pointer_default(unique)
	]
	interface ITRiASObjectCallback : IUnknown
	{
	cpp_quote("#if !defined(_CHANGEDOBJECT_DEFINED)")
	cpp_quote("#define _CHANGEDOBJECT_DEFINED")
	// @doc CHANGEDOBJECTENUMS 
	// @enum CHANGEDOBJECT | Flags geben an, was in einem Bezugsobjekt vom Typ <o TRiASObjects> 
	// modifiziert werden soll bzw. modifiziert worden ist.
	// @xref <i ITRiASObjectCallback>, <om ITRiASObjectCallback.OnChanging>, <om ITRiASObjectCallback.OnChanged>
		typedef [public, v1_enum, helpstring("Flags, was im Bezugsobjekt modifiziert werden soll/modifiert wurde.")]
		enum _tagCHANGEDOBJECT {
			[helpstring("Name wurde modifiziert.")]
				CHANGEDOBJECT_Name = 0x01,			// @emem Name wurde modifiziert
			[helpstring("Eindeutige Zugriffsnummer wurde modifiziert.")]
				CHANGEDOBJECT_Handle = 0x02,		// @emem Eindeutige Zugriffsnummer wurde modifiziert
			[helpstring("Objekttyp wurde modifiziert (initialisiert).")]
				CHANGEDOBJECT_Type = 0x04,		// @emem Objekttyp wurde modifiziert (initialisiert
		} CHANGEDOBJECT;
	cpp_quote("#endif // _CHANGEDOBJECT_DEFINED")

	cpp_quote("#if !defined(_SETUPOBJECTMODE_DEFINED)")
	cpp_quote("#define _SETUPOBJECTMODE_DEFINED")
	// @doc SETUPOBJECTMODEENUMS 
	// @enum SETUPOBJECTMODE | Der Mode, in dem dieses Objekt geladen werden soll.
	// @xref <i ITRiASObjectCallback>, <om ITRiASObjectCallback.SetupObject>
		typedef [public, v1_enum, helpstring("Modi zum Laden eines Objektes")]
		enum _tagSETUPOBJECTMODE {
			[helpstring("Objektinstanz initialisieren.")]
				SETUPOBJECTMODE_InitOrLoad = 0,		// @emem Objektinstanz initialisieren
			[helpstring("Normales laden, wenn notwendig.")]
				SETUPOBJECTMODE_Normal = 1,			// @emem Normales laden, wenn notwendig
			[helpstring("Angeforderte Aktion erneut erzwingen.")]
				SETUPOBJECTMODE_Force = 0x8000,		// @emem Angeforderte Aktion erneut erzwingen
		} SETUPOBJECTMODE;
	cpp_quote("#endif // _SETUPOBJECTMODE_DEFINED")

	cpp_quote("#if !defined(_SETUPFEATURESMODE_DEFINED)")
	cpp_quote("#define _SETUPFEATURESMODE_DEFINED")
	// @doc SETUPFEATURESMODEENUMS 
	// @enum SETUPFEATURESMODE | Der Mode, in dem die Metadaten einer Objekteigenschaftsmenge geladen werden sollen.
	// @xref <i ITRiASFeaturesCallback>, <om ITRiASFeaturesCallback.SetupFeatures>
		typedef [public, v1_enum, helpstring("Modi zum Laden der Metadaten einer Objekteigenschaftsmenge.")]
		enum _tagSETUPFEATURESMODE {
			[helpstring("Objektinstanz initialisieren.")]
				SETUPFEATURESMODE_InitOrLoad = 0,		// @emem Objektinstanz initialisieren
			[helpstring("Normale Initialisierung.")]
				SETUPFEATURESMODE_Normal = 1,			// @emem Normale Initialisierung
			[helpstring("Objektmenge intern rücksetzen.")]
				SETUPFEATURESMODE_Reset = 2,			// @emem Objektmenge intern rücksetzen
			[helpstring("Angeforderte Aktion erneut erzwingen.")]
				SETUPFEATURESMODE_Force = 0x8000,		// @emem Angeforderte Aktion erneut erzwingen
		} SETUPFEATURESMODE;
	cpp_quote("#endif // _SETUPFEATURESMODE_DEFINED")

	// @property BSTR * | ITRiASObjectCallback | DefaultType | Die <op .DefaultType>- Eigenschaft
	// liefert den Type (ProgID) des im Standardfall zu instantiierenden Objektes.
	// @supby <o TRiASSimpleObject> 
	// @xref <i ITRiASObjectCallback>
		[propget, helpstring("Typ des standardmäßig zu erzeugenden Objektes.")] HRESULT DefaultType([out, retval] BSTR *Type);

	// @method HRESULT | ITRiASObjectCallback | SetupObject | Die <om .SetupObject>- Methode
	// fordert das Bezugsobjekt auf, sich vollständig zu initialisieren.
	// @parm <t SETUPOBJECTMODE> | SetupMode | der Parameter <p SetupMode> gibt vor, welche Informationen sichergestellt 
	// werden sollen.
	// @supby <o TRiASSimpleObject> 
	// @xref <i ITRiASObjectCallback>, <t SETUPOBJECTMODE>
	// @end
		[helpstring("Initialiseren der Metadaten dieses Objektes.")] HRESULT SetupObject([in /*, optional*/, defaultvalue(SETUPOBJECTMODE_Normal)] SETUPOBJECTMODE SetupMode);

	// @method HRESULT | ITRiASObjectCallback | SetupFeatures | Die <om .SetupFeatures>- Methode
	// fordert das Bezugsobjekt auf, die zu dieser Objektmenge gehörenden Objekteigenschaften zu 
	// initialisieren.
	// @parm <t SETUPFEATURESMODE> | SetupMode | Erzwingt gegebenenfalls das Neuinitialisieren evtl. eingelesener
	// Objekteigenschaften.
	// @comm Die Methode <om .SetupFeatures> muß lediglich für bestimmte Typen von Objekten unterstützt werden.
	// In erster Linie sicher für nichtrelationale Datenbankstrukturen (wie z.B. <tr> -Datenbanken.
	// @supby <o TRiASSimpleObject> 
	// @xref <i ITRiASObjectCallback>, <t SETUPFEATURESMODE>
	// @end
		[helpstring("Initialisierung aller Objekteigenschaften dieses Objektes")] HRESULT SetupFeatures([in /*, optional*/, defaultvalue(SETUPFEATURESMODE_Normal)] SETUPFEATURESMODE SetupMode);

	// @method HRESULT | ITRiASObjectCallback | OnChanging | Die <om .OnChanging>- Methode wird
	// immer dann gerufen, wenn das Bezugsobjekt in irgend einer Form modifiziert werden soll.
	// @parm <t CHANGEDOBJECT> | rgWhat | Der Parameter <p rgWhat> gibt an, was im Bezugsobjekt 
	// modifiziert werden soll.
	// @parm VARIANT | OldValue | Der Parameter <p NewValue> enthält den neuen Wert der eingestellt 
	// werden soll.
	// @parm VARIANT_BOOL * | DisAllow | Durch Setzen des Wertes des Parameters <p DisAllow> auf
	// <cv VARIANT_TRUE> kann die durchzuführende Aktion abgebrochen werden. Durch Setzen auf den Wert
	// <cv VARIANT_FALSE> wird das Einverständnis erteilt, die Aktion durchzuführen.
	// @supby <o TRiASSimpleObject> 
	// @xref <i ITRiASObjectCallback>, <t CHANGEDOBJECT>
		[helpstring("Irgend etwas wird modifiziert werden.")] HRESULT OnChanging([in] CHANGEDOBJECT rgWhat, [in] VARIANT NewValue, [out, retval] VARIANT_BOOL *DisAllow);

	// @method HRESULT | ITRiASObjectCallback | OnChanged | Die <om .OnChanged>- Methode wird
	// immer dann gerufen, wenn das Bezugsobjekt in irgend einer Form modifiziert wurde.
	// @parm <t CHANGEDOBJECT> | rgWhat | Der Parameter <p rgWhat> gibt an, was im Bezugsobjekt 
	// modifiziert wurde.
	// @parm VARIANT | OldValue | Der Parameter <p NewValue> enthält den alten Wert der vor der
	// Modifikation eingestellt gewesen war.
	// @supby <o TRiASSimpleObject> 
	// @xref <i ITRiASObjectCallback>, <t CHANGEDOBJECT>
		[helpstring("Irgend etwas wurde modifiziert.")] HRESULT OnChanged([in] CHANGEDOBJECT rgWhat, [in] VARIANT OldValue);

	// @method HRESULT | ITRiASObjectCallback | OnDelete | Die <om .OnDelete>- Methode
	// fordert das Bezugsobjekt auf, sich aus der Datenbank zu löschen und alle abhängigen 
	// Objekte freizugeben.
	// @supby <o TRiASSimpleObject> 
	// @xref <i ITRiASObjectCallback>
		[helpstring("Löschen dieses Objektes.")] HRESULT OnDelete();

	// @method HRESULT | ITRiASObjectsCallback | OnFinalRelease | Die <om .OnFinalRelease>- Methode wird
	// immer dann gerufen, wenn das Objekt logisch freigegeben wird.
	// @supby <o TRiASSimpleObjects> 
	// @xref <i ITRiASObjectsCallback>
		[helpstring("Objekt wird logisch freigegeben.")] HRESULT OnFinalRelease();
	};

///////////////////////////////////////////////////////////////////////////////
// @doc INTERFACE TRIASDB
// @interface ITRiASObjects | Das Interface <i ITRiASObjects> dient der Verwaltung
// einer Objektmenge.
// @supint <i ITRiASPropertyBase> | Dieses Interface wird implizit als Basisinterface des
// <i ITRiASObjects> implemntiert. Über dieses Interface werden die Eigenschaften 
// der jeweiligen Objektmenge zugänglich gemacht. Objektmengen, die einer Objektklasse entsprechen 
// exportieren hier z.B. die Objektklassen-Eigenschaften (Objektklassenschlüssel, Beschreibungsinfos
// oder andere Metadaten). Sind keine derartigen Eigenschaften vorgesehen, dann können die Methoden 
// von <i ITRiASPropertyBase> den Rückgabewert <cv E_NOTIMPL> liefern.
// @supby <o TRiASObjects>, <o TRiASSimpleObjects>
// @group Methoden und Eigenschaften von <i ITRiASObjects> 
// @index | IOBJECTS
// @doc IOBJECTS
	[
		object,
		uuid(1CB3AB6D-2E87-11D1-969D-00A024D6F582),
		dual,
		helpstring("ITRiASObjects Interface"),
		pointer_default(unique)
	]
	interface ITRiASObjects : ITRiASBase
	{
	cpp_quote("#if !defined(_OBJECTSCOLLECTIONTYPE_DEFINED)")
	cpp_quote("#define _OBJECTSCOLLECTIONTYPE_DEFINED")
	// @doc OBJECTSCOLLECTIONTYPE
	// @enum OBJECTSCOLLECTIONTYPE | Mögliche Typen einer TRiASObjects-collection
	// @xref <i ITRiASObjects>, <op ITRiASObjects.CollectionType>
		typedef [public, v1_enum, helpstring("Mögliche Typen einer TRiASObjects-collection")] 
		enum _tagOBJECTSCOLLECTIONTYPE {
			[helpstring("Unbekannter Objektmengentyp.")] 
				OBJECTSCOLLECTIONTYPE_Unknown = 0,		// @emem Unbekannter Objektmengentyp
			[helpstring("Objektmenge entspricht einer Objektklasse.")] 
				OBJECTSCOLLECTIONTYPE_Class = 1,		// @emem Objektmenge entspricht einer Objektklasse
			[helpstring("Objektmenge entspricht einem Rechercheergebnis.")] 
				OBJECTSCOLLECTIONTYPE_Query = 2,		// @emem Objektmenge entspricht einem Rechercheergebnis
			[helpstring("Temporäre Objektmenge.")] 
				OBJECTSCOLLECTIONTYPE_Temporary = 4,	// @emem Temporäre Objektmenge
		} OBJECTSCOLLECTIONTYPE;
	cpp_quote("#endif // _OBJECTSCOLLECTIONTYPE_DEFINED")

	cpp_quote("#if !defined(_CLASSIFYMODE_DEFINED)")
	cpp_quote("#define _CLASSIFYMODE_DEFINED")
	// @doc CLASSIFYMODE
	// @enum CLASSIFYMODE | Mögliche Modi bei der Umklassifizierung von Objekten
	// @xref <i ITRiASObjects>, <om ITRiASObjects.Classify>
		typedef [public, v1_enum, helpstring("Mögliche Modi bei der Umklassifizierung von Objekten")] 
		enum _tagCLASSIFYMODE {
			[helpstring("Keine Umklassifizierung vornehmen")]
				CLASSIFYMODE_DoNotClassify = 0x00,			// @emem Keine Umklassifizierung vornehmen
			[helpstring("Lediglich innerhalb einer Datenquelle klassifizieren.")] 
				CLASSIFYMODE_DatasourceOnly = 0x01,			// @emem Lediglich innerhalb einer Datenquelle klassifizieren
			[helpstring("In der Zielobjektmenge nicht existierende Objekteigenschaften üignorieren.")] 
				CLASSIFYMODE_IgnoreNewProperties = 0x02,	// @emem In der Zielobjektmenge nicht existierende Objekteigenschaften übernehmen
			[helpstring("Objekttyp wurde festgelegt.")] 
				CLASSIFYMODE_InitObjectType = 0x04,			// @emem Objekttyp wurde festgelegt
		} CLASSIFYMODE;
	cpp_quote("#endif // _CLASSIFYMODE_DEFINED")

	// @doc IOBJECTS
	// @property LONG | ITRiASObjects | Count | Liefert die Anzahl der in dieser Objektsammlungen 
	// enthaltenen Objekte (readonly).
	// @comm Die Eigenschaft <op .Count> kann nicht gesetzt werden.
	// @supby <o TRiASObjects> 
	// @xref <i ITRiASObjects>
		[propget, id(3), helpstring("Liefert die Anzahl der Objekte in dieser Objektmenge.")] HRESULT Count([out, retval] long *pVal);
		[propput, id(3), hidden, restricted, helpstring("Setzt die Anzahl der Objekte in dieser Objektmenge.")] HRESULT Count([in] long newVal);

	// @property BSTR | ITRiASObjects | Name | Die <op .Name>- Eigenschaft setzt bzw. liefert
	// den Bezeichner dieser Objektmenge.
	// @supby <o TRiASObjects>
	// @xref <i ITRiASObjects>
		[propget, id(4), helpstring("Liefert den Namen dieser Objektmenge.")] HRESULT Name([out, retval] BSTR *pVal);
		[propput, id(4), helpstring("Setzt den Namen dieser Objektmenge.")] HRESULT Name([in] BSTR newVal);

	// @property BSTR | ITRiASObjects | Description | Die <op .Description>- Eigenschaft setzt bzw. liefert
	// einen ausführlicheren Beschreibungstext dieser Objektmenge.
	// @supby <o TRiASObjects>
	// @xref <i ITRiASObjects>
		[propget, id(5), helpstring("Liefert den Beschreibungstext dieser Objektmenge.")] HRESULT Description([out, retval] BSTR *pVal);
		[propput, id(5), helpstring("Setzt den Beschreibungstext dieser Objektmenge.")] HRESULT Description([in] BSTR newVal);

	// @property BSTR | ITRiASObjects | Name | Die <op .Name>- Eigenschaft setzt bzw. liefert
	// den Bezeichner dieser Objektmenge.
	// @comm Die Eigenschaft <op .TableName> kann nicht gesetzt werden.
	// @supby <o TRiASObjects>
	// @xref <i ITRiASObjects>
		[propget, id(6), helpstring("Liefert den Tabellennamen dieser Objektmenge.")] HRESULT TableName([out, retval] BSTR *pVal);

	// @property <t OBJECTTYPE> | ITRiASObjects | Types | Die <op .Types>- Eigenschaft setzt bzw. liefert
	// die Objekttypen, die in dieser Objektmenge enthalten sind.
	// @supby <o TRiASObjects>
	// @xref <i ITRiASObjects>, <t OBJECTTYPE>
		[propget, id(7), helpstring("Liefert die in dieser Objektmenge enthaltenen Objekttypen.")] HRESULT Types([out, retval] OBJECTTYPE *pVal);
		[propput, id(7), helpstring("Setzt die in dieser Objektmenge enthaltenen Objekttypen.")] HRESULT Types([in] OBJECTTYPE newVal);

	// @property LONG | ITRiASObjects | Handle | Die <op .Handle>- Eigenschaft liefert die eindeutige 
	// Zugriffsnummer dieser Objektmenge. Die Eigenschaft kann gesetzt werden, um eine Voreinstellung
	// für die Zugriffsnummer vorzugeben. Diese Voreinstellung wird immer dann als Zugriffsnummer für 
	// dieses Objekt verwendet werden, wenn diese noch nicht für ein anderes Objekt identischen Types 
	// vergeben worden ist. Das setzen dieser Eigenschaft hat nur dann eine Wirkung, wenn noch keine 
	// Zugriffsnummer für dieses Objekt vergeben wurde.
	// @supby <o TRiASObjects>
	// @xref <i ITRiASObjects>
		[propget, id(8), helpstring("Liefert die eindeutige Zugriffsnummer dieser Objektmenge."), hidden, restricted] HRESULT Handle([out, retval] INT_PTR *pVal);
		[propput, id(8), helpstring("Setzt die Voreinstellung für die eindeutige Zugriffsnummer dieser Objektmenge."), hidden, restricted] HRESULT Handle([in] INT_PTR newVal);

	// @property LONG | ITRiASObjects | OKS | Die <op .OKS>- Eigenschaft setzt bzw. liefert den
	// Objektklassenschlüssel, der dieser Objektmenge zugeordnet ist.
	// @supby <o TRiASObjects>
	// @xref <i ITRiASObjects>
		[propget, id(9), helpstring("Liefert den Objektklassenschlüssel für diese Objektmenge.")] HRESULT OKS([out, retval] BSTR *pVal);
		[propput, id(9), helpstring("Setzt den Objektklassenschlüssel für diese Objektmenge.")] HRESULT OKS([in] BSTR newVal);

	// @property <i ITRiASObjectsCallback> * | ITRiASObjects | ObjectsCallback | Die <op .ObjectsCallback>- Eigenschaft 
	// initialisiert das Rückrufinterface, über welches die Objektspezifik definiert wird.
	// @comm Das übergebene Objekt wird nicht festgehalten (kein AddRef!).
	// @supby <o TRiASObjects> 
	// @xref <i ITRiASObjects> <i ITRiASObjectsCallback>
		[propputref, id(10), helpstring("Zuordnen des Objektes, welches die Spezifik dieser Objektmenge definiert.")] HRESULT ObjectsCallback(ITRiASObjectsCallback *pICB);

	// @property <i ITRiASFeatures> * | ITRiASObjects | Features | Die <op .Features>- Eigenschaft 
	// liefert bzw. setzt die Menge aller Objekteigenschaften, die durch alle Objekte dieser Objektmenge 
	// unterstützt werden.
	// @supby <o TRiASObjects> 
	// @xref <i ITRiASObjects>, <i ITRiASFeatures>
		[propget, id(11), helpstring("Liefert die Menge aller Objekteigenschaften, die durch alle Objekte dieser Objektmenge unterstützt werden.")] HRESULT Features([out, retval] ITRiASFeatures **pVal);
		[propput, id(11), helpstring("Setzt die Menge aller Objekteigenschaften, die durch alle Objekte dieser Objektmenge unterstützt werden.")] HRESULT Features([in] ITRiASFeatures * newVal);

	// @property <i ITRiASFeature> | ITRiASObjects | Feature | Die <op .Feature>- Eigenschaft 
	// Liefert bzw. erzeugt eine Objekteigenschaft, die durch alle Objekte dieser 
	// Objektmenge unterstützt werden.
	// @parm VARIANT | Item | Die zu liefernde/erzeugende Objekteigenschaft.
	// @parm VARIANT_BOOL | fCreate | Die Objekteigenschaft soll neu erzeugt werden, wenn sie
	// noch nicht existiert.
	// @parm BSTR | Type | Wenn der Parameter <p fCreate> den Wert <cv True> besitzt und die gegebene 
	// Objekteigenschaft nicht existiert, dann wird eine neue Objekteigenschaft mit dem hier vorgegeben Typ
	// neu erzeugt (ProgID). Ist der hier gegebene Typ ungültig oder nicht gegeben, dann wird eine 
	// Objekteigenschaft vom Typ <o TRiASFeature> erzeugt.
	// @comm Die Eigenschaft <op .Feature> kann nicht gesetzt werden.
	// @rvalue <cv S_OK> | Die Operation war erfolgreich (die Objekteigenschaft existierte bereits).
	// @rvalue <cv S_FALSE> | Die Operation war erfolgreich aber die Objekteigenschaft mußte neu 
	// erzeugt werden. Dieser Rückgabewert kann nur dann geliefert werden, wenn der 
	// Parameter <p fCreate> den Wert <cv True> hatte.
	// @supby <o TRiASObjects> 
	// @xref <i ITRiASObjects>, <i ITRiASFeature>
	// @end
		[propget, id(12), helpstring("Liefert bzw. erzeugt eine Objekteigenschaft, die durch alle Objekte dieser Objektmenge unterstützt werden.")] HRESULT Feature([in] VARIANT Item, [in /*, optional*/, defaultvalue(VARIANT_FALSE)] VARIANT_BOOL Create, [in /*, optional*/, defaultvalue("")] BSTR Type, [out, retval] ITRiASFeature **pVal);

	// @property <i ITRiASFeatures> * | ITRiASObjects | GeometryFeatures | Die <op .GeometryFeatures>- Eigenschaft 
	// liefert bzw. setzt die Menge aller Geometrie-Objekteigenschaften, die durch alle Objekte dieser 
	// Objektmenge unterstützt werden.
	// @supby <o TRiASObjects> 
	// @xref <i ITRiASObjects>, <i ITRiASFeatures>
		[propget, id(13), helpstring("Liefert die Menge aller Geometrie-Objekteigenschaften, die durch alle Objekte dieser Objektmenge unterstützt werden.")] HRESULT GeometryFeatures([out, retval] ITRiASFeatures **pVal);
		[propput, id(13), helpstring("Setzt die Menge aller Geometrie-Objekteigenschaften, die durch alle Objekte dieser Objektmenge unterstützt werden.")] HRESULT GeometryFeatures([in] ITRiASFeatures *newVal);

	// @property <i ITRiASFeature> * | ITRiASObjects | GeometryFeature | Die <op .GeometryFeature>- Eigenschaft 
	// Liefert bzw. erzeugt eine Geometrie-Objekteigenschaft, die durch alle Objekte dieser 
	// Objektmenge unterstützt werden.
	// @parm VARIANT | Item | Die zu liefernde/erzeugende Geometrie-Objekteigenschaft.
	// @parm VARIANT_BOOL | fCreate | Die Objekteigenschaft soll neu erzeugt werden, wenn sie
	// noch nicht existiert.
	// @parm BSTR | Type | Wenn der Parameter <p fCreate> den Wert <cv True> besitzt und die gegebene 
	// Objekteigenschaft nicht existiert, dann wird eine neue Objekteigenschaft mit dem hier vorgegeben Typ
	// neu erzeugt (ProgID). Ist der hier gegebene Typ ungültig oder nicht gegeben, dann wird eine 
	// Objekteigenschaft vom Typ <o TRiASFeature> erzeugt.
	// @comm Die Eigenschaft <op .GeometryFeature> kann nicht gesetzt werden.
	// @rvalue <cv S_OK> | Die Operation war erfolgreich (die Objekteigenschaft existierte bereits).
	// @rvalue <cv S_FALSE> | Die Operation war erfolgreich aber die Objekteigenschaft mußte neu 
	// erzeugt werden. Dieser Rückgabewert kann nur dann geliefert werden, wenn der 
	// Parameter <p fCreate> den Wert <cv True> hatte.
	// @devnote Wenn der Parameter <p Item> den Wert 'DefaultGeometry' enthält, dann wird das 
	// Primärgeometriefeld dieser Objektklasse geliefert.
	// @supby <o TRiASObjects> 
	// @xref <i ITRiASObjects>, <i ITRiASFeature>
	// @end
		[propget, id(14), helpstring("Liefert bzw. erzeugt eine Geometrie-Objekteigenschaft, die durch alle Objekte dieser Objektmenge unterstützt werden.")] HRESULT GeometryFeature([in] VARIANT Item, [in /*, optional*/, defaultvalue(VARIANT_FALSE)] VARIANT_BOOL Create, [in /*, optional*/, defaultvalue("")] BSTR Type, [out, retval] ITRiASFeature **pVal);

	// @property BSTR | ITRiASObjects | DefaultGeometry | Die <op .DefaultGeometry>- Eigenschaft 
	// liefert bzw. setzt den Namen der Primärgeometrie-Eigenschaft.
	// @supby <o TRiASObjects> 
	// @xref <i ITRiASObjects>, <i ITRiASFeatures>
		[propget, id(15), helpstring("Liefert den Namen des Primärgeometrie-Feldes.")] HRESULT DefaultGeometry([out, retval] BSTR *pVal);
		[propput, id(15), helpstring("Setzt den Namen des Primärgeometrie-Feldes.")] HRESULT DefaultGeometry([in] BSTR newVal);

	// @property BSTR | ITRiASObjects | PrimaryKey | Die <op .PrimaryKey>- Eigenschaft 
	// liefert bzw. setzt den Namen der Primärattribut-Eigenschaft.
	// @supby <o TRiASObjects> 
	// @xref <i ITRiASObjects>, <i ITRiASFeatures>
		[propget, id(16), helpstring("Liefert den Namen des Primärattribut-Feldes.")] HRESULT PrimaryKey([out, retval] BSTR *pVal);
		[propput, id(16), helpstring("Setzt den Namen des Primärattribut-Feldes.")] HRESULT PrimaryKey([in] BSTR newVal);

	// @property BSTR | ITRiASObjects | CollectionType | Die <op .CollectionType>- Eigenschaft 
	// liefert bzw. setzt den Typ des Objektklassenobjektes.
	// @supby <o TRiASObjects> 
	// @xref <i ITRiASObjects>, <i ITRiASFeatures>, <t OBJECTSCOLLECTIONTYPE>
		[propget, id(17), helpstring("Liefert den Typ dieser Sammlung von Objekten.")] HRESULT CollectionType([out, retval] OBJECTSCOLLECTIONTYPE *pVal);
		[propput, id(17), helpstring("Setzt den Typ dieser Sammlung von Objekten.")] HRESULT CollectionType([in] OBJECTSCOLLECTIONTYPE newVal);

	// @property VARIANT_BOOL | ITRiASObjects | Updatable | Die <op .Updatable>- Eigenschaft liefert bzw. 
	// setzt, ob diese Sammlung von Objekten beschreibbar ist.
	// @supby <o TRiASObjects> 
	// @xref <i ITRiASObjects>
		[propget, id(18), helpstring("Liefert ob diese Sammlung von Objekten beschreibbar ist.")] HRESULT Updatable([out, retval] VARIANT_BOOL *pVal);
		[propput, id(18), helpstring("Setzt ob diese Sammlung von Objekten beschreibbar ist.")] HRESULT Updatable([in] VARIANT_BOOL newVal);

	// @method HRESULT | ITRiASObjects | Item | Die Methode <om .Item> liefert ein Element dieser Sammlung.
	// @supby <o TRiASObjects>
	// @xref <i ITRiASObjects>
		[id(DISPID_DEFAULT), helpstring("Get the object by name or by index number.")] HRESULT Item([in] VARIANT Index, [out, retval] ITRiASObject **Obj);

	// @method HRESULT | ITRiASObjects | _NewEnum | Liefert einen neuen
	// Enumerator, der alle Objekte enthält, die in der vorliegenden Sammlung zusammengefaßt sind.
	// @parm IUnknown ** | Enum | Zeiger auf eine Variable vom Typ IUnknown *, welche nach erfolgreicher 
	// Abarbeitung der Methode <om ._NewEnum> den Ergebnis-Enumerator enthält.
	// @comm Der gelieferte Enumerator ist vom Typ <i IEnumVARIANT>. Daher sollte der Rückgabewert
	// explizit durch einen QueryInterface-Aufruf konvertiert werden.
	// @ex Das folgende Beispiel verdeutlicht die empfohlene Vorgehensweise |
	// IEnumVARIANT *pIEnum = NULL;
	// IUnknown *pIUnk = NULL;
	// HRESULT hr = pIEntries -> _NewEnum (&pIUnk);
	//
	//	if (SUCCEEDED(hr)) {
	//		hr = pIUnk -> QueryInterface(IID_IEnumVARIANT, (LPVOID *)&pIEnum);
	//		pIUnk -> Release();
	//	}
	//	...
	// @comm Normalerweise wird diese Funktion nicht direkt gerufen, Sie ist lediglich
	// für die Nutzung in Automation-Werkzeugen wie z.B. VisualBasic vorgesehen, wo sie
	// für Programmkonstrukte wie 'For Each ...' notwendig ist.
	// @supby <o TRiASObjects>
	// @xref <i ITRiASObjects>
		[id(DISPID_NEWENUM), hidden] HRESULT _NewEnum([out, retval] IUnknown **ppIEnum);

	// @method HRESULT | ITRiASObjects | Add | Die <om .Add>- Methode erzeugt
	// ein neues Objekt und fügt dieses zur vorliegenden Sammlung von Objekten hinzu.
	// @parm BSTR | Name | Der <p Name>- Parameter enthält den Objektnamen des neu zu erzeugenden 
	// Objektes.
	// @parm BSTR | Type | Der <p Type>-Parameter enthält den Typ (ProgID) des neu zu erzeugenden 
	// Objektes. Ist der hier gegebene Typ ungültig oder nicht gegeben, dann wird ein Objekt vom 
	// Typ <o TRiASSimpleObject> erzeugt.
	// @parm <t OBJECTTYPE> | ObjType | Der <p Objtype> -Parameter gibt den Objekttype des hinzuzufügenden
	// Objektes an. Diese Information wird lediglich beim Neuerzeugen eines Objektes benötigt.
	// @supby <o TRiASObjects>
	// @xref <i ITRiASObjects>
	// @end
		[id(100), helpstring("Create and add a new object.")] HRESULT Add([in] BSTR Name, [in /*, optional*/, defaultvalue("")] BSTR Type, [in /*, optional*/, defaultvalue(OBJECTTYPE_Unknown)] OBJECTTYPE rgType, [out, retval] ITRiASObject **Object);

	// @method HRESULT | ITRiASObjects | _Remove | Die <om ._Remove>- Methode entfernt
	// ein Objekt aus der gegebenen Sammlung von Objekten.
	// @parm VARIANT | Index | Der Parameter <p Index> kann entweder die Zählummer des
	// (0 <lt> Index <lt>= Count), den Objektnamen des zu entfernenden 
	// Objektes oder ein Objekt vom Typ <o TRiASObject> enthalten.
	// @supby <o TRiASObjects>
	// @xref <i ITRiASObjects>
		[id(101), helpstring("Entfernen des Objektes aus dieser Objektmenge.")] HRESULT _Remove([in] VARIANT Index);

	// @method HRESULT | ITRiASObjects | Classify | Die <om .Classify>- Methode klassifiert das
	// übergebene Objekt in die vorliegende Objektklasse um.
	// @parm <i ITRiASObject> * | Obj | Das umzuklassifizierende Objekt.
	// @parm <t CLASSIFYMODE> | Mode | Der Mode, mit dem das Objekt umklassifiziert werden soll.
	// @comm Es wird zuerst das durch die Methode <op .ObjectsCallback> gesetzte Targetobjekt aufgefordert, 
	// mit <om ITRiASObjectsCallback.OnAdd> das gegebene Objekt umzuklassifizieren. Schlägt dieses fehl, 
	// dann wird in der neuen Objektklasse mit <om. Add> ein neues Objekt erzeugt, sämtliche seiner 
	// Objekteigenschaften umkopiert und anschließend das alte Objekt mit <om .Delete> aus seiner 
	// Datenquelle gelöscht.
	// @supby <o TRiASObjects>
	// @xref <i ITRiASObjects>, <i ITRiASObject>, <t CLASSIFYMODE>
		[id(102), helpstring("Umklassifizieren des übergebenen Objektes zu dieser Objektmenge.")] HRESULT Classify([in] ITRiASObject *Obj, [in] CLASSIFYMODE Mode);

	// @method HRESULT | ITRiASObjects | Delete | Die <om .Delete>- Methode entfernt
	// ein Objekt aus der gegebenen Sammlung von Objekten und löscht es aus der entsprechenden Datenquelle.
	// @parm VARIANT | Index | Der Parameter <p Index> kann entweder die Zählummer des
	// (0 <lt> Index <lt>= Count), den Objektnamen des zu entfernenden 
	// Objektes oder ein Objekt vom Typ <o TRiASObject> enthalten.
	// @comm Diese Routine versucht zuerst die Methode <om ITRiASObject.Delete> direkt zu rufen, um das
	// Objekt selbst aufzufordern, sich aus der Datenquelle zu löschen. Wenn dieser Aufruf fehlschlägt, 
	// dann wird über das mit der Methode <op .ObjectsCallback> initialisierte Targetobjekt durch die
	// Methode <om ITRiASObjectsCallback.OnDelete> aufgefordert, das Objekt zu entfernen.
	// @supby <o TRiASObjects>
	// @xref <i ITRiASObjects>, <o TRiASObject>, <om ITRiASObjectsCallback.OnDelete>,
	// <om ITRiASObject.Delete>, <op .ObjectsCallback>
		[id(103), helpstring("Entfernen des übergebenen Objektes aus der zugehörigen Datenquelle.")] HRESULT Delete([in] VARIANT Index);

	// @method HRESULT | ITRiASObjects | _Add | Die <om ._Add>- Methode fügt ein bereits existierendes
	// Objekt zu dieser Objektmenge hinzu.
	// @parm <i ITRiASObject> * | Obj | Der Parameter <p Obj> enthält das hinzuzufügende Objekt.
	// @supby <o TRiASObjects>
	// @xref <i ITRiASObjects>, <i ITRiASObject>
	// @end
		[id(104), helpstring("Add an existing object."), hidden] HRESULT _Add([in] ITRiASObject *Obj, [in /*, optional*/, defaultvalue(VARIANT_FALSE)] VARIANT_BOOL FullAdd);

	// zusätzliches
		[id(105), helpstring("Reset collection object"), hidden] HRESULT _Reset();

	// @method HRESULT | ITRiASObjects | _Clone | Die <om ._Clone>- Methode liefert eine neue 
	// Sammlung von Objekten, die identisch zur vorliegenden ist.
	// @parm <i ITRiASObjects> ** | Enum | Zeiger auf eine Variable vom Typ <i ITRiASObjects> *, welche 
	// nach erfolgreicher Abarbeitung der Methode <om ._Clone> die Kopie dieser Objektsammlung enthält.
	// @comm Bei Änderungen an der ursprünglichen Objektsammlung wird die neu erzeugte Kopie
	// nicht modifiziert.
	// @supby <o TRiASObjects>
	// @xref <i ITRiASObjects>
		[id(106), helpstring("Erzeugt eine neue Sammlung von Objekten, die der vorliegenden identisch ist."), hidden] HRESULT _Clone([out, retval] ITRiASObjects **Objs);

	// @method HRESULT | ITRiASObjects | Refresh | Liest alle existierenden Elemente dieser
	// Sammlung neu ein
	// @comm Vorsicht! Diese Methode sollte nur dann gerufen werden, wenn es notwendig ist, da
	// sie zeitaufwendig sein kann.
	// @supby <o TRiASObjects>
	// @xref <i ITRiASObjects>
		[id(107), helpstring("Liest alle Elemente dieser Sammlung neu ein (Vorsicht! Zeitaufwendig!).")] HRESULT Refresh();

	// @method HRESULT | ITRiASObjects | SetEventSink | Die <om .SetEventSink>- Methode erlaubt
	// dieses Objekt bei einem anderen Objekt, welches den Connectionpoint für das Interface 
	// <i ITRiASConnectionEvents> implementiert hat, anzumelden bzw. abzumelden.
	// @parm IUnknown * | Unk | Dieser Parameter muß einen Zeiger auf ein IUnknown-Interface des Objektes
	// sein, bei dem sich unser Objekt an- bzw. abmelden soll. 
	// @parm VARIANT_BOOL | fAdvise | Das Objekt wird angemeldet, wenn dieser Parameter den Wert
	// <cv VARIANT_TRUE> enthält, anderenfalls wird das Objekt abgemeldet.
	// @supby <o TRiASObjects> 
	// @xref <i ITRiASObjects>
		[id(108), helpstring("Zuordnen des Targetobjektes zur Eventbehandlung."), hidden, restricted] HRESULT SetEventSink ([in] IUnknown *Unk, [in] VARIANT_BOOL fAdvise);
	};

///////////////////////////////////////////////////////////////////////////////
// @doc INTERFACE TRIASDB
// @interface ITRiASObjectsEx | Das Interface <i ITRiASObjectsEx> dient der Verwaltung
// einer Objektmenge.
// @supby <o TRiASSimpleObjects>
// @group Methoden und Eigenschaften von <i ITRiASObjectsEx> 
// @index | IOBJECTSEX
// @doc IOBJECTSEX
	[
		object,
		uuid(22CE36EB-2399-41D1-848E-20592F3A5A74),
		oleautomation,
		helpstring("ITRiASObjectsEx Interface"),
		pointer_default(unique)
	]
	interface ITRiASObjectsEx : IDispatch
	{
	// @property INT_PTR | ITRiASObjectsEx | LocalHandle | Die <op .LocalHandle>- Eigenschaft 
	// liefert den Identifikator dieses Objektklassenobjektes innerhalb seiner Datenbank.
	// @comm Die Eigenschaft <op .LocalHandle> kann nicht gesetzt werden.
	// @supby <o TRiASSimpleObjects> 
	// @xref <i ITRiASSimpleObjects>
		[propget, id(1), helpstring("Liefert den Identifikator dieses Objektklassenobjektes innerhalb seiner Datenbank.")] HRESULT LocalHandle ([out, retval] INT_PTR *pVal);

	// @property LONG | ITRiASObjectsEx | Count | Liefert die Anzahl der in dieser Objektsammlung 
	// enthaltenen Objekte (readonly).
	// @parm <t OBJECTTYPE> | Type | Der/die Objekttyp(en) für die der Objektzähler geliefert werden soll.
	// @comm Im Unterschied zu der <op ITRiASObjects.Count>- Eigenschaft gestattet diese
	// Eigenschaft die Abfrage der Objektanzahl je nach Objekttyp.
	// @comm Die Eigenschaft <op .Count> kann nicht gesetzt werden.
	// @supby <o TRiASSimpleObjects> 
	// @xref <i ISimpleTRiASObjects>, <op ITRiASObjects.Count>, <t OBJECTTYPE>
	// @end
		[propget, id(2), helpstring("Liefert die Anzahl der Objekte in dieser Objektmenge.")] HRESULT Count([in, /*optional, */defaultvalue(OBJECTTYPE_All)] OBJECTTYPE rgType, [out, retval] long *pVal);

	// @property HOBJECT * | ITRiASObjectsEx | Handles | Liefert die Handles der zu dieser Objektmenge 
	// gehörenden Einzelobjekte (readonly).
	// @parm long | Count | Die Anzahl der maximal zu liefernden Objekthandles.
	// @comm Die Eigenschaft <op .Handles> kann nicht gesetzt werden.
	// @supby <o TRiASSimpleObjects> 
	// @xref <i ISimpleTRiASObjects>
		[propget, id(3), helpstring("Liefert die Handles der zu dieser Objektmenge gehörenden Einzelobjekte.")] HRESULT Handles ([in] long Count, [in, out, size_is(Count)] INT_PTR *pHandles);
	};

///////////////////////////////////////////////////////////////////////////////
// @doc INTERFACE TRIASDB
// @interface ITRiASObjectsCallback | Das Interface <i ITRiASObjectsCallback> dient der Verwaltung
// einer Objektmenge.
// @supby <o TRiASSimpleObjects>
// @group Methoden und Eigenschaften von <i ITRiASObjectsCallback> 
// @index | IOBJECTSCALLBACK
// @doc IOBJECTSCALLBACK
	[
		object,
		uuid(3F9633F3-C718-11D1-85D6-00600875138A),
		oleautomation,
		helpstring("ITRiASObjectsCallback Interface"),
		pointer_default(unique)
	]
	interface ITRiASObjectsCallback : IUnknown
	{
	cpp_quote("#if !defined(_SETUPOBJECTSMODE_DEFINED)")
	cpp_quote("#define _SETUPOBJECTSMODE_DEFINED")
	// @doc SETUPOBJECTSMODEENUMS 
	// @enum SETUPOBJECTSMODE | Der Mode, in dem diese Objektmenge geladen werden soll.
	// @xref <i ITRiASObjectsCallback>, <om ITRiASObjectsCallback.SetupObjects>
		typedef [public, v1_enum, helpstring("Modi zum Laden der Objekte einer Objektmenge")]
		enum _tagSETUPOBJECTSMODE {
			[helpstring("Objektinstanz initialisieren.")]
				SETUPOBJECTSMODE_InitOrLoad = 0,		// @emem Objektinstanz initialisieren
			[helpstring("Objektanzahl sicherstellen.")]
				SETUPOBJECTSMODE_Count = 1,				// @emem Objektanzahl sicherstellen
			[helpstring("Alle Objekte sicher und vollständig laden.")]
				SETUPOBJECTSMODE_Load = 2,				// @emem Alle Objekte sicher und vollständig laden
			[helpstring("Objektinstant wieder in Ausgangszustand zurücksetzen.")]
				SETUPOBJECTSMODE_ResetObjectInfo = 4,	// @emem Objektinstant wieder in Ausgangszustand zurücksetzen
			[helpstring("Angeforderte Aktion erneut erzwingen.")]
				SETUPOBJECTSMODE_Force = 0x8000,		// @emem Angeforderte Aktion erneut erzwingen
		} SETUPOBJECTSMODE;
	cpp_quote("#endif // _SETUPOBJECTSMODE_DEFINED")

	// @doc IOBJECTSCALLBACK
	// @property BSTR * | ITRiASObjectsCallback | DefaultType | Die <op .DefaultType>- Eigenschaft
	// liefert den Type (ProgID) des im Standardfall zu instantiierenden Objektes.
	// @supby <o TRiASSimpleObjects> 
	// @xref <i ITRiASObjectsCallback>
		[propget, helpstring("Typ des standardmäßig zu erzeugenden Objektes.")] HRESULT DefaultType([out, retval] BSTR *Type);

	// @method HRESULT | ITRiASObjectsCallback | SetupObjects | Die <om .SetupObjects>- Methode
	// fordert das Bezugsobjekt auf, die zu dieser Objektmenge gehörenden Metadaten zu initialisieren.
	// @parm <t SETUPOBJECTSMODE> | Mode | der Parameter <p Mode> gibt vor, welche Informationen sichergestellt 
	// werden sollen.
	// @comm Zu den zu initialisierenden Metadaten gehören die zu den Objekten dieser Objektmenge 
	// gehörenden Attribute (<o TRiASFeature>- Objekte), 
	// @supby <o TRiASSimpleObjects> 
	// @xref <i ITRiASObjectsCallback>, <t SETUPOBJECTSMODE>
		[helpstring("Initialiseren der Metadaten dieser Objektmenge.")] HRESULT SetupObjects([in] SETUPOBJECTSMODE Mode);

	// @method HRESULT | ITRiASObjectsCallback | SetupFeatures | Die <om .SetupFeatures>- Methode
	// fordert das Bezugsobjekt auf, die zu dieser Objektmenge gehörenden Objekteigenschaften zu 
	// initialisieren.
	// @parm <t SETUPFEATURESMODE> | SetupMode | Erzwingt gegebenenfalls das Neuinitialisieren evtl. eingelesener
	// Objekteigenschaften.
	// @supby <o TRiASSimpleObjects> 
	// @xref <i ITRiASObjectsCallback>, <t SETUPFEATURESMODE>
	// @end
		[helpstring("Initialisierung aller Objekteigenschaften dieser Objektmenge")] HRESULT SetupFeatures([in /*, optional*/, defaultvalue(SETUPFEATURESMODE_Normal)] SETUPFEATURESMODE SetupMode);

	// @method HRESULT | ITRiASObjectsCallback | OnCreate | Die <om .OnCreate>- Methode wird
	// immer dann gerufen, wenn ein neues Objekt erzeugt werden soll.
	// @supby <o TRiASSimpleObjects> 
	// @xref <i ITRiASObjectsCallback>
	// @end
		[helpstring("Ein Objekt soll erzeugt werden.")] HRESULT OnCreate([in] BSTR Name, [in /*, optional*/, defaultvalue("")] BSTR Type, [in /*, optional*/, defaultvalue(OBJECTTYPE_Unknown)] OBJECTTYPE rgType, [out, retval] ITRiASObject **Obj);

	// @method HRESULT | ITRiASObjectsCallback | OnChanging | Die <om .OnChanging>- Methode wird
	// immer dann gerufen, wenn das Bezugsobjekt in irgend einer Form modifiziert werden soll.
	// @parm <t CHANGEDOBJECTS> | rgWhat | Der Parameter <p rgWhat> gibt an, was im Bezugsobjekt 
	// modifiziert werden soll.
	// @parm VARIANT | NewValue | Der Parameter <p NewValue> enthält den neuen Wert der eingestellt 
	// werden soll.
	// @parm VARIANT_BOOL * | DisAllow | Durch Setzen des Wertes des Parameters <p DisAllow> auf
	// <cv VARIANT_TRUE> kann die durchzuführende Aktion abgebrochen werden. Durch Setzen auf den Wert
	// <cv VARIANT_FALSE> wird das Einverständnis erteilt, die Aktion durchzuführen.
	// @supby <o TRiASSimpleObjects> 
	// @xref <i ITRiASObjectsCallback>, <t CHANGEDOBJECTS>
		[helpstring("Irgend etwas wird modifiziert werden.")] HRESULT OnChanging([in] CHANGEDOBJECTS rgWhat, [in] VARIANT NewValue, [out, retval] VARIANT_BOOL *DisAllow);

	// @method HRESULT | ITRiASObjectsCallback | OnChanged | Die <om .OnChanged>- Methode wird
	// immer dann gerufen, wenn das Bezugsobjekt in irgend einer Form modifiziert wurde.
	// @parm <t CHANGEDOBJECTS> | rgWhat | Der Parameter <p rgWhat> gibt an, was im Bezugsobjekt 
	// modifiziert wurde.
	// @parm VARIANT | OldValue | Der Parameter <p OldValue> enthält den alten Wert der vor der
	// Modifikation eingestellt gewesen war.
	// @supby <o TRiASSimpleObjects> 
	// @xref <i ITRiASObjectsCallback>, <t CHANGEDOBJECTS>
		[helpstring("Irgend etwas wurde modifiziert.")] HRESULT OnChanged([in] CHANGEDOBJECTS rgWhat, [in] VARIANT OldValue);

	// @method HRESULT | ITRiASObjectsCallback | OnDelete | Die <om .OnDelete>- Methode wird
	// immer dann gerufen, Ein Objekt gelöscht werden soll.
	// @rvalue <cv S_OK> | Das Objekt wurde erfolgreich aus der Datenbank gelöscht und alle Referenzen 
	// wurden freigegeben.
	// @rvalue <cv S_FALSE> | Das Objekt wurde nicht aus der Datenbank gelöscht, da diese Operation z.B.
	// durch die zugehörige Objektklasse auszuführen ist. es wurden jedoch alle Refrenzen freigegeben.
	// @supby <o TRiASSimpleObjects> 
	// @xref <i ITRiASObjectsCallback>
		[helpstring("Ein Objekt soll gelöscht werden.")] HRESULT OnDelete([in] INT_PTR hObj);

	// @method HRESULT | ITRiASObjectsCallback | OnAdd | Die <om .OnAdd>- Methode wird
	// immer dann gerufen, wenn ein existierendes Objekt zu dieser Objektmenge hinzugefügt werden soll.
	// @parm <i ITRiASObject> * | Obj | Das umzuklassifizierende Objekt.
	// @parm <t CLASSIFYMODE> | Mode | Der Mode, mit dem das Objekt umklassifiziert werden soll.
	// @supby <o TRiASSimpleObjects> 
	// @xref <i ITRiASObjectsCallback>, <t CLASSIFYMODE>
		[helpstring("Ein Objekt soll zu dieser Objektmenge hinzugefügt werden.")] HRESULT OnAdd([in] ITRiASObject *Obj, [in] CLASSIFYMODE Mode);

	// @method HRESULT | ITRiASObjectsCallback | OnRemove | Die <om .OnRemove>- Methode wird
	// immer dann gerufen, wenn ein existierendes Objekt aus dieser Objektmenge entfernt werden soll.
	// @supby <o TRiASSimpleObjects> 
	// @xref <i ITRiASObjectsCallback>
		[helpstring("Ein Objekt soll zu dieser Objektmenge hinzugefügt werden.")] HRESULT OnRemove([in] ITRiASObject *Obj);

	// @method HRESULT | ITRiASObjectsCallback | MapFeatureCode | Die <om .MapFeatureCode>- Methode wird
	// immer dann gerufen, wenn ein bestimmtes Feature dieser Objektklasse gesucht wird.
	// @comm Die <om .MapFeatureCode> Methode ist notwendig, da für der Unique Ident von <tr> 
	// Datenquellenbezogen vergeben wird, in verschiedenen Datenquellen (z.B. GDO-gestützte Datenquellen) 
	// jedoch möglicherweise ein tabellenbezogener Unique Ident verwaltet wird.
	// @supby <o TRiASSimpleObjects> 
	// @xref <i ITRiASObjectsCallback>
		[helpstring("Zuordnen eines anderen Handles für eine Objekteigenschaft.")] HRESULT MapFeatureHandle ([in] VARIANT NameOrHandle, [out, retval] VARIANT *NewNameOrHandle);

	// @method HRESULT | ITRiASObjectsCallback | OnFinalRelease | Die <om .OnFinalRelease>- Methode wird
	// immer dann gerufen, wenn das Objekt logisch freigegeben wird.
	// @supby <o TRiASSimpleObjects> 
	// @xref <i ITRiASObjectsCallback>
		[helpstring("Objekt wird logisch freigegeben.")] HRESULT OnFinalRelease();
	};

///////////////////////////////////////////////////////////////////////////////
// @doc INTERFACE TRIASDB
// @interface ITRiASObjectsCollection | Das Interface <i ITRiASObjectsCollection> 
// dient der Verwaltung einer Sammlung von <o TRiASObjects>- Objektmengen.
// @supby <o TRiASObjectsCollection>
// @group Methoden und Eigenschaften von <i ITRiASObjectsCollection> 
// @index | IOBJECTSCOLLECTION
// @doc IOBJECTSCOLLECTION
	[
		object,
		uuid(48172D64-AB72-11D1-858D-00600875138A),
		dual,
		helpstring("ITRiASObjectsCollection Interface"),
		pointer_default(unique)
	]
	interface ITRiASObjectsCollection : ITRiASBase
	{
	// @property LONG | IITRiASObjectsCollection | Count | Liefert die Anzahl der in dieser Objektsammlungen 
	// enthaltenen Objekte (readonly).
	// @comm Die Eigenschaft <op .Count> kann nicht gesetzt werden.
	// @supby <o TRiASObjectsCollection> 
	// @xref <i ITRiASObjectsCollection>
		[propget, id(3), helpstring("Liefert die Anzahl der Objekte in dieser Objektmenge.")] HRESULT Count([out, retval] long *pVal);

	// @property <i ITRiASObjectsCollectionCallback> * | IITRiASObjectsCollection | 
	// ObjectsCollectionCallback | Die <op .ObjectsCollectionCallback>- Eigenschaft 
	// initialisiert das Rückrufinterface, über welches die Objektspezifik definiert wird.
	// @comm Das übergebene Objekt wird nicht festgehalten (<b kein> AddRef!).
	// @supby <o TRiASObjectsCollection> 
	// @xref <i ITRiASObjectsCollection>, <i ITRiASObjectsCollectionCallback>
		[propputref, id(4), helpstring("Zuordnen des Objektes, welches die Spezifik dieser Objektklassenmenge definiert.")] HRESULT ObjectsCollectionCallback([in] ITRiASObjectsCollectionCallback *pICB);

	// @method HRESULT | ITRiASObjectsCollection | Item | 
	// @supby <o TRiASObjectsCollection> 
	// @xref <i ITRiASObjectsCollection>
		[id(DISPID_DEFAULT), helpstring("Get the objects-collection by name or by index number.")] HRESULT Item([in] VARIANT Index, [out, retval] ITRiASObjects **Obj);

	// @method HRESULT | IITRiASObjectsCollection | _NewEnum | Liefert einen neuen
	// Enumerator, der alle Objekte enthält, die in der vorliegenden Sammlung zusammengefaßt sind.
	// @parm IUnknown ** | Enum | Zeiger auf eine Variable vom Typ IUnknown *, welche nach erfolgreicher 
	// Abarbeitung der Methode <om ._NewEnum> den Ergebnis-Enumerator enthält.
	// @comm Der gelieferte Enumerator ist vom Typ <i IEnumVARIANT>. Daher sollte der Rückgabewert
	// explizit durch einen QueryInterface-Aufruf konvertiert werden.
	// @ex Das folgende Beispiel verdeutlicht die empfohlene Vorgehensweise |
	// IEnumVARIANT *pIEnum = NULL;
	// IUnknown *pIUnk = NULL;
	// HRESULT hr = pIEntries -> _NewEnum (&pIUnk);
	//
	//	if (SUCCEEDED(hr)) {
	//		hr = pIUnk -> QueryInterface(IID_IEnumVARIANT, (LPVOID *)&pIEnum);
	//		pIUnk -> Release();
	//	}
	//	...
	// @comm Normalerweise wird diese Funktion nicht direkt gerufen, Sie ist lediglich
	// für die Nutzung in Automation-Werkzeugen wie z.B. VisualBasic vorgesehen, wo sie
	// für Programmkonstrukte wie 'For Each ...' notwendig ist.
	// @supby <o TRiASObjectsCollection> 
	// @xref <i ITRiASObjectsCollection>
		[id(DISPID_NEWENUM), hidden] HRESULT _NewEnum([out, retval] IUnknown **ppIEnum);

		[id(100), helpstring("Create and add a new object.")] HRESULT Add([in] BSTR Name, [in /*, optional*/, defaultvalue("")] BSTR Type, [out, retval] ITRiASObjects **Object);
		[id(101), helpstring("Remove a object")] HRESULT Remove([in] VARIANT Index);

	// zusätzliches
		[id(102), helpstring("Add an existing object."), hidden] HRESULT _Add([in] ITRiASObjects *Obj, [in /*, optional*/, defaultvalue(VARIANT_TRUE)] VARIANT_BOOL FullAdd);

	// @method HRESULT | ITRiASObjectsCollection | _Clone | Die <om ._Clone>- Methode liefert eine neue 
	// Sammlung von Objekten, die identisch zur vorliegenden ist.
	// @parm <i ITRiASObjectsCollection> ** | Enum | Zeiger auf eine Variable vom Typ 
	// <i ITRiASObjectsCollection> *, welche nach erfolgreicher Abarbeitung der Methode 
	// <om ._Clone> die Kopie dieser Objektsammlung enthält.
	// @comm Bei nachfolgendne Änderungen an der ursprünglichen Objektsammlung wird die neu erzeugte Kopie
	// nicht automatisch modifiziert.
	// @supby <o TRiASObjectsCollection> 
	// @xref <i ITRiASObjectsCollection>
		[id(103), helpstring("Erzeugt eine neue Sammlung von Objekten, die der vorliegenden identisch ist."), hidden] HRESULT _Clone([out, retval] ITRiASObjectsCollection **ObjsColl);

	// @method HRESULT | ITRiASObjectsCollection | Refresh | Liest alle existierenden Elemente dieser
	// Sammlung neu ein.
	// @comm Vorsicht! Diese Methode sollte nur dann gerufen werden, wenn es notwendig ist, da
	// sie zeitaufwendig sein kann.
	// @supby <o TRiASObjectsCollection> 
	// @xref <i ITRiASObjectsCollection>
		[id(104), helpstring("Liest alle Elemente dieser Sammlung neu ein (Vorsicht! Zeitaufwendig!).")] HRESULT Refresh();
	};

///////////////////////////////////////////////////////////////////////////////
// @doc INTERFACE TRIASDB
// @interface ITRiASObjectsCollectionCallback | Das Interface <i ITRiASObjectsCollectionCallback> dient der Verwaltung
// einer Sammlung von Objektklassen.
// @supby <o TRiASObjectsCollectionCallback>
// @group Methoden und Eigenschaften von <i ITRiASObjectsCollectionCallback> 
// @index | IOBJECTSCOLLECTIONCALLBACK
// @doc IOBJECTSCOLLECTIONCALLBACK
	[
		object,
		oleautomation,
		uuid(5F20C608-B87C-11D2-95A8-006008447800),
		helpstring("ITRiASObjectsCollectionCallback Interface"),
		pointer_default(unique)
	]
	interface ITRiASObjectsCollectionCallback : IUnknown
	{
	// @property BSTR * | ITRiASObjectsCollectionCallback | DefaultType | Die <op .DefaultType>- Eigenschaft
	// liefert den Type (ProgID) des im Standardfall zu instantiierenden Objektes.
	// @supby <o TRiASObjectsCollectionCallback> 
	// @xref <i ITRiASObjectsCollectionCallback>
		[propget, helpstring("Typ des standardmäßig zu erzeugenden Objektes.")] HRESULT DefaultType([out, retval] BSTR *Type);

	// @method HRESULT | ITRiASObjectsCollectionCallback | OnCreate | Die <om .OnCreate>- Methode wird
	// immer dann gerufen, wenn eine neue Objekteigenschaft erzeugt werden soll.
	// @supby <o TRiASObjectsCollectionCallback> 
	// @xref <i ITRiASObjectsCollectionCallback>
	// @end
		[helpstring("Eine Objektklasse soll erzeugt werden.")] HRESULT OnCreate([in] VARIANT NameOrHandle, [in /*, optional, defaultvalue("")*/ ] BSTR Type, [in] OBJECTSCOLLECTIONTYPE rgType, [out, retval] ITRiASObjects **Objs);

	// @method HRESULT | ITRiASObjectsCollectionCallback | OnDelete | Die <om .OnDelete>- Methode wird
	// immer dann gerufen, eine Objekteigenschaft gelöscht werden soll.
	// @supby <o TRiASObjectsCollectionCallback> 
	// @xref <i ITRiASObjectsCollectionCallback>
		[helpstring("Eine Objektklasse soll gelöscht werden.")] HRESULT OnDelete([in] VARIANT vWhich);

	// @method HRESULT | ITRiASObjectsCallback | OnFinalRelease | Die <om .OnFinalRelease>- Methode wird
	// immer dann gerufen, wenn das Objekt logisch freigegeben wird.
	// @supby <o TRiASSimpleObjects> 
	// @xref <i ITRiASObjectsCallback>
		[helpstring("Objekt wird logisch freigegeben.")] HRESULT OnFinalRelease();
	};

///////////////////////////////////////////////////////////////////////////////
// Eigenschafts-Collection
// @doc INTERFACE TRIASDB
// @interface ITRiASFeatures | Das Interface <i ITRiASFeatures> 
// dient der Verwaltung einer Sammlung von <o TRiASFeature>- Objekten.
// @supby <o TRiASFeatures>
// @group Methoden und Eigenschaften von <i ITRiASFeatures> 
// @index | IFEATURES
// @doc IFEATURES
	[
		object,
		uuid(1CB3AB71-2E87-11D1-969D-00A024D6F582),
		dual,
		helpstring("ITRiASFeatures Interface"),
		pointer_default(unique)
	]
	interface ITRiASFeatures : ITRiASBase
	{
	cpp_quote("#if !defined(_FEATURETYPE_DEFINED)")
	cpp_quote("#define _FEATURETYPE_DEFINED")
	// @doc FEATURETYPEENUMS 
	// @enum FEATURETYPE | Der Typ einer Objekt-, Ansichts- bzw. Objektklasseneigenschaft.
	// @xref <i ITRiASFeature>, <om ITRiASSimpleFeature.InitTarget>, <op ITRiASFeature.Type>
		typedef [public, v1_enum, helpstring("Typ einer Objekteigenschaft.")]
		enum _tagFEATURETYPE {
			[helpstring("Eigenschaft eines Objektes")]
				FEATURETYPE_Object = 'a',			// @emem Eigenschaft eines Objektes
			[helpstring("Eigenschaft einer Ansicht")]
				FEATURETYPE_View = 'b',				// @emem Eigenschaft einer Ansicht
			[helpstring("Eigenschaft einer Objektklasse")]
				FEATURETYPE_Ident = 'c',			// @emem Eigenschaft einer Objektklasse
			[helpstring("Unbekannter Eigenschaftstyp")]
				FEATURETYPE_Unknown = 'u',			// @emem Unbekannter Eigenschaftstyp
			[helpstring("Bitmaske für Eigenschaftstyp")]
				FEATURETYPE_TypeMask = 0xff,		// @emem Bitmaske für Eigenschaftstyp
			[helpstring("Eigenschaft ist systemintern")]
				FEATURETYPE_System = 0x100,			// @emem Eigenschaft ist systemintern
			[helpstring("Alle Eigenschaften liefern")]
				FEATURETYPE_AllFeatures = 0x200,		// @emem Alle Eigenschaften liefern
			[helpstring("Eigenschaft ist schreibgeschützt")]
				FEATURETYPE_ReadOnly = 0x400,		// @emem Eigenschaft ist schreibgeschützt
			[helpstring("Eigenschaft enthält ein Geometriefeld")]
				FEATURETYPE_Geometry = 0x800,		// @emem Eigenschaft enthält ein Geometriefeld
			[helpstring("Keine Objekte mit dieser Objekteigenschaft vorhanden")]
				FEATURETYPE_DefinitionOnly = 0x1000,		// @emem Keine Objekte mit dieser Objekteigenschaft vorhanden
			[helpstring("Eigenschaft ist global für Datenquelle")]
				FEATURETYPE_IsGlobal = 0x4000,		// @emem Eigenschaft ist global für Datenquelle
			[helpstring("Eigenschaft ist Standardeigenschaft (Default Geometry oder PrimaryKey)")]
				FEATURETYPE_IsPrimaryFeature = 0x8000,		// @emem Eigenschaft ist Standardeigenschaft (Default Geometry oder PrimaryKey)
			[helpstring("Das höherwertige Wort enthält den Datentyp der Eigenschaft")]
				FEATURETYPE_DataTypeMask = ~0xFFFF,		// @emem Das höherwertige Wort enthält den Datentyp der Eigenschaft
		} FEATURETYPE;
	cpp_quote("#define DATATYPE_FROM_VT(x)	MAKELONG(0,(x))")
	cpp_quote("#define VT_FROM_DATATYPE(x)	HIWORD(x)")
	cpp_quote("#endif // _FEATURETYPE_DEFINED")

	cpp_quote("#if !defined(_FEATURESTYPE_DEFINED)")
	cpp_quote("#define _FEATURESTYPE_DEFINED")
	// @doc FEATURESTYPEENUMS 
	// @enum FEATURESTYPE | Der Typ einer Objekteigenschaftsmenge.
	// @xref <i ITRiASFeatures>, <op ITRiASFeatures.FeaturesType>
		typedef [public, v1_enum, helpstring("Typ einer Objekteigenschaftsmenge.")]
		enum _tagFEATURESTYPE {
			[helpstring("Unbekannter Typ der Objekteigenschaftsmenge.")]
				FEATURESTYPE_Unknown = 0,			// @emem Unbekannter Typ der Objekteigenschaftsmenge 
			[helpstring("Objekteigenschaftsmenge enthält 'normale' Attribute.")]
				FEATURESTYPE_Attributes = 1,		// @emem Objekteigenschaftsmenge enthält 'normale' Attribute.
			[helpstring("Objekteigenschaftsmenge enthält Geometrieattribute.")]
				FEATURESTYPE_Geometries = 2,		// @emem Objekteigenschaftsmenge enthält Geometrieattribute.
		} FEATURESTYPE;
	cpp_quote("#endif // _FEATURESTYPE_DEFINED")

	// @doc IFEATURES
	// @property LONG | ITRiASFeatures | Count | Liefert die Anzahl der in dieser Objektsammlung 
	// enthaltenen Objekteigenschaften (readonly).
	// @comm Die Eigenschaft <op .Count> kann nicht gesetzt werden.
	// @supby <o TRiASFeatures> 
	// @xref <i ITRiASFeatures>
		[propget, id(3), helpstring("Liefert die Anzahl der Objekteigenschaften in dieser collection.")] HRESULT Count([out, retval] long *pVal);

	// @property <i ITRiASFeaturesCallback> * | ITRiASFeatures | FeaturesCallback | Die <op .FeaturesCallback>- Eigenschaft 
	// initialisiert das Rückrufinterface, über welches die Objektspezifik definiert wird.
	// @comm Das übergebene Objekt wird nicht festgehalten (kein AddRef!).
	// @supby <o TRiASFeatures> 
	// @xref <i ITRiASFeatures>, <i ITRiASFeaturesCallback>
		[propputref, id(4), helpstring("Zuordnen des Objektes, welches die Spezifik dieser Objekteigenschaftsmenge definiert.")] HRESULT FeaturesCallback(ITRiASFeaturesCallback *pICB);

	// @property <i IDispatch> * | ITRiASFeatures | RelatedObject | Die <op .RelatedObject>- Eigenschaft 
	// liefert bzw. setzt die Objektmenge (<o TRiASObjects> oder abgeleitete Objekte) oder das Objekt 
	// <o TRiASObject> oder abgeleitete Objekte), der/dem diese Objekteigenschaften zugeordnet sind.
	// @comm Das übergebene Objekt wird nicht festgehalten (kein AddRef!).
	// @supby <o TRiASFeatures> 
	// @xref <i ITRiASFeatures>, <i ITRiASObjects>, <i TRiASObject>
		[propget, id(5), helpstring("Liefert die Objektmenge oder das Objekt, der diese Objekteigenschaften zugeordnet sind.")] HRESULT RelatedObject([out, retval] IDispatch * *pVal);
		[propputref, id(5), helpstring("Setzt die Objektmenge oder das Objekt, der diese Objekteigenschaften zugeordnet sind.")] HRESULT RelatedObject([in] IDispatch * newVal);

	// @property <t FEATURESTYPE> | ITRiASFeatures | FeaturesType | Die <op .FeaturesType>- Eigenschaft 
	// liefert bzw. setzt den Typ dieser Objekteigenschaftsmenge.
	// @supby <o TRiASFeatures> 
	// @xref <i ITRiASFeatures>, <i ITRiASObjects>, <i TRiASObject>
		[propget, id(6), helpstring("Liefert den Typ dieser Objekteigenschaftsmenge.")] HRESULT FeaturesType([out, retval] FEATURESTYPE *pVal);
		[propput, id(6), helpstring("Setzt den Typ dieser Objekteigenschaftsmenge.")] HRESULT FeaturesType([in] FEATURESTYPE newVal);

	// @method HRESULT | ITRiASFeatures | Item | 
	// @supby <o TRiASFeatures> 
	// @xref <i ITRiASFeatures>
		[id(DISPID_DEFAULT), helpstring("Get the objectproperty by description or by index number.")] HRESULT Item([in] VARIANT Index, [out, retval] ITRiASFeature **Feature);

	// @method HRESULT | ITRiASFeatures | _NewEnum | Liefert einen neuen Enumerator, der alle 
	// Objekteigenschaften enthält, die in der vorliegenden Sammlung zusammengefaßt sind.
	// @parm IUnknown ** | Enum | Zeiger auf eine Variable vom Typ IUnknown *, welche nach erfolgreicher 
	// Abarbeitung der Methode <om ._NewEnum> den Ergebnis-Enumerator enthält.
	// @comm Der gelieferte Enumerator ist vom Typ <i IEnumVARIANT>. Daher sollte der Rückgabewert
	// explizit durch einen QueryInterface-Aufruf konvertiert werden.
	// @ex Das folgende Beispiel verdeutlicht die empfohlene Vorgehensweise |
	// IEnumVARIANT *pIEnum = NULL;
	// IUnknown *pIUnk = NULL;
	// HRESULT hr = pIEntries -> _NewEnum (&pIUnk);
	//
	//	if (SUCCEEDED(hr)) {
	//		hr = pIUnk -> QueryInterface(IID_IEnumVARIANT, (LPVOID *)&pIEnum);
	//		pIUnk -> Release();
	//	}
	//	...
	// @comm Normalerweise wird diese Funktion nicht direkt gerufen, Sie ist lediglich
	// für die Nutzung in Automation-Werkzeugen wie z.B. VisualBasic vorgesehen, wo sie
	// für Programmkonstrukte wie 'For Each ...' notwendig ist.
	// @supby <o TRiASFeatures> 
	// @xref <i ITRiASFeatures>, <i IEnumVARIANT>
		[id(DISPID_NEWENUM), hidden] HRESULT _NewEnum([out, retval] IUnknown **ppIEnum);

	// @method HRESULT | ITRiASFeatures | Add | Die <om .Add>- Methode erzeugt
	// eine neue Objekteigenschaft und fügt diesen zur vorliegenden Sammlung von 
	// Objekten hinzu.
	// @parm VARIANT | NameOrHandle | Der Parameter <p NameOrHandle> gibt den Namen oder die Zugriffsnummer der 
	// neu zu erzeugenden Objekteigenschaft vor.
	// @parm BSTR | Type | Der Parameter <p Type> legt den Typ des neu zu erzeugenden Objektes fest.
	// Ist der Wert dieses Parameters kein gültiger ProgID, dann wird ein Objektabhängiger Voreinstellungswert
	// verwendet.
	// @parm <t FEATURETYPE> | rgType | Der Parameter <p rgType> legt den Attributtyp der neu zu erzeugenden 
	// Objekteigenschaft fest
	// @comm Wird im Parameter <p NameOrHandle> die zugriffsnummer der Objekteigenschaft übergeben, dann
	// wird davon ausgegangen, das die Objekteigenschaft noch nicht existiert.
	// @supby <o TRiASFeatures>
	// @xref <i ITRiASFeatures>, <t FEATURETYPE>
	// @end
		[id(100), helpstring("Create and add a new objectproperty.")] HRESULT Add([in] VARIANT NameOrHandle, [in /*, optional*/, defaultvalue("")] BSTR Type, [in /*, optional*/, defaultvalue(FEATURETYPE_Unknown)] FEATURETYPE rgType, [out, retval] ITRiASFeature **Feature);

	// @method HRESULT | ITRiASFeatures | Remove | Die <om .Remove>- Methode entfernt
	// eine Objekteigenschaft aus der gegebenen Sammlung von Objekten.
	// @parm VARIANT | Index | Der Parameter <p Index> kann entweder die Zählummer des
	// (0 <lt> Index <lt>= Count), den Beschreibungstext der zu entfernenden 
	// Objekteigenschaft oder ein Objekt vom Typ <o TRiASFeature> enthalten.
	// @comm Zu Beachten ist, daß wenn eine Zeichenkette als Index übergeben wird, dann wird
	// diese als Beschreibungsinformation einer Objekteigenschaft ausgewertet 
	// (die Beschreibungsinformation wird durch die <op ITRiASFeature.Description>-
	// Eigenschaft geliefert).
	// @supby <o TRiASFeatures>
	// @xref <i ITRiASFeatures>, <op ITRiASFeature.Description>
		[id(101), helpstring("Remove a objectproperty")] HRESULT Remove([in] VARIANT Index);

	// zusätzliches
		[id(102), helpstring("Add an existing objectproperty."), hidden] HRESULT _Add([in] ITRiASFeature *Feature, [in /*, optional*/, defaultvalue(VARIANT_TRUE)] VARIANT_BOOL FullAdd);

	// @method HRESULT | ITRiASFeatures | _Clone | Die <om ._Clone>- Methode liefert eine neue 
	// Sammlung von Objekten, die identisch zur vorliegenden ist.
	// @parm <i ITRiASFeatures> ** | Enum | Zeiger auf eine Variable vom Typ <i ITRiASFeatures> *, 
	// welche nach erfolgreicher Abarbeitung der Methode <om ._Clone> die Kopie dieser 
	// Objektsammlung enthält.
	// @comm Bei Änderungen an der ursprünglichen Objektsammlung wird die neu erzeugte Kopie
	// nicht modifiziert.
	// @supby <o TRiASFeatures>
	// @xref <i ITRiASFeatures>
		[id(103), helpstring("Erzeugt eine neue Sammlung von Objekteigenschaften, die der vorliegenden identisch ist."), hidden] HRESULT _Clone([out, retval] ITRiASFeatures **Features);

	// @method HRESULT | ITRiASFeatures | SetEventSink | Die <om .SetEventSink>- Methode erlaubt
	// dieses Objekt bei einem anderen Objekt, welches den Connectionpoint für das Interface 
	// <i ITRiASFeatureEvents> implementiert hat, anzumelden bzw. abzumelden.
	// @parm IUnknown * | Unk | Dieser Parameter muß einen Zeiger auf ein IUnknown-Interface des Objektes
	// sein, bei dem sich unser Objekt an- bzw. abmelden soll. 
	// @parm DWORD * | Cookie | Dieser Parameter enthält einen Zeiger auf einen Speicherbereich, der nach
	// erfolgreicher Abarbeitung ein eindeutiges Handle enthält (für <p fAdvise> gleich VARIANT_TRUE),
	// das die erzeugte Verbindung kennzeichnet. Beim Auflösen der Verbindung muß dergleiche Zugriffswert
	// übergeben werden.
	// @parm VARIANT_BOOL | fAdvise | Das Objekt wird angemeldet, wenn dieser Parameter den Wert
	// <cv VARIANT_TRUE> enthält, anderenfalls wird das Objekt abgemeldet.
	// @supby <o TRiASFeatures> 
	// @xref <i ITRiASFeatures>, <i ITRiASFeatureEvents>
		[id(104), helpstring("Zuordnen des Targetobjektes zur Eventbehandlung."), hidden, restricted] HRESULT SetEventSink ([in] IUnknown *Unk, [in, out] DWORD *Cookie, [in] VARIANT_BOOL fAdvise);

		[id(105), helpstring("method Refresh")] HRESULT Refresh();
		[id(106), helpstring("method RefreshEx")] HRESULT RefreshEx([in] SETUPFEATURESMODE Mode);
	};

///////////////////////////////////////////////////////////////////////////////
// @doc INTERFACE TRIASDB
// @interface ITRiASFeaturesCallback | Das Interface <i ITRiASFeaturesCallback> dient der Verwaltung
// einer Sammlung von Objekteigenschaften.
// @supby <o TRiASSimpleFeatures>
// @group Methoden und Eigenschaften von <i ITRiASFeaturesCallback> 
// @index | IFEATURESCALLBACK
// @doc IFEATURESCALLBACK
	[
		object,
		uuid(EBC2D694-DEC1-11D1-8605-00600875138A),
		oleautomation,
		helpstring("ITRiASFeaturesCallback Interface"),
		pointer_default(unique)
	]
	interface ITRiASFeaturesCallback : IUnknown
	{
	cpp_quote("#if !defined(_CHANGEDFEATURES_DEFINED)")
	cpp_quote("#define _CHANGEDFEATURES_DEFINED")
	// @doc CHANGEDFEATURESENUMS 
	// @enum CHANGEDFEATURES | Flags geben an, was in einem Bezugsobjekt vom Typ <o TRiASFeaturess> 
	// modifiziert werden soll bzw. modifiziert worden ist.
	// @xref <i ITRiASFeaturesCallback>, <om ITRiASFeaturesCallback.OnChanging>, <om ITRiASFeaturesCallback.OnChanged>
		typedef [public, v1_enum, helpstring("Flags, was im Bezugsobjekt modifiert wurde.")]
		enum _tagCHANGEDFEATURES {
			[helpstring("Name wurde modifiziert.")]
				CHANGEDFEATURES_Name = 0x01,		// @emem Name wurde modifiziert
			[helpstring("Beschreibungsinfo wurde modifiziert.")]
				CHANGEDFEATURES_Description = 0x02,	// @emem Beschreibungsinfo wurde modifiziert
			[helpstring("Eindeutige Zugriffsnummer wurde modifiziert.")]
				CHANGEDFEATURES_Handle = 0x04,		// @emem Eindeutige Zugriffsnummer wurde modifiziert
		} CHANGEDFEATURES;
	cpp_quote("#endif // _CHANGEDFEATURES_DEFINED")

	// @doc IFEATURESCALLBACK
	// @property BSTR * | ITRiASFeaturesCallback | DefaultType | Die <op .DefaultType>- Eigenschaft
	// liefert den Type (ProgID) des im Standardfall zu instantiierenden Objektes.
	// @supby <o TRiASSimpleFeatures> 
	// @xref <i ITRiASFeaturesCallback>
		[propget, helpstring("Typ des standardmäßig zu erzeugenden Objektes.")] HRESULT DefaultType([out, retval] BSTR *Type);

	// @method HRESULT | ITRiASFeaturesCallback | SetupFeatures | Die <om .SetupFeatures> -Methode
	// fordert das Bezugsobjekt auf, die zu dieser Objektmenge gehörenden Metadaten zu initialisieren.
	// @parm IDispatch * | Parent | Gibt das als Parent für die <o TRiASFeature> -Objekte zu verwendende 
	// Objekt vor.
	// @parm <t SETUPFEATURESMODE> | SetupMode | Erzwingt gegebenenfalls das Neuinitialisieren evtl. eingelesener
	// Objekteigenschaften.
	// @comm Zu den zu initialisierenden Metadaten gehören die zu den Objekten dieser Objektmenge 
	// gehörenden Attribute (<o TRiASFeature> -Objekte), 
	// @supby <o TRiASSimpleFeatures> 
	// @xref <i ITRiASFeaturesCallback>, <t SETUPFEATURESMODE>
	// @end
		[helpstring("Initialiseren der Metadaten dieses Objekteigenschaftsmenge.")] HRESULT SetupFeatures([in] IDispatch *Parent, [in /*, optional*/, defaultvalue(SETUPFEATURESMODE_Normal)] SETUPFEATURESMODE SetupMode);

	// @method HRESULT | ITRiASFeaturesCallback | OnCreate | Die <om .OnCreate> -Methode wird
	// immer dann gerufen, wenn eine neue Objekteigenschaft erzeugt werden soll.
	// @supby <o TRiASSimpleFeatures> 
	// @xref <i ITRiASFeaturesCallback>
	// @end
		[helpstring("Eine Objekteigenschaft soll erzeugt werden.")] HRESULT OnCreate([in] VARIANT NameOrHandle, [in /*, optional, defaultvalue("")*/] BSTR Type, [in] FEATURETYPE rgType, [out, retval] ITRiASFeature **Feat);

	// @method HRESULT | ITRiASFeaturesCallback | OnChanging | Die <om .OnChanging>- Methode wird
	// immer dann gerufen, wenn das Bezugsobjekt in irgend einer Form modifiziert werden soll.
	// @parm <t CHANGEDFEATURES> | rgWhat | Der Parameter <p rgWhat> gibt an, was im Bezugsobjekt 
	// modifiziert werden soll.
	// @parm VARIANT | OldValue | Der Parameter <p NewValue> enthält den neuen Wert der eingestellt 
	// werden soll.
	// @parm VARIANT_BOOL * | DisAllow | Durch Setzen des Wertes des Parameters <p DisAllow> auf
	// <cv VARIANT_TRUE> kann die durchzuführende Aktion abgebrochen werden. Durch Setzen auf den Wert
	// <cv VARIANT_FALSE> wird das Einverständnis erteilt, die Aktion durchzuführen.
	// @supby <o TRiASSimpleFeatures> 
	// @xref <i ITRiASFeaturesCallback>, <t CHANGEDFEATURES>
		[helpstring("Irgend etwas wird modifiziert werden.")] HRESULT OnChanging([in] CHANGEDFEATURES rgWhat, [in] VARIANT NewValue, [out, retval] VARIANT_BOOL *DisAllow);

	// @method HRESULT | ITRiASFeaturesCallback | OnChanged | Die <om .OnChanged>- Methode wird
	// immer dann gerufen, wenn das Bezugsobjekt in irgend einer Form modifiziert wurde.
	// @parm <t CHANGEDFEATURES> | rgWhat | Der Parameter <p rgWhat> gibt an, was im Bezugsobjekt 
	// modifiziert wurde.
	// @parm VARIANT | OldValue | Der Parameter <p NewValue> enthält den alten Wert der vor der
	// Modifikation eingestellt gewesen war.
	// @supby <o TRiASSimpleFeatures> 
	// @xref <i ITRiASFeaturesCallback>, <t CHANGEDFEATURES>
		[helpstring("Irgend etwas wurde modifiziert.")] HRESULT OnChanged([in] CHANGEDFEATURES rgWhat, [in] VARIANT OldValue);

	// @method HRESULT | ITRiASFeaturesCallback | OnDelete | Die <om .OnDelete>- Methode wird
	// immer dann gerufen, eine Objekteigenschaft gelöscht werden soll.
	// @supby <o TRiASSimpleFeatures> 
	// @xref <i ITRiASFeaturesCallback>
		[helpstring("Eine Objekteigenschaft soll gelöscht werden.")] HRESULT OnDelete([in] VARIANT vWhich);

	// @method HRESULT | ITRiASObjectsCallback | OnFinalRelease | Die <om .OnFinalRelease>- Methode wird
	// immer dann gerufen, wenn das Objekt logisch freigegeben wird.
	// @supby <o TRiASSimpleObjects> 
	// @xref <i ITRiASObjectsCallback>
		[helpstring("Objekt wird logisch freigegeben.")] HRESULT OnFinalRelease();
	};

///////////////////////////////////////////////////////////////////////////////
// Eine Objekteigenschaft
// @doc INTERFACE TRIASDB
// @interface ITRiASFeature | Das Interface <i ITRiASFeature> 
// dient der Verwaltung eines <o TRiASFeature>- Objektes (also einer Objekteigenschaft).
// @supint <i ITRiASPropertyBase> | Dieses Interface wird implizit als Basisinterface des
// <i ITRiASObjects> implemntiert. Über dieses Interface werden die Eigenschaften 
// der jeweiligen Objektmenge zugänglich gemacht. Objektmengen, die einer Objektklasse entsprechen 
// exportieren hier z.B. die Objektklassen-Eigenschaften (Objektklassenschlüssel, Beschreibungsinfos
// oder andere Metadaten). Sind keine derartigen Eigenschaften vorgesehen, dann können die Methoden 
// von <i ITRiASPropertyBase> den Rückgabewert <cv E_NOTIMPL> liefern.
// @supby <o TRiASFeature>
// @group Methoden und Eigenschaften von <i ITRiASFeature> 
// @index | IFEATURE
// @doc IFEATURE
	[
		object,
		uuid(1CB3AB73-2E87-11D1-969D-00A024D6F582),
		dual,
		helpstring("ITRiASFeature Interface"),
		pointer_default(unique)
	]
	interface ITRiASFeature : ITRiASBase
	{
	cpp_quote("#if !defined(_EVALEXPARAM_DEFINED)")
	cpp_quote("#define _EVALEXPARAM_DEFINED")
	// @doc EVALEXPARAMENUMS 
	// @enum EVALEXPARAM | Der Typ eines zusätzlichen (optionalen) Parameters für die <om ITRiASFeature.EvalEx>- Methode.
	// @xref <i ITRiASFeature>, <om ITRiASFeature.EvalEx>
		enum _tagEVALEXPARAM {
			[helpstring("Koordinatensystem-GUID")]
				EVALEXPARAM_CoordSysGuid = 0,		// @emem Koordinatensystem-GUID
			[helpstring("Koordinatenbereich, in dem Objekte gesucht werden")]
				EVALEXPARAM_Window = 1,				// @emem Koordinatenbereich, in dem Objekte gesucht werden
			[helpstring("Objektcontainer (umschließendes Rechteck)")]
				EVALEXPARAM_Envelope = 2,			// @emem Objektcontainer (umschließendes Rechteck)
		};
	cpp_quote("#endif // _EVALEXPARAM_DEFINED")

	// @doc IFEATURE
	// @property BSTR | ITRiASFeature | Name | Die <op .Name>- Eigenschaft liefert bzw. setzt den 
	// Namen dieser Objekteigenschaft.
	// @comm Der gegebene Name sollte ein eindeutiger Bezeichner der Objekteigenschaft sein, der 
	// es erlaubt, diese Objekteigenschaft eindeutig zu identifizieren und wiederzufinden.
	// @supby <o TRiASFeature> 
	// @xref <i ITRiASFeature>
		[propget, id(DISPID_DEFAULT), helpstring("Liefert den Namen dieser Objekteigenschaft.")] HRESULT Name([out, retval] BSTR *pVal);
		[propput, id(DISPID_DEFAULT), helpstring("Setzt den Namen dieser Objekteigenschaft."), hidden] HRESULT Name([in] BSTR newVal);

	// @property BSTR | ITRiASFeature | Description | Die <op .Description>- Eigenschaft setzt bzw. liefert
	// einen ausführlicheren Beschreibungstext dieser Objekteigenschaft.
	// @supby <o TRiASFeature>
	// @xref <i ITRiASFeature>
		[propget, id(1), helpstring("Liefert den Beschreibungstext dieser Objekteigenschaft.")] HRESULT Description([out, retval] BSTR *pVal);
		[propput, id(1), helpstring("Setzt den Beschreibungstext dieser Objekteigenschaft.")] HRESULT Description([in] BSTR newVal);

	// @property LONG | ITRiASFeature | Handle | Die <op .Handle>- Eigenschaft liefert die eindeutige 
	// Zugriffsnummer dieser Objekteigenschaft. 
	// @devnote Die <op .Handle>- Eigenschaft kann gesetzt werden, 
	// um eine Voreinstellung für die Zugriffsnummer vorzunehmen. Diese Voreinstellung wird immer 
	// dann als Zugriffsnummer für diese Objekteigenschaft verwendet werden, wenn diese noch nicht 
	// für ein anderes Objekt identischen Types vergeben worden ist. Das Setzen dieser Eigenschaft 
	// hat nur dann eine Wirkung, wenn noch keine Zugriffsnummer für dieses Objekt vergeben wurde.
	// @supby <o TRiASFeature> 
	// @xref <i ITRiASFeature>
		[propget, id(2), helpstring("Liefert die eindeutige Zugriffsnummer dieser Objekteigenschaft."), hidden, restricted] HRESULT Handle([out, retval] INT_PTR *pVal);
		[propput, id(2), helpstring("Setzt eine Voreinstellung für die eindeutige Zugriffsnummer dieser Objekteigenschaft."), hidden, restricted] HRESULT Handle([in] INT_PTR newVal);

	// @property <i ITRiASFeatureCallback> * | ITRiASFeature | FeatureCallback | Die <op .FeatureCallback>- Eigenschaft 
	// initialisiert das Rückrufinterface, über welches die Objektspezifik definiert wird.
	// @comm Das übergebene Objekt wird nicht festgehalten (kein AddRef!).
	// @supby <o TRiASFeature> 
	// @xref <i ITRiASFeature>, <i ITRiASFeatureCallback>
		[propputref, id(3), helpstring("Zuordnen des Objektes, welches die Spezifik dieser Objekteigenschaft definiert.")] HRESULT FeatureCallback(ITRiASFeatureCallback *pICB);

	// @property <t FEATURETYPE> | ITRiASFeature | Type | Die <op .Type>- Eigenschaft liefert bzw. setzt den 
	// Typ dieser Objekteigenschaft.
	// @supby <o TRiASFeature> 
	// @xref <i ITRiASFeature>
		[propget, id(4), helpstring("Liefert den Typ dieser Objekteigenschaft.")] HRESULT Type([out, retval] FEATURETYPE *pVal);
		[propput, id(4), helpstring("Setzt den Typ dieser Objekteigenschaft.")] HRESULT Type([in] FEATURETYPE newVal);

	// @property VARIANT_BOOL | ITRiASFeature | Updatable | Die <op .Updatable>- Eigenschaft liefert bzw. 
	// setzt, ob diese Objekteigenschaft beschreibbar ist.
	// @supby <o TRiASFeature> 
	// @xref <i ITRiASFeature>
		[propget, id(5), helpstring("Liefert ob diese Objekteigenschaft beschreibbar ist.")] HRESULT Updatable([out, retval] VARIANT_BOOL *pVal);
		[propput, id(5), helpstring("Setzt ob diese Objekteigenschaft beschreibbar ist.")] HRESULT Updatable([in] VARIANT_BOOL newVal);

	// @method HRESULT | ITRiASFeature | Eval | Die <om .Eval>- Methode liefert den Wert der 
	// Objekteigenschaft für ein gegebenes Objekt.
	// @parm <i ITRiASObject> * | Obj | Der Parameter <p Obj> gibt das Objekt an, für welches die 
	// Eigenschaft berechnet werden soll.
	// @parm VARIANT * | Value | Der Parameter <p Value> enthält nach erfolgreicher Abarbeitung der 
	// <om .Eval>- Methode den gesuchten Wert der Objekteigenschaft für das gegeben Objekt.
	// @supby <o TRiASFeature> 
	// @xref <i ITRiASFeature>, <i ITRiASObject>
		[id(100), helpstring("Liefert den Wert der Objekteigenschaft für ein gegebenes Objekt.")] HRESULT Eval([in] ITRiASObject *Obj, [out, retval] VARIANT *Val);

	// @method HRESULT | ITRiASFeature | EvalEx | Die <om .EvalEx>- Methode liefert den Wert der 
	// Objekteigenschaft für ein gegebenes Objekt unter zusätzlichen Randbedingungen.
	// @parm <i ITRiASObject> * | Obj | Der Parameter <p Obj> gibt das Objekt an, für welches die 
	// Eigenschaft berechnet werden soll.
	// @parm SAFEARRAY(VARIANT) | Constraints | Zusätzliche Randbedingungen für die Berechnung des 
	// Wertes der Objekteigenschaft. 
	// @parm VARIANT * | Value | Der Parameter <p Value> enthält nach erfolgreicher Abarbeitung der 
	// <om .EvalEx>- Methode den gesuchten Wert der Objekteigenschaft für das gegeben Objekt.
	// @devnote Die Methode <om .EvalEx> wird in erster Linie für die Abfrage von Geometriefeldern
	// eingesetzt, dabei können im Parameter <p Constraints> bis zu 3 zusätzliche Parameter in Form eines 
	// SAFEARRAY(VARIANT) übergeben werden. <nl>Wenn der erste Parameter gegeben ist, dann muß hier der GUID des
	// Koordinatensystemes (i.a. in Form eines BSTR) geliefert werden, in Bezug auf welches die übergebenen 
	// Koordinaten berechnet sind.<nl>Wenn der zweite Parameter gegeben ist
	// (2. Element des SAFEARRAY(VARIANT)) dann wird dieser als <i IDispatch> Interfacepointer
	// interpretiert, hinter dem sich ein <o DGMRectangleGeometry> Objekt verbirgt. Dieses Objekt ist
	// auf das aktuelle Such-Fenster initialisiert, d.h. alle Objekte, die vollständig außerhalb dieses
	// Suchfensters liegen, müssen nicht geladen werden und die <om .EvalEx>- Methode kann den Wert
	// <cv TRIASDB_S_OBJECTDOESNOTFIT> liefern.<nl>Der dritte Parameter enthält nach erfolgreicher 
	// Abarbeitung der Methode den umschließenden Container des Objektes ebenfalls in Form eines
	// <o DGMRectangleGeometry>- Objektes (auch hier ein <i IDispatch>- Pointer).
	// @rvalue <cv TRIASDB_S_OBJECTDOESNOTFIT> | Die zu ladende Objektgeometrie liegt vollständig
	// außerhalb des im zweiten optionalen Parameter gegebenen Suchfenster. In diesem Fall wird die 
	// Objektgeometrie nicht geliefert.
	// @supby <o TRiASFeature> 
	// @xref <i ITRiASFeature>, <i ITRiASObject>
		[id(101), helpstring("Liefert den Wert der Objekteigenschaft für ein gegebenes Objekt unter zusätzlichen Randbedingungen.")] HRESULT EvalEx([in] ITRiASObject *Obj, [in, out] SAFEARRAY(VARIANT) *Constraints, [out, retval] VARIANT *Val);

	// @method HRESULT | ITRiASFeature | Update | Die <om .Update>- Methode setzt den Wert der 
	// Objekteigenschaft für ein gegebenes Objekt.
	// @parm <i ITRiASObject> * | Obj | Der Parameter <p Obj> gibt das Objekt an, für welches die 
	// Eigenschaft berechnet werden soll.
	// @parm VARIANT | Value | Der Parameter <p Value> enthält den neuen Wert für die Objekteigenschaft.
	// des gegebenen Objektes.
	// @rvalue <cv TRIASDB_W_ISREADONLY> | Die Objekteigenschaft unterstützt keine Schreiboperationen 
	// (ist schreibgeschützt). Dieser Wert wird immer dann geliefert, wenn die <op .Type>- Eigenschaft
	// den Wert <e FEATURETYPE.FEATURETYPE_ReadOnly> liefert.
	// @supby <o TRiASFeature> 
	// @xref <i ITRiASFeature>, <i ITRiASObject>, <t FEATURETYPE>
		[id(102), helpstring("Setzt den Wert der Objekteigenschaft für ein gegebenes Objekt.")] HRESULT Update([in] ITRiASObject *Obj, [in] VARIANT Val);

	// @method HRESULT | ITRiASFeature | Clone | Die <om .Clone>- Methode erzeugt eine Kopie der
	// vorliegenden Objekteigenschaft.
	// @supby <o TRiASFeature> 
	// @xref <i ITRiASFeatureCallback>
		[id(103), helpstring("Erzeugt eine Kopie der vorliegenden Objekteigenschaft.")] HRESULT Clone ([out, retval] ITRiASFeature **NewFeat);

	// @property VARIANT_BOOL | ITRiASFeature | Length | Die <op .Updatable>- Eigenschaft liefert
	// bzw. setzt die Feldlänge dieser Objekteigenschaft
	// @supby <o TRiASFeature> 
	// @xref <i ITRiASFeature>
		[propget, id(6), helpstring("Liefert die Feldlänge dieser Objekteigenschaft.")] HRESULT Length([out, retval] long *pVal);
		[propput, id(6), helpstring("Setzt die Feldlänge dieser Objekteigenschaft.")] HRESULT Length([in] long newVal);
	};

///////////////////////////////////////////////////////////////////////////////
// @doc INTERFACE TRIASDB
// @interface ITRiASFeatureCallback | Das Interface <i ITRiASFeatureCallback> dient der Verwaltung
// einer Objekteigenschaft.
// @supby <o TRiASSimpleFeature>
// @group Methoden und Eigenschaften von <i ITRiASFeatureCallback> 
// @index | IFEATURECALLBACK
// @doc IFEATURECALLBACK
	[
		object,
		uuid(EBC2D693-DEC1-11D1-8605-00600875138A),
		oleautomation,
		helpstring("ITRiASFeatureCallback Interface"),
		pointer_default(unique)
	]
	interface ITRiASFeatureCallback : IUnknown
	{
	cpp_quote("#if !defined(_SETUPFEATUREMODE_DEFINED)")
	cpp_quote("#define _SETUPFEATUREMODE_DEFINED")
	// @doc SETUPFEATUREMODEENUMS 
	// @enum SETUPFEATUREMODE | Der Mode, in dem die Metadaten einer Objekteigenschaft geladen werden sollen.
	// @xref <i ITRiASFeatureCallback>, <om ITRiASFeatureCallback.SetupFeature>
		typedef [public, v1_enum, helpstring("Modi zum Laden der Metadaten einer Objekteigenschaftsmenge.")]
		enum _tagSETUPFEATUREMODE {
			[helpstring("Objektinstanz initialisieren.")]
				SETUPFEATUREMODE_InitOrLoad = 0,			// @emem Objektinstanz initialisieren
			[helpstring("Normale Initialisierung.")]
				SETUPFEATUREMODE_Normal = 1,			// @emem Normale Initialisierung
			[helpstring("Angeforderte Aktion erneut erzwingen.")]
				SETUPFEATUREMODE_Force = 0x8000,		// @emem Angeforderte Aktion erneut erzwingen
		} SETUPFEATUREMODE;
	cpp_quote("#endif // _SETUPFEATUREMODE_DEFINED")

	cpp_quote("#if !defined(_CHANGEDFEATURE_DEFINED)")
	cpp_quote("#define _CHANGEDFEATURE_DEFINED")
	// @doc CHANGEDFEATUREENUMS 
	// @enum CHANGEDFEATURE | Flags geben an, was in einem Bezugsobjekt vom Typ <o TRiASFeature> 
	// modifiziert werden soll bzw. modifiziert worden ist.
	// @xref <i ITRiASFeatureCallback>, <om ITRiASFeatureCallback.OnChanging>, <om ITRiASFeatureCallback.OnChanged>
		typedef [public, v1_enum, helpstring("Flags, was im Bezugsobjekt modifiert wurde.")]
		enum _tagCHANGEDFEATURE {
			[helpstring("Name wurde modifiziert.")]
				CHANGEDFEATURE_Name = 0x01,			// @emem Name wurde modifiziert
			[helpstring("Beschreibungsinfo wurde modifiziert.")]
				CHANGEDFEATURE_Description = 0x02,	// @emem Beschreibungsinfo wurde modifiziert
			[helpstring("Eindeutige Zugriffsnummer wurde modifiziert.")]
				CHANGEDFEATURE_Handle = 0x04,		// @emem Eindeutige Zugriffsnummer wurde modifiziert
			[helpstring("Der Objekteigenschaftswert wurde modifiziert.")]
				CHANGEDFEATURE_Value = 0x08,		// @emem Der Objekteigenschaftswert wurde modifiziert
			[helpstring("Schreibschutz wurde modifiziert.")]
				CHANGEDFEATURE_ROMode = 0x10,		// @emem Schreibschutz wurde modifiziert
			[helpstring("Typ wurde modifiziert.")]
				CHANGEDFEATURE_Type = 0x20,			// @emem Der Type der Objekteigenschaft wurde modifiziert
			[helpstring("Feldlänge wurde modifiziert.")]
				CHANGEDFEATURE_Length = 0x40,		// @emem Feldlänge Zugriffsnummer wurde modifiziert
		} CHANGEDFEATURE;
	cpp_quote("#endif // _CHANGEDFEATURE_DEFINED")

	// @doc IFEATURECALLBACK
	// @property BSTR * | ITRiASFeatureCallback | DefaultType | Die <op .DefaultType>- Eigenschaft
	// liefert den Type (ProgID) des im Standardfall zu instantiierenden Objektes.
	// @supby <o TRiASSimpleFeature> 
	// @xref <i ITRiASFeatureCallback>
		[propget, helpstring("Typ des standardmäßig zu erzeugenden Objektes.")] HRESULT DefaultType([out, retval] BSTR *Type);

	// @method HRESULT | ITRiASObjectCallback | SetupFeature | Die <om .SetupFeature>- Methode
	// fordert das Bezugsobjekt auf, sich vollständig zu initialisieren.
	// @parm <t SETUPFEATUREMODE> | SetupMode | der Parameter <p SetupMode> gibt vor, welche Informationen sichergestellt 
	// werden sollen.
	// @supby <o TRiASSimpleFeature> 
	// @xref <i ITRiASFeatureCallback>, <t SETUPFEATUREMODE>
	// @end
		[helpstring("Initialiseren der Metadaten dieses Objektes.")] HRESULT SetupFeature([in /*, optional*/, defaultvalue(SETUPFEATUREMODE_Normal)] SETUPFEATUREMODE SetupMode);

	// @method HRESULT | ITRiASFeatureCallback | OnChanging | Die <om .OnChanging>- Methode wird
	// immer dann gerufen, wenn das Bezugsobjekt in irgend einer Form modifiziert werden soll.
	// @parm <t CHANGEDFEATURE> | rgWhat | Der Parameter <p rgWhat> gibt an, was im Bezugsobjekt 
	// modifiziert werden soll.
	// @parm VARIANT | OldValue | Der Parameter <p NewValue> enthält den neuen Wert der eingestellt 
	// werden soll.
	// @parm VARIANT_BOOL * | DisAllow | Durch Setzen des Wertes des Parameters <p DisAllow> auf
	// <cv VARIANT_TRUE> kann die durchzuführende Aktion abgebrochen werden. Durch Setzen auf den Wert
	// <cv VARIANT_FALSE> wird das Einverständnis erteilt, die Aktion durchzuführen.
	// @supby <o TRiASSimpleFeature> 
	// @xref <i ITRiASFeatureCallback>, <t CHANGEDFEATURE>
		[helpstring("Irgend etwas wird modifiziert werden.")] HRESULT OnChanging([in] CHANGEDFEATURE rgWhat, [in] VARIANT NewValue, [out, retval] VARIANT_BOOL *DisAllow);

	// @method HRESULT | ITRiASFeatureCallback | OnChanged | Die <om .OnChanged>- Methode wird
	// immer dann gerufen, wenn das Bezugsobjekt in irgend einer Form modifiziert wurde.
	// @parm <t CHANGEDFEATURE> | rgWhat | Der Parameter <p rgWhat> gibt an, was im Bezugsobjekt 
	// modifiziert wurde.
	// @parm VARIANT | OldValue | Der Parameter <p NewValue> enthält den alten Wert der vor der
	// Modifikation eingestellt gewesen war.
	// @supby <o TRiASSimpleFeature> 
	// @xref <i ITRiASFeatureCallback>, <t CHANGEDFEATURE>
		[helpstring("Irgend etwas wurde modifiziert.")] HRESULT OnChanged([in] CHANGEDFEATURE rgWhat, [in] VARIANT OldValue);
	
	// @method HRESULT | ITRiASFeatureCallback | Eval | Die <om .Eval>- Methode liefert den Wert 
	// der Objekteigenschaft für ein gegebenes Objekt.
	// @parm <i ITRiASObject> * | Obj | Der Parameter <p Obj> gibt das Objekt an, für welches die 
	// Eigenschaft berechnet werden soll.
	// @parm VARIANT * | Value | Der Parameter <p Value> enthält nach erfolgreicher Abarbeitung der 
	// <om .Eval>- Methode den gesuchten Wert der Objekteigenschaft für das gegeben Objekt.
	// @supby <o TRiASSimpleFeature> 
	// @xref <i ITRiASFeatureCallback>
		[helpstring("Liefert den Wert der Objekteigenschaft für ein gegebenes Objekt.")] HRESULT Eval([in] ITRiASObject *Obj, [out, retval] VARIANT *pVal);

	// @method HRESULT | ITRiASFeatureCallback | EvalEx | Die <om .EvalEx>- Methode liefert den Wert der 
	// Objekteigenschaft für ein gegebenes Objekt unter zusätzlichen Randbedingungen.
	// @parm <i ITRiASObject> * | Obj | Der Parameter <p Obj> gibt das Objekt an, für welches die 
	// Eigenschaft berechnet werden soll.
	// @parm SAFEARRAY(VARIANT) | Constraints | Zusätzliche Randbedingungen für die Berechnung des 
	// Wertes der Objekteigenschaft. 
	// @parm VARIANT * | Value | Der Parameter <p Value> enthält nach erfolgreicher Abarbeitung der 
	// <om .EvalEx>- Methode den gesuchten Wert der Objekteigenschaft für das gegeben Objekt.
	// @supby <o TRiASFeature> 
	// @xref <i ITRiASFeature>, <i ITRiASObject>
		[helpstring("Liefert den Wert der Objekteigenschaft für ein gegebenes Objekt unter zusätzlichen Randbedingungen.")] HRESULT EvalEx([in] ITRiASObject *Obj, [in, out] SAFEARRAY(VARIANT) *Constraints, [out, retval] VARIANT *Val);

	// @method HRESULT | ITRiASFeatureCallback | Update | Die <om .Update>- Methode setzt den Wert 
	// der Objekteigenschaft für ein gegebenes Objekt.
	// @parm <i ITRiASObject> * | Obj | Der Parameter <p Obj> gibt das Objekt an, für welches der
	// neue Wert der Eigenschaft gesetzt werden soll.
	// @parm VARIANT | Value | Der Parameter <p Value> enthält den neuen einzustellenden Wert
	// der Objekteigenschaft für das gegeben Objekt.
	// @rvalue <cv TRIASDB_W_ISREADONLY> | Die Objekteigenschaft unterstützt keine Schreiboperationen 
	// (ist schreibgeschützt). 
	// @supby <o TRiASSimpleFeature> 
	// @xref <i ITRiASFeatureCallback>
		[helpstring("Setzt den Wert der Objekteigenschaft für ein gegebenes Objekt.")] HRESULT Update([in] ITRiASObject *Obj, [in] VARIANT Val);

	// @method HRESULT | ITRiASFeatureCallback | Clone | Die <om .Clone>- Methode erzeugt eine Kopie der
	// vorliegenden Objekteigenschaft.
	// @supby <o TRiASSimpleFeature> 
	// @xref <i ITRiASFeatureCallback>
		[helpstring("Erzeugt eine Kopie der vorliegenden Objekteigenschaft.")] HRESULT Clone ([out, retval] ITRiASFeature **NewFeat);

	// @method HRESULT | ITRiASObjectsCallback | OnFinalRelease | Die <om .OnFinalRelease>- Methode wird
	// immer dann gerufen, wenn das Objekt logisch freigegeben wird.
	// @supby <o TRiASSimpleObjects> 
	// @xref <i ITRiASObjectsCallback>
		[helpstring("Objekt wird logisch freigegeben.")] HRESULT OnFinalRelease();
	};

///////////////////////////////////////////////////////////////////////////////
// @doc INTERFACE TRIASDB
// @interface ITRiASSearchObjects | Das Interface <i ITRiASSearchObjects> dient der Verwaltung
// von Recherchefunktionalitäten für eine Objekteigenschaft.
// @supby <o TRiASSimpleFeature>
// @group Methoden und Eigenschaften von <i ITRiASSearchObjects> 
// @index | IFEATURESEARCH
// @doc IFEATURESEARCH
	[
		object,
		uuid(C92461C5-2139-11D2-9E9C-006008447800),
		dual,
		helpstring("ITRiASSearchObjects Interface"),
		pointer_default(unique)
	]
	interface ITRiASSearchObjects : IDispatch
	{
	// @method HRESULT | ITRiASSearchObjects | ConsiderSearch | Die <om .ConsiderSearch>- Methode
	// testet, ob die geforderte Recherchefunktionalität von diesem Objekt unterstützt wird.
	// @parm BSTR | Command | Der Parameter <p Command> enthält eine objektspezifische Zeichenkette, 
	// die die auszuführende Rechercheoperation beschreibt.
	// @parm SAFEARRAY(VARIANT) | Params | Der Parameter <p Params> enthält ggf. zusätzliche Parametrisierungen
	// für die Rechercheoperation in Form von Elementen des übergebenen SAFEARRAY(VARIANT).
	// @rvalue <cv S_OK> | Die geforderte Recherchefunktionalität wird vollständig unterstützt.
	// @rvalue <cv TRIASDB_S_SEARCHNOTRECOMMENDED> | Die geforderte Recherefunktionalität wird unterstützt 
	// ist aber nicht zu empfehlen (da wahrscheinlich langsam).
	// @rvalue <cv E_NOTIMPL> oder <cv TRIASDB_S_SEARCH_NOT_SUPPORTED> | Die geforderte Recherchefunktionalität 
	// wird _nicht_ unterstützt.
	// @supby <o TRiASSimpleFeature>, <o TRiASSimpleGeoFeature>  
	// @xref <i ITRiASSearchObjects>, <l Recherchen in TRiAS®>
	// @end
		[id(100), helpstring("Testen, ob die geforderte Recherchefunktionalität von diesem Objekt unterstützt wird.")] HRESULT ConsiderSearch([in] BSTR Command, [in/*, optional */] SAFEARRAY(VARIANT) Params);

	// @method HRESULT | ITRiASSearchObjects | SearchObjects | Die <om .SearchObjects>- Methode
	// findet alle Objekte, die dem gegebenen Recherchekriterium genügen.
	// @parm BSTR | Command | Der Parameter <p Command> enthält eine objektspezifische Zeichenkette, 
	// die die Auszuführende Rechercheoperation beschreibt.
	// @parm <i ITRiASObjects> * | Obj | Dieser Parameter enthält einen Zeiger auf ein 
	// <o TRiASObjects>- Objekt, zu welchem die gefundenen Objekte hinzugefügt werden sollen.
	// @parm SAFEARRAY(VARIANT) | Params | Der Parameter <p Params> enthält ggf. zusätzliche Parametrisierungen
	// für die Rechercheoperation in Form von Elementen des übergebenen SAFEARRAY(VARIANT).
	// Der erste Wert dieses Feldes enthält das Recherchekriterium (z.B. die zu suchende Zeichenkette).
	// @rvalue <cv E_NOTIMPL> oder <cv TRIASDB_S_SEARCH_NOT_SUPPORTED> | Die geforderte Recherchefunktionalität 
	// wird _nicht_ unterstützt.
	// @supby <o TRiASSimpleFeature>, <o TRiASSimpleGeoFeature>  
	// @xref <i ITRiASSearchObjects>, <l Recherchen in TRiAS®>
	// @end
		[id(101), helpstring("Finden aller Objekte, die dem gegebenen Recherchekriterium genügen.")] HRESULT SearchObjects([in] BSTR Command, [in] ITRiASObjects *Objs, [in /*, optional*/] SAFEARRAY(VARIANT) Params);

	// @method HRESULT | ITRiASSearchObjects | ConstraintObjects | Die <om .ConstraintObjects> -Methode
	// gewährleistet, daß alle Objekte der Eingabemenge zu einer der Objektklassen dieser Sammlung gehören.
	// @parm <i ITRiASObjects> * | ObjsIn | Der Parameter <p ObjsIn> enthält die Eingabeobjektmenge, deren
	// Elemente auf Zugehörigkeit zu einer in dieser Sammlung enthaltenen Objektklasse überprüft werden sollen.
	// Dabei werden aus der durch den Parameter <p ObjsIn> gegebenen Objektmenge alle diejenigen Objekte
	// entfernt, welche nicht einer der Objektklassen dieser Sammlung zugeordnet sind.
	// @supby <o TRiASObjectsCollection> 
	// @xref <i ITRiASObjectsCollection>, <l Recherchen in TRiAS®>
		[id(102), helpstring("Gewährleistet, daß alle Objekte der Eingabemenge zu einer der Objektklassen dieser Sammlung gehören.")] HRESULT ConstraintObjects([in] ITRiASObjects *Obj);
	};

///////////////////////////////////////////////////////////////////////////////
// Relations-Collection
// @doc INTERFACE TRIASDB
	[
		object,
		uuid(1CB3AB75-2E87-11D1-969D-00A024D6F582),
		dual,
		helpstring("ITRiASRelations Interface"),
		pointer_default(unique)
	]
	interface ITRiASRelations : IDispatch
	{
	};

///////////////////////////////////////////////////////////////////////////////
// Eine Objektrelation
// @doc INTERFACE TRIASDB
	[
		object,
		uuid(1CB3AB77-2E87-11D1-969D-00A024D6F582),
		dual,
		helpstring("ITRiASRelation Interface"),
		pointer_default(unique)
	]
	interface ITRiASRelation : IDispatch
	{
	};
	
///////////////////////////////////////////////////////////////////////////////
// allgemeine Verwaltung von Properties
// @doc INTERFACE TRIASDB
	[
		object,
		uuid(9A9E8F26-3D7F-11D1-96C0-00A024D6F582),
		dual,
		helpstring("ITRiASProperties Interface"),
		pointer_default(unique)
	]
	interface ITRiASProperties : ITRiASBase
	{
	// @property LONG | ITRiASProperties | Count | Liefert die Anzahl der in dieser Objektsammlungen 
	// enthaltenen Objekte (readonly).
	// @comm Die Eigenschaft <op .Count> kann nicht gesetzt werden.
	// @supby <o TRiASProperties>
	// @xref <i ITRiASProperties>
		[propget, id(3), helpstring("Number of properties.")] HRESULT Count([out, retval] long *pVal);

	// @method HRESULT | ITRiASProperties | Item | 
	// @supby <o TRiASProperties>
	// @xref <i ITRiASProperties>
		[id(DISPID_DEFAULT), helpstring("Get the property by name or by index.")] HRESULT Item([in] VARIANT Which, [out, retval] ITRiASProperty **Property);

	// @method HRESULT | ITRiASProperties | _NewEnum | Liefert einen neuen
	// Enumerator, der alle Objekte enthält, die in der vorliegenden Sammlung zusammengefaßt sind.
	// @parm IUnknown ** | Enum | Zeiger auf eine Variable vom Typ IUnknown *, welche nach erfolgreicher 
	// Abarbeitung der Methode <om ._NewEnum> den Ergebnis-Enumerator enthält.
	// @comm Der gelieferte Enumerator ist vom Typ <i IEnumVARIANT>. Daher sollte der Rückgabewert
	// explizit durch einen QueryInterface-Aufruf konvertiert werden.
	// @ex Das folgende Beispiel verdeutlicht die empfohlene Vorgehensweise |
	// IEnumVARIANT *pIEnum = NULL;
	// IUnknown *pIUnk = NULL;
	// HRESULT hr = pIEntries -> _NewEnum (&pIUnk);
	//
	//	if (SUCCEEDED(hr)) {
	//		hr = pIUnk -> QueryInterface(IID_IEnumVARIANT, (LPVOID *)&pIEnum);
	//		pIUnk -> Release();
	//	}
	//	...
	// @comm Normalerweise wird diese Funktion nicht direkt gerufen, Sie ist lediglich
	// für die Nutzung in Automation-Werkzeugen wie z.B. VisualBasic vorgesehen, wo sie
	// für Programmkonstrukte wie 'For Each ...' notwendig ist.
	// @supby <o TRiASProperties>
	// @xref <i ITRiASProperties>
		[id(DISPID_NEWENUM), hidden] HRESULT _NewEnum([out, retval] IUnknown **ppIEnum);

		[id(100), helpstring("Create a new property and add it to the collection.")] HRESULT Add([in] VARIANT Which, [out, retval] ITRiASProperty **Property);
		[id(101), helpstring("Remove a property from the collection.")] HRESULT Remove([in] VARIANT Which);

	// zusätzliches
		[id(102), helpstring("Add an existing property."), hidden] HRESULT _Add([in] ITRiASProperty *Prop, [in /*, optional*/, defaultvalue(VARIANT_TRUE)] VARIANT_BOOL FullAdd);

	// @method HRESULT | ITRiASProperties | _Clone | Die <om ._Clone>- Methode liefert eine 
	// neue Sammlung von Objekten, die identisch zur vorliegenden ist.
	// @parm <i ITRiASProperties> ** | Enum | Zeiger auf eine Variable vom Typ <i ITRiASProperties> *, 
	// welche nach erfolgreicher Abarbeitung der Methode <om ._Clone> die Kopie dieser 
	// Objektsammlung enthält.
	// @comm Bei Änderungen an der ursprünglichen Objektsammlung wird die neu erzeugte Kopie
	// nicht modifiziert.
	// @supby <o TRiASProperties>
	// @xref <i ITRiASProperties>
		[id(103), helpstring("Erzeugt eine Sammlung von Properties (Eigenschaften), die der vorliegenden identisch ist."), hidden] HRESULT _Clone([out, retval] ITRiASProperties **Props);

		[id(104), helpstring("Liest alle existierenden Eigenschaften des Bezugsobjektes neu ein (Vorsicht! Zeitaufwendig!).")] HRESULT Refresh();
		[id(105), helpstring("Zuordnen des Targetobjektes zur Eventbehandlung."), hidden, restricted] HRESULT SetEventSink ([in] IUnknown *pIUnk, [in] VARIANT_BOOL fAdvise);
	};

// @doc INTERFACE TRIASDB
	[
		object,
		uuid(9A9E8F24-3D7F-11D1-96C0-00A024D6F582),
		dual,
		helpstring("ITRiASProperty Interface"),
		pointer_default(unique)
	]
	interface ITRiASProperty : IDispatch
	{
	cpp_quote("#if !defined(_PROPERTY_TYPE_DEFINED)")
	cpp_quote("#define _PROPERTY_TYPE_DEFINED")
		typedef [public, v1_enum, helpstring("Bekannte PROPERTY_TYPE's")]
		enum _tagPROPERTY_TYPE {
			[helpstring("Normale Property.")]
				PROPERTY_TYPE_Normal = 0x00,
			[helpstring("Systeminterne Property.")]
				PROPERTY_TYPE_System = 0x01,
			[helpstring("Schreibgeschützte Property.")]
				PROPERTY_TYPE_ReadOnly = 0x02,
			[helpstring("Dynamisch generierte Property."), hidden, restricted]
				PROPERTY_TYPE_Dynamic = 0x04,
			[helpstring("Das zugehörige Propertysupportobjekt kann sich nicht selbst speichern."), hidden, restricted]
				PROPERTY_TYPE_NeedsSavingHelp = 0x08,
			[helpstring("Property ist in der Nutzeroberfläche nicht zu sehen."), hidden, restricted]
				PROPERTY_TYPE_Hidden = 0x10,
		} PROPERTY_TYPE;
	cpp_quote("#endif // _PROPERTY_TYPE_DEFINED")

		[propget, id(DISPID_DEFAULT), helpstring("Liefert den Wert dieser Eigenschaft.")] HRESULT Value([out, retval] VARIANT *pVal);
		[propput, id(DISPID_DEFAULT), helpstring("Setzt den Wert dieser Eigenschaft.")] HRESULT Value([in] VARIANT newVal);
		[propget, id(1), helpstring("Liefert den Bezeichner dieser Eigenschaft (dient als Identifikation).")] HRESULT Name([out, retval] BSTR *pVal);
		[propput, id(1), helpstring("Setzt den Bezeichner dieser Eigenschaft (dient als Identifikation).")] HRESULT Name([in] BSTR newVal);
		[propget, id(2), helpstring("Liefert den Typ dieser Eigenschaft.")] HRESULT Type([out, retval] PROPERTY_TYPE *pVal);
		[propput, id(2), helpstring("Setzt den Typ dieser Eigenschaft.")] HRESULT Type([in] PROPERTY_TYPE newVal);
		[propget, id(3), helpstring("Liefert, ob diese Eigenschaft von einem anderen Objekt vererbt (übernommen) wurde.")] HRESULT Inherited([out, retval] VARIANT_BOOL *pVal);
		[propget, id(4), helpstring("Liefert den Beschreibungstext dieser Eigenschaft.")] HRESULT Description([out, retval] BSTR *pVal);
		[propput, id(4), helpstring("Setzt den Beschreibungstext dieser Eigenschaft.")] HRESULT Description([in] BSTR newVal);
		[id(100), helpstring("Liefert den Wert und den Typ dieser Eigenschaft.")] HRESULT GetValueAndType([in, out] VARIANT *pVal, [in, out] PROPERTY_TYPE *pType);
		[id(101), helpstring("Setzt den Wert und den Typ dieser Eigenschaft.")] HRESULT SetValueAndType([in] VARIANT Val, [in] PROPERTY_TYPE Type);
		[id(102), helpstring("Liest den Wert dieser spezifischen Eigenschaft neu ein.")] HRESULT Refresh();
	};

// @doc INTERFACE TRIASDB
	[
		object,
		uuid(25FEBCA5-3DC3-11D1-96C0-00A024D6F582),
		helpstring("ITRiASPropertySupport Interface"),
		pointer_default(unique),
		restricted, 
		hidden
	]
	interface ITRiASPropertySupport : IUnknown
	{
		[helpstring("Erzeugt ein neues spezifisches Eigenschaftsobjekt.")] HRESULT CreateProperty([in] BSTR Name, [out, retval] ITRiASProperty **Property);
		[helpstring("Füllt den Enumerator mit allen spezifischen Eigenschaftsobjekten.")] HRESULT FillWithProperties([in, out] IUnknown **Props);
		[helpstring("Löscht ein spezifisches Eigenschaftsobjekt.")] HRESULT RemoveProperty([in] BSTR Name);
	}

// @doc INTERFACE TRIASDB
	[
		object,
		uuid(32E4EC75-3D14-11D2-9EB6-006008447800),
		helpstring("ITRiASPropertyMapHandler Interface"),
		pointer_default(unique),
		restricted, 
		hidden
	]
	interface ITRiASPropertyMapHandler : IUnknown
	{
		[helpstring("Modifiziert einen Eintrag in der PropertySupportMap des Objektes.")] HRESULT ChangeMapEntry ([in] BSTR EntryKey, [in] INT_PTR NewData, [in] DWORD NewFlags, [in] VARIANT InitData);
		[helpstring("Fügt einen Eintrag zu der PropertySupportMap des Objektes hinzu.")] HRESULT AddMapEntry ([in] BSTR EntryKey, [in] INT_PTR NewData, [in] DWORD NewFlags, [in] VARIANT InitData);
	};

// @doc INTERFACE TRIASDB
	[
		object,
		uuid(25FEBCA6-3DC3-11D1-96C0-00A024D6F582),
		helpstring("ITRiASPropertyCallback Interface"),
		pointer_default(unique),
		restricted, 
		hidden
	]
	interface ITRiASPropertyCallback : IUnknown
	{
		[helpstring("Setzt den Wert eines spezifischen Eigenschaftsobjektes.")] HRESULT PutValue([in] BSTR Name, [in] VARIANT newVal);
		[helpstring("Liefert den Wert eines spezifischen Eigenschaftsobjektes.")] HRESULT GetValue([in] BSTR Name, [out] VARIANT *pVal);
		[helpstring("Setzt den Typ eines spezifischen Eigenschaftsobjektes.")] HRESULT PutType([in] BSTR Name, [in] PROPERTY_TYPE newVal);
		[helpstring("Liefert den Typ eines spezifischen Eigenschaftsobjektes.")] HRESULT GetType([in] BSTR Name, [out] PROPERTY_TYPE *pVal);
		[helpstring("Setzt den Wert und den Typ eines spezifischen Eigenschaftsobjektes.")] HRESULT PutValueAndType([in] BSTR Name, [in] VARIANT Val, [in] PROPERTY_TYPE Type);
		[helpstring("Liefert den Wert und den Typ eines spezifischen Eigenschaftsobjektes.")] HRESULT GetValueAndType([in] BSTR Name, [out] VARIANT *pVal, [out] PROPERTY_TYPE *pType);
		[helpstring("Liest den Wert dieser spezifischen Eigenschaft neu ein.")] HRESULT Refresh([in] BSTR Name);
	};

///////////////////////////////////////////////////////////////////////////////
// @doc INTERFACE HELPER
// @interface ITRiASDataServerRegEntries | Das Interface <i ITRiASDataServerRegEntries>
// dient der Verwaltung der RegistryEinträge für alle registrierten TRiASDB-DataServer 
// Nähere Informationen über die in der Registry gespeicherten Informationen sind 
// unter <l Registryeinträge für einen TRiASDB-DataServer> zu finden.
// @supby <o TRiASDataServerRegEntries>
// @xref <o TRiASDataServerRegEntries>, <i ITRiASDataServerRegEntry>
// @group Methoden und Eigenschaften von <i ITRiASDataServerRegEntries> 
// @index | IREGENTRIES
// @doc IREGENTRIES
	[
		object,
		uuid(F4B3F945-810E-11D1-9776-00A024D6F582),
		dual,
		helpstring("ITRiASDataServerRegEntries Interface"),
		pointer_default(unique)
	]
	interface ITRiASDataServerRegEntries : IDispatch
	{
	// @property LONG | ITRiASDataServerRegEntries | Count | Liefert die Anzahl der 
	// registrierten TRiASDB-DataServer (readonly)
	// @comm Die Eigenschaft <op .Count> kann nicht gesetzt werden.
	// @supby <o TRiASDataServerRegEntries>
	// @xref <i ITRiASDataServerRegEntries>
		[propget, id(1), helpstring("Liefert die Anzahl der registrierten TRiASDB-DataServer.")] HRESULT Count([out, retval] LONG *pVal);

	// @method HRESULT | ITRiASDataServerRegEntries | Item | Liefert die Informationen zu 
	// einem TRiASDB-DataServer über seinen Kurzbezeichner oder seinen Index.
	// @parm VARIANT | Index | Dieser Parameter muß entweder die Zählnummer des zu liefernden
	// Elementes der Collection enthalten (0 <lt> Index <lt>= Count) oder dessen Kurzbezeichner als
	// Zeichenkette.
	// @parm <i ITRiASDataServerRegEntry> ** | Entry | Der Zeiger auf eine Variable vom Typ
	// <i ITRiASDataServerRegEntry> *, die nach erfolgreicher Abarbeitung der Methode die 
	// gesuchte Information enthält.
	// @rvalue <cv S_OK> | Die Methode <om .Item> wurde erfolgreich abgearbeitet und die Informationen zu dem
	// gesuchten DataServer wurde erfolgreich zur Verfügung gestellt
	// @rvalue <cv TRIASDB_E_UNKNOWN_DATASERVER> | Der angegebene DataServer wurde nicht gefunden 
	// (es sind keine Informationen zu diesem DataServer registriert)
	// @supby <o TRiASDataServerRegEntries>
	// @xref <i ITRiASDataServerRegEntries>
		[id(DISPID_DEFAULT), helpstring("Liefert einen TRiASDB-DataServer über seinen Kurzbezeichner oder seinen Index.")] HRESULT Item([in] VARIANT Index, [out, retval] ITRiASDataServerRegEntry **Entry);

	// @method HRESULT | ITRiASDataServerRegEntries | _NewEnum | Liefert einen neuen
	// Enumerator, der alle Objekte enthält, die in der vorliegenden Sammlung zusammengefaßt sind.
	// @parm IUnknown ** | Enum | Zeiger auf eine Variable vom Typ IUnknown *, welche nach erfolgreicher 
	// Abarbeitung der Methode <om ._NewEnum> den Ergebnis-Enumerator enthält.
	// @comm Der gelieferte Enumerator ist vom Typ <i IEnumVARIANT>. Daher sollte der Rückgabewert
	// explizit durch einen QueryInterface-Aufruf konvertiert werden.
	// @ex Das folgende Beispiel verdeutlicht die empfohlene Vorgehensweise |
	// IEnumVARIANT *pIEnum = NULL;
	// IUnknown *pIUnk = NULL;
	// HRESULT hr = pIEntries -> _NewEnum (&pIUnk);
	//
	//	if (SUCCEEDED(hr)) {
	//		hr = pIUnk -> QueryInterface(IID_IEnumVARIANT, (LPVOID *)&pIEnum);
	//		pIUnk -> Release();
	//	}
	//	...
	// @comm Normalerweise wird diese Funktion nicht direkt gerufen, Sie ist lediglich
	// für die Nutzung in Automation-Werkzeugen wie z.B. VisualBasic vorgesehen, wo sie
	// für Programmkonstrukte wie 'For Each ...' notwendig ist.
	// @supby <o TRiASDataServerRegEntries>
	// @xref <i ITRiASDataServerRegEntries>
		[id(DISPID_NEWENUM), hidden] HRESULT _NewEnum([out, retval] IUnknown **Enum);

	// @method HRESULT | ITRiASDataServerRegEntries | _Clone | Die <om ._Clone>- Methode
	// liefert eine neue Sammlung von Objekten, die identisch zur vorliegenden ist.
	// @parm <i ITRiASDataServerRegEntries> ** | Enum | Zeiger auf eine Variable vom Typ 
	// ITRiASDataServerRegEntries *, welche nach erfolgreicher Abarbeitung der Methode <om ._Clone> 
	// die Kopie dieser Objektsammlung enthält.
	// @comm Bei Änderungen an der ursprünglichen Objektsammlung wird die neu erzeugte Kopie
	// nicht modifiziert.
	// @supby <o TRiASDataServerRegEntries>
	// @xref <i ITRiASDataServerRegEntries>
		[id(100), hidden, helpstring("Erzeugt eine neue Sammlung von TRiASDB-ServerEntries, die der vorliegenden identisch ist.")] HRESULT _Clone([out, retval] ITRiASDataServerRegEntries **Entries);

	// @method HRESULT | ITRiASDataServerRegEntries | Refresh | Liest alle existierenden 
	// TRiASDB-DataServerEntries neu ein
	// @comm Vorsicht! Diese Methode sollte nur dann gerufen werden, wenn es notwendig ist, da
	// sie zeitaufwendig sein kann.
	// @supby <o TRiASDataServerRegEntries>
	// @xref <i ITRiASDataServerRegEntries>
		[id(101), helpstring("Liest alle existierenden TRiASDB-DataServerEntries neu ein (Vorsicht! Zeitaufwendig!).")] HRESULT Refresh();

	// @method HRESULT | ITRiASDataServerRegEntries | FindFromServerProgID | Liefert einen 
	// TRiASDB-DataServer über den ProgID des zugehörigen Targetobjektes
	// @parm BSTR | ServerProgID | Der ProgID des COM-Objektes, welches das zugehörigen 
	// Targetdokument (TRiASDB-DataServer) repräsentiert.
	// @parm <i ITRiASDataServerRegEntry> ** | Entry | Der Zeiger auf eine Variable vom Typ
	// <i ITRiASDataServerRegEntry> *, die nach erfolgreicher Abarbeitung der 
	// Methode <om .FindFromServerProgID> die gesuchte Information enthält.
	// @rvalue <cv S_OK> | Die Methode <om .FindFromServerProgID> wurde erfolgreich abgearbeitet 
	// und die Informationen zu dem gesuchten DataServer wurden erfolgreich zur Verfügung gestellt
	// @rvalue <cv TRIASDB_E_UNKNOWN_DATASERVER> | Der angegebene DataServer wurde nicht gefunden 
	// (es sind keine Informationen zu diesem DataServer registriert)
	// @supby <o TRiASDataServerRegEntries>
	// @xref <l Registryeinträge für einen TRiASDB-DataServer>, <i ITRiASDataServerRegEntries>
		[id(102), helpstring("Liefert einen TRiASDB-DataServer über den ProgID des zugehörigen Targetobjektes.")] HRESULT FindFromServerProgID([in] BSTR ProgID, [out, retval] ITRiASDataServerRegEntry **Entry);
	};

///////////////////////////////////////////////////////////////////////////////
// @doc INTERFACE HELPER
// @interface ITRiASDataServerRegEntry | Das Interface <i ITRiASDataServerRegEntry>
// dient dem Zugriff auf diverse statische Informationen über einen TRiASDB-DataServer,
// die in der Registry gespeichert sind. Nähere Informationen über die in der Registry
// gespeicherten Informationen sind unter <l Registryeinträge für einen TRiASDB-DataServer>
// zu finden.
// @supby <o TRiASDataServerRegEntry>
// @xref <o TRiASDataServerRegEntry>
// @group Methoden und Eigenschaften von <i ITRiASDataServerRegEntry> 
// @index | IREGENTRY
// @doc IREGENTRY
	[
		object,
		uuid(F4B3F947-810E-11D1-9776-00A024D6F582),
		dual,
		helpstring("ITRiASDataServerRegEntry Interface"),
		pointer_default(unique)
	]
	interface ITRiASDataServerRegEntry : IDispatch
	{
	// @property BSTR | ITRiASDataServerRegEntry | Version | Liefert die Version dieses 
	// TRiASDB-DataServers (readonly)
	// @comm Die Eigenschaft <op .Version> kann nicht gesetzt werden.
	// @supby <o TRiASDataServerRegEntry>
	// @xref <i ITRiASDataServerRegEntry>
		[propget, id(1), helpstring("Liefert die Version dieses TRiASDB-DataServers.")] HRESULT Version([out, retval] BSTR *pVal);

	// @property BSTR | ITRiASDataServerRegEntry | DataServerClass | Liefert den ProgID des 
	// COM-Objektes des zugehörigen TRiASDB-DataServers (readonly)
	// @comm Die Eigenschaft <op .DataServerClass> kann nicht gesetzt werden.
	// @supby <o TRiASDataServerRegEntry>
	// @xref <i ITRiASDataServerRegEntry>
		[propget, id(2), helpstring("Liefert den ProgID des COM-Objektes des zugehörigen TRiASDB-DataServers.")] HRESULT DataServerClass([out, retval] BSTR *pVal);

	// @property BSTR | ITRiASDataServerRegEntry | DatabaseClass | Liefert den ProgID des 
	// COM-Objektes der zugehörigen TRiASDatabase (readonly)
	// @comm Die Eigenschaft <op .DatabaseClass> kann nicht gesetzt werden.
	// @supby <o TRiASDataServerRegEntry>
	// @xref <i ITRiASDataServerRegEntry>
		[propget, id(3), helpstring("Liefert den ProgID des COM-Objektes der zugehörigen TRiASDatabase.")] HRESULT DatabaseClass([out, retval] BSTR *pVal);

	// @property BSTR | ITRiASDataServerRegEntry | DefaultExtension | Liefert Standard-Dateierweiterung 
	// für die Datenbank bei 'NameIsFile' (readonly)
	// @comm Die Eigenschaft <op .DefaultExtension> kann nicht gesetzt werden.
	// @supby <o TRiASDataServerRegEntry>
	// @xref <i ITRiASDataServerRegEntry>
		[propget, id(4), helpstring("Liefert Standard-Dateierweiterung für Datenbank bei 'NameIsFile'.")] HRESULT DefaultExtension([out, retval] BSTR *pVal);

	// @property BSTR | ITRiASDataServerRegEntry | FilterString | Liefert FilterString für Datei 
	// Öffnen/Datei Speichern Dialoge (readonly)
	// @comm Die Eigenschaft <op .FilterString> kann nicht gesetzt werden.
	// @supby <o TRiASDataServerRegEntry>
	// @xref <i ITRiASDataServerRegEntry>
		[propget, id(5), helpstring("Liefert FilterString für Datei Öffnen/Datei Speichern Dialoge.")] HRESULT FilterString([out, retval] BSTR *pVal);

	// @property BSTR | ITRiASDataServerRegEntry | ShortName | Liefert die Kurzbezeichnung 
	// dieses TRiASDB-DataServers (readonly)
	// @comm Die Eigenschaft <op .ShortName> kann nicht gesetzt werden.
	// @supby <o TRiASDataServerRegEntry>
	// @xref <i ITRiASDataServerRegEntry>
		[propget, id(DISPID_DEFAULT), helpstring("Liefert die Kurzbezeichnung dieses TRiASDB-DataServers.")] HRESULT ShortName([out, retval] BSTR *pVal);

	// @property BSTR | ITRiASDataServerRegEntry | LongName | Liefert die Langbezeichnung 
	// dieses TRiASDB-DataServers (readonly)
	// @comm Die Eigenschaft <op .LongName> kann nicht gesetzt werden.
	// @supby <o TRiASDataServerRegEntry>
	// @xref <i ITRiASDataServerRegEntry>
		[propget, id(7), helpstring("Liefert die Langbezeichnung dieses TRiASDB-DataServers.")] HRESULT LongName([out, retval] BSTR *pVal);

	// @property BSTR | ITRiASDataServerRegEntry | FileDescription | Liefert die 
	// Dateibeschreibung für diesen TRiASDB-DataServer (readonly)
	// @comm Die Eigenschaft <op .FileDescription> kann nicht gesetzt werden.
	// @supby <o TRiASDataServerRegEntry>
	// @xref <i ITRiASDataServerRegEntry>
		[propget, id(8), helpstring("Liefert die Dateibeschreibung für diesen TRiASDB-DataServer.")] HRESULT FileDescription([out, retval] BSTR *pVal);

	// @property BSTR | ITRiASDataServerRegEntry | IsReadWrite | Liefert, ob der TRiASDB-DatenServer 
	// Daten in die Datenbank schreiben kann (readonly)
	// @comm Die Eigenschaft <op .IsReadWrite> kann nicht gesetzt werden.
	// @supby <o TRiASDataServerRegEntry>
	// @xref <i ITRiASDataServerRegEntry>
		[propget, id(9), helpstring("Liefert, ob der TRiASDB-DatenServer Daten in die Datenbank schreiben kann.")] HRESULT IsReadWrite([out, retval] VARIANT_BOOL *pVal);

	// @property VARIANT_BOOL | ITRiASDataServerRegEntry | NameIsFile | Liefert, ob der 
	// Datenbankname eine Datei beschreibt (readonly)
	// @comm Die Eigenschaft <op .NameIsFile> kann nicht gesetzt werden.
	// @supby <o TRiASDataServerRegEntry>
	// @xref <i ITRiASDataServerRegEntry>
		[propget, id(10), helpstring("Liefert, ob der Datenbankname eine Datei beschreibt.")] HRESULT NameIsFile([out, retval] VARIANT_BOOL *pVal);

	// @property VARIANT_BOOL | ITRiASDataServerRegEntry | NameIsDirectory | Liefert, ob der 
	// Datenbankname ein Verzeichnis beschreibt (readonly)
	// @comm Die Eigenschaft <op .NameIsDirectory> kann nicht gesetzt werden.
	// @supby <o TRiASDataServerRegEntry>
	// @xref <i ITRiASDataServerRegEntry>
		[propget, id(11), helpstring("Liefert, ob der Datenbankname ein Verzeichnis beschreibt.")] HRESULT NameIsDirectory([out, retval] VARIANT_BOOL *pVal);

	// @property VARIANT_BOOL | ITRiASDataServerRegEntry | SourceStringUsed | Liefert, ob beim Aufruf der 
	// OpenDatabase-Methode der Parameter 'SourceString' ausgewertet wird (readonly)
	// @comm Die Eigenschaft <op .SourceStringUsed> kann nicht gesetzt werden.
	// @supby <o TRiASDataServerRegEntry>
	// @xref <i ITRiASDataServerRegEntry>
		[propget, id(12), helpstring("Liefert, ob beim Aufruf der OpenDatabase-Methode der Parameter 'SourceString' ausgewertet wird.")] HRESULT SourceStringUsed([out, retval] VARIANT_BOOL *pVal);

	// @property String | ITRiASDataServerRegEntry | SourceStringDescription | Beschreibt den 
	// Parameter 'SourceString' der OpenDatabase-Methode (readonly)
	// @supby <o TRiASDataServerRegEntry>
	// @xref <i ITRiASDataServerRegEntry>
		[propget, id(13), helpstring("Beschreibt den Parameter 'SourceString' der OpenDatabase-Methode.")] HRESULT SourceStringDescription([out, retval] BSTR *pVal);

	// @property String | ITRiASDataServerRegEntry | TempName | Wenn temporäre Datenquellen unterstützt 
	// werden, dann liefert diese Eigenschaft den zu verwendenden temporären Basisnamen
	// @supby <o TRiASDataServerRegEntry>
	// @xref <i ITRiASDataServerRegEntry>
		[propget, id(14), helpstring("Wenn temporäre Datenquellen unterstützt werden, dann liefert diese Eigenschaft den zu verwendenden temporären Basisnamen.")] HRESULT TempName([out, retval] BSTR *pVal);

	// @property String | ITRiASDataServerRegEntry | LastDirUsed | Liefert bzw. setzt das 
	// zuletzt benutzte Dateiverzeichnis
	// @supby <o TRiASDataServerRegEntry>
	// @xref <i ITRiASDataServerRegEntry>
		[propget, id(15), helpstring("Liefert das zuletzt benutzte Dateiverzeichnis.")] HRESULT LastDirUsed([out, retval] BSTR *pVal);
		[propput, id(15), helpstring("Setzt das zuletzt benutzte Dateiverzeichnis.")] HRESULT LastDirUsed([in] BSTR newVal);

	// @property LONG | ITRiASDataServerRegEntry | ToolboxBitmap32 | Liefert die Nummer des im 
	// Nutzerinterface für diesen TRiASDB-DataServer zu verwendenden Piktogramms (readonly)
	// @supby <o TRiASDataServerRegEntry>
	// @xref <i ITRiASDataServerRegEntry>
		[propget, id(16), helpstring("Liefert die Nummer des im Nutzerinterface für diesen TRiASDB-DataServer zu verwendenden Piktogramms.")] HRESULT ToolboxBitmap32([out, retval] LONG *pVal);

	// @property VARIANT_BOOL | ITRiASDataServerRegEntry | MultipleFiles | Liefert, ob mehrere Dateien als
	// eine Datenbank geöffnet werden können (readonly).
	// @comm Die Eigenschaft <op .MultipleFiles> kann nicht gesetzt werden.
	// @comm Diese Eigenschaft ist nur dann sinnvol auswertbar, wenn <op .NameIsFile> den Wert <cv True> 
	// liefert.
	// @supby <o TRiASDataServerRegEntry>
	// @xref <i ITRiASDataServerRegEntry>
		[propget, id(17), helpstring("Liefert, ob mehrere Dateien als eine Datenbank geöffnet werden können.")] HRESULT MultipleFiles([out, retval] VARIANT_BOOL *pVal);

	// @property String | ITRiASDataServerRegEntry | OpenWizPages | Liefert den ProgID eines 
	// COM-Objektes, der zusätzliche Pages für den Open-Dialog zur Verfügung stellt.
	// @comm Die Eigenschaft <op .OpenWizPages> kann nicht gesetzt werden.
	// @supby <o TRiASDataServerRegEntry>
	// @xref <i ITRiASDataServerRegEntry>
		[propget, id(18), helpstring("Liefert den ProgID eines COM-Objektes, der zusätzliche Pages für den Open-Dialog zur Verfügung stellt.")] HRESULT OpenWizPages([out, retval] BSTR *pVal);

	// @property VARIANT_BOOL | ITRiASDataServerRegEntry | NameIsSubStorage | Liefert, ob der 
	// Datenbankname ein Storage im Projekt beschreibt (readonly)
	// @comm Die Eigenschaft <op .NameIsSubStorage> kann nicht gesetzt werden.
	// @supby <o TRiASDataServerRegEntry>
	// @xref <i ITRiASDataServerRegEntry>
		[propget, id(19), helpstring("Liefert, ob der Datenbankname ein Storage im Projekt beschreibt.")] HRESULT NameIsSubStorage([out, retval] VARIANT_BOOL *pVal);

	// @property long | ITRiASDataServerRegEntry | RestrictInstances | Liefert die Anzahl Datenquellen 
	// dieses Types, die gleichzeitig in einem Projekt geöffnet werden können.
	// @comm Die Eigenschaft <op .RestrictInstances> kann nicht gesetzt werden.
	// @comm Diese Routine liefert '0', wenn keine derartige Limitierung existiert.
	// @supby <o TRiASDataServerRegEntry>
	// @xref <i ITRiASDataServerRegEntry>
		[propget, id(20), helpstring("Liefert Anzahl der gleichzeitig zu öffnenden Datenquellen.")] HRESULT RestrictInstances([out, retval] long *pVal);

	// @property VARIANT_BOOL | ITRiASDataServerRegEntry | NeedsCoordSystemExisting | Liefert, ob ein 
	// Koordinatensystem für eine existierende Datenquelle auswählbar sein muß.
	// @comm Die Eigenschaft <op .NeedsCoordSystemExisting> kann nicht gesetzt werden.
	// @supby <o TRiASDataServerRegEntry>
	// @xref <i ITRiASDataServerRegEntry>
		[propget, id(21), helpstring("Liefert, ob ein Koordinatensystem für eine existierende Datenquelle auswählbar sein muß.")] HRESULT NeedsCoordSystemExisting([out, retval] VARIANT_BOOL *pVal);

	// @property VARIANT_BOOL | ITRiASDataServerRegEntry | NeedsCoordSystemNew | Liefert, ob ein 
	// Koordinatensystem für eine neue Datenquelle auswählbar sein muß.
	// @comm Die Eigenschaft <op .NeedsCoordSystemNew> kann nicht gesetzt werden.
	// @supby <o TRiASDataServerRegEntry>
	// @xref <i ITRiASDataServerRegEntry>
		[propget, id(22), helpstring("Liefert, ob ein Koordinatensystem für eine existierende Datenquelle auswählbar sein muß.")] HRESULT NeedsCoordSystemNew([out, retval] VARIANT_BOOL *pVal);

	// @property String | ITRiASDataServerRegEntry | ReconnectDialog | Liefert den ProgID eines 
	// COM-Objektes, der ein Nutzerinterface für das Wiederauffinden einer Verbindung zur Verfügung stellt.
	// @comm Die Eigenschaft <op .ReconnectDialog> kann nicht gesetzt werden.
	// @comm Diese Eigenschaft ist nur dann sinnvol auswertbar, wenn <op .NameIsFile>, 
	// <op .NameIsSubStorage> und <op .NameIsDirectory> den Wert <cv False> liefern.
	// @supby <o TRiASDataServerRegEntry>
	// @xref <i ITRiASDataServerRegEntry>
		[propget, id(23), helpstring("Liefert den ProgID eines COM-Objektes, der ein Nutzerinterface für das Wiederauffinden einer Verbindung zur Verfügung stellt.")] HRESULT ReconnectDialog([out, retval] BSTR *pVal);

	// @property String | ITRiASDataServerRegEntry | CreateDatabase | Liefert den ProgID eines 
	// COM-Objektes, das eine neue Datenbank eines bestimmten Types erzeugen kann.
	// @comm Die Eigenschaft <op .CreateDatabase> kann nicht gesetzt werden.
	// @supby <o TRiASDataServerRegEntry>
	// @xref <i ITRiASDataServerRegEntry>
		[propget, id(24), helpstring("Liefert den ProgID eines COM-Objektes, das eine neue Datenbank eines bestimmten Types erzeugen kann.")] HRESULT CreateDatabase([out, retval] BSTR *pVal);
	};

///////////////////////////////////////////////////////////////////////////////
// @doc INTERFACE HELPER
// @interface ITRiASOpenWizardPropExt | Das Interface <i ITRiASOpenWizardPropExt>
// dient der Initialisierung eines Objektes, welches zusätzliche Seiten in den Opendialog
// einhängen will.
// @group Methoden und Eigenschaften von <i ITRiASOpenWizardPropExt> 
// @index | ITRIASOPENWIZARDPROPEXT
// @doc ITRIASOPENWIZARDPROPEXT
	[
		object,
		uuid(4DD970F4-A20F-11D1-BA29-080036D63803),
		dual,
		helpstring("TRiASOpenWizardPropExt Interface"),
		pointer_default(unique)
	]
	interface ITRiASOpenWizardPropExt : IUnknown
	{
	// @method HRESULT | ITRiASOpenWizardPropExt | InitForOpenDialog | Die <om .InitForOpenDialog>-
	// Methode wird gerufen, nachdem das Objekt, welches eine zusätzliche Page für den Opendialog 
	// registriert hat (s. <l Registryeinträge für einen TRiASDB-DataServer>) instantiiert wurde.
	// Diese Methode dient der internen Initialisierung des Objektes.
	// @parm BSTR | ProgID | Der Parameter <p ProgID> enthält den ProgID des Targetobjektes für
	// welches ein <o TRiASDatabase>- Objekt erstellt werden soll (siehe <om ITRiASConnection.Connect>.
	// @parm BSTR | Caption | Der Parameter <p Caption> enthält eine Zeichenkette, die das Objekt
	// im Fensterkopf aller einzuhängenden Dialogseiten anzeigen soll.
	// @parm VARIANT_BOOL | fCreate | Der Parameter <p fCreate> gibt vor, ob der Dialog, in den 
	// die Dialogseiten eingehängt werden sollen, dazu dient, eine Datenquelle neu zu erzeugen
	// (in diesem Fall enthält <p fCreate> den Wert <cv True>), oder eine existierenden Datenquelle
	// zu öffnen (in diesem Fall enthält <p fCreate> den Wert <cv False>).
	// @parm <i IComposeStringPairs> * | Pairs | Der Parameter <p Pairs> enthält einen Zeiger
	// auf ein <i IComposeStringPairs>- Interface, über welches der/die Dialog(e) die eingegebenen
	// Informationen als Key/Value Paare speichern kann. Diese Informationen bekommt das zuständige 
	// <o TRiASDatabase>- Objekt im Connect-String beim Aufruf der Methode 
	// <om ITRiASDatabase.OpenDatabase> in der Form ";Key=Value" übergeben und können von dort 
	// mit Hilfe eines <o ParseStringPairs>- Objektes wieder extrahiert werden.
	// @devnote Unter Umständen ist es notwendig, daß Objekte, die während der Konfigurationsphase
	// (während der Dialog angezeigt ist) instantiiert wurden auch während der Phase des 
	// Erzeugens/Öffnens der entsprechenden Datenquelle noch verfügbar sein müssen.
	// <nl>Derartiges läßt sich relativ einfach regeln, da das Dialogobjekt von <tr> während dem
	// gesamten Prozeß (Dialog und Erzeugen/Öffnen der Datenquelle) festgehalten wird. Wenn das 
	// Dialogobjekt also als Singleton-Objekt konzipiert wird, was keine Einschränkung darstellt, 
	// da sowieso immer nur ein Objekt dieses Types gleichzeitig existieren muß, können alle weiteren 
	// Objekte, die ebenfalls 'leben' sollen, durch das Dialogobjekt gehalten werden. Das Dialogobjekt 
	// ist dann als Singleton-Objekt jederzeit über seinen CLSID erreichbar.
	// @supby <o OpenWizPropExt>
	// @xref <i ITRiASOpenWizardPropExt>, <l Registryeinträge für einen TRiASDB-DataServer>,
	// <om ITRiASConnection.Connect>, <om ITRiASDatabase.OpenDatabase>
		[helpstring("Initialisierung für die Arbeit mit dem Opendialog.")] HRESULT InitForOpenDialog ([in] BSTR ProgID, [in] BSTR Caption, [in] VARIANT_BOOL fCreate, [in] IComposeStringPairs *Pairs);
	};

///////////////////////////////////////////////////////////////////////////////
// @doc INTERFACE HELPER
// @interface ITRiASObjectHandleMap | Das Interface <i ITRiASObjectHandleMap>
// dient der Zuordnung eindeutiger Zugriffsnummern zu diversen Objekttypen innerhalb der
// TRiASDB-Schnittstelle.
// @group Methoden und Eigenschaften von <i ITRiASObjectHandleMap> 
// @index | ITRIASOBJECTHANDLEMAP
// @doc ITRIASOBJECTHANDLEMAP
	[
		object,
		uuid(D4C24AD5-A5EA-11D1-BA31-080036D63803),
		dual,
		helpstring("ITRiASObjectHandleMap Interface"),
		pointer_default(unique)
	]
	interface ITRiASObjectHandleMap : IDispatch
	{
	cpp_quote("#if !defined(_OBJECTMAPMODE_DEFINED)")
	cpp_quote("#define _OBJECTMAPMODE_DEFINED")
	// @doc OBJECTMAPMODE
	// @enum OBJECTMAPMODE | Der Mode, in dem ein Objekt zur Objekttabelle von TRiASDB hinzugefügt
	// werden soll.
	// @xref <i ITRiASObjectHandleMap>, <om ITRiASObjectHandleMap.GetObjectHandle>
		typedef [public, v1_enum, helpstring("Mode zu GetObjetHandle.")]
		enum _tagOBJECTMAPMODE {
			[helpstring("Liefern der Zugriffsnummer des übergebenen Objektes.")]
				OBJECTMAPMODE_GetObjectHandle = 0,		// @emem Es soll lediglich die Zugriffsnummer 
				// des übergebenen Objektes geliefert werden. Wenn das Objekt nicht registriert ist
				// (durch einen vorhergehenden Aufruf der <om .GetObjectHandle> mit dem Parameter 
				// <p Mode> gleich <e .OBJECTMAPMODE_CreateObjectHandle>), dann schlägt 
				// die <om .GetObjectHandle>- Methode fehl
			[helpstring("Erzeugen und liefern der Zugriffsnummer des übergebenen Objektes.")]
				OBJECTMAPMODE_CreateObjectHandle = 1,	// @emem Es soll eine neue Zugriffsnummer für 
				// das übergebene Objekt erzeugt und geliefert werden. Wenn das Objekt bereits 
				// registriert ist, dann liefert die <om .GetObjectHandle>- Methode die bereits
				// vergebene Zugriffsnummer des Objektes und den Rückkehrwert <cv S_FALSE>.
			[helpstring("Liefern des Objektes zur übergebenen Zugriffsnummer.")]
				OBJECTMAPMODE_GetObjectFromHandle = 2,	// @emem Es soll ein unter dem übergebenen
				// Handle registriertes Objekt geliefert werden.
			[helpstring("Liefern des Objektes zur übergebenen lokalen Zugriffsnummer.")]
				OBJECTMAPMODE_GetObjectFromNativeHandle = 3,	// @emem Es soll ein unter dem übergebenen
				// Handle registriertes Objekt geliefert werden. der Unterschied
				// zu <e .OBJECTMAPMODE_GetObjectFromHandle> besteht darin, daß zuerst versucht wird
				// das übergebene Handle über die interne Datenbank-lokale Liste aufzulösen (d.h. das ü
				// übergebene Handle wird im Kontext der zugehörigen Datenquelle ausgewertet.
			[helpstring("Möglichst voreingestelltes Handle verwenden.")]
				OBJECTMAPMODE_UsePredefinedHandle = 0x80,	// @emem Es soll möglichst die
				// Zugriffsnummer verwendet werden, die im Parameter <p Handle> übergeben wird.
				// Wenn es nicht möglich ist diese Zugriffsnummer zu verwenden, weil diese bereits 
				// vergeben ist, dann wird eine neue Zugriffsnummer erzeugt und als Rückgabewert
				// <cv S_FALSE> geliefert.
			[helpstring("Die Registrierung bewirkt kein Festhalten des Objektes.")]
				OBJECTMAPMODE_WeakRegistration = 0,		// @emem Die Registrierung
				// des Objektes bewirkt kein Festhalten des Objektes. Dieser Wert wird
				// lediglich ausgewertet, wenn gleichzeitig der Wert <e .OBJECTMAPMODE_CreateObjectHandle>
				// gegeben ist.
			[helpstring("Die Registrierung bewirkt ein Festhalten des Objektes.")]
				OBJECTMAPMODE_RegistrationKeepsAlive = 0x100,	// @emem Die Registrierung 
				// bewirkt ein Festhalten des Objektes (AddRef). Dieser Wert wird
				// lediglich ausgewertet, wenn gleichzeitig der Wert <e .OBJECTMAPMODE_CreateObjectHandle>
				// gegeben ist.
			[helpstring("Der übergebene Name identifiziert das Objekt eindeutig.")]
				OBJECTMAPMODE_NameIdentifiesObject = 0,	// @emem Der übergebene Name identifiziert
				// das Objekt eindeutig und soll gespeichert werden, um das Objekt wieder
				// auffinden zu können.
			[helpstring("Der übergebene Name identifiziert das Objekt nicht eindeutig.")]
				OBJECTMAPMODE_NameDoesNotIdentifyObject = 0x200,	// @emem Der übergebene Name identifiziert
				// das Objekt <b nicht> eindeutig und wird nicht mit gespeichert. 
			[helpstring("Zugehöriges Datenbankhandle speichern.")]
				OBJECTMAPMODE_RegisterNativeHandle = 0,	// @emem Das zugehörige Datenbank-Handle
				// wird für spätere Identifikationszwecke mit gespeichert, so daß das registrierte
				// Objekt in dieser Map auch über dieses wiederauffindbar ist.
			[helpstring("Zugehöriges Datenbankhandle nicht speichern.")]
				OBJECTMAPMODE_DoNotRegisterNativeHandle = 0x400,	// @emem Das zugehörige Datenbank-Handle
				// wird für spätere Identifikationszwecke <b nicht> mit gespeichert, so daß das registrierte
				// Objekt in dieser Map <b nicht> über dieses wiederauffindbar ist.
			[helpstring("Entfernen lediglich einer Referenz auf dieses Objekt.")]
				OBJECTMAPMODE_RemoveThisReference = 0,	// @emem Dieser Wert 
				// wird nur im Zusammenhang mit der Funktion <om .RemoveObject> verwendet,
				// wenn lediglich eine Referenz auf dieses Objekt freigegeben werden soll.
				// Das Objekt wird nur dann aus der Map entfernt, wenn die entfernte
				// Referenz die letzte war.
			[helpstring("Entfernen aller existierenden Refenzen auf dieses Objekt.")]
				OBJECTMAPMODE_RemoveAllReferences = 2,	// @emem Dieser Wert 
				// wird nur im Zusammenhang mit der Funktion <om .RemoveObject> verwendet,
				// wenn alle Referenzen auf dieses Objekt freigegeben werden sollen.
			[helpstring("Entfernen aller existierenden Objekte aus der Map.")]
				OBJECTMAPMODE_RemoveAllObjects = 4,	// @emem Dieser Wert 
				// wird nur im Zusammenhang mit der Funktion <om .RemoveObject> verwendet,
				// wenn alle Objekte freigegeben werden sollen.
		} OBJECTMAPMODE;
	cpp_quote("#endif // _OBJECTMAPMODE_DEFINED")

	// @doc ITRIASOBJECTHANDLEMAP
	// @method HRESULT | ITRiASObjectHandleMap | GetObjectHandle | Die <om .GetObjectHandle> -Methode liefert
	// die eindeutige Zugriffsnummer für das übergebene Objekt.
	// @parm VARIANT | Name | Der Parameter <p Name> muß eine dieses Objekt eindeutig identifizierende 
	// Zeichenkette oder Zahl enthalten. Um die Eindeutigkeit dieser Zeichenkette zu gewährleisten, sollte
	// diese folgendes Format besitzen: "{guid}:realname" o.ä.. 
	// @parm IUnknown * | Object | Der Parameter <p Object> enthält den Zeiger auf ein <i IUnknown>- 
	// Interface des Objektes, welches registriert werden soll.
	// @parm <t OBJECTMAPMODE> | Mode | Der Parameter <p Mode> gibt den Mode vor in dem ein Objekt registriert
	// werden soll.
	// @parm LONG * | Handle | Nach erfolgreichem Abarbeiten der <om .GetObjectHandle>- Methode enthält
	// der Parameter <p Handle> die eindeutige Zugriffsnummer, die dem übergebenen Objekt zugeordnet 
	// wurde. Wenn im Parameter <p Mode> unter anderem <e OBJECTMAPMODE.OBJECTMAPMODE_UsePredefinedHandle>
	// gegeben ist, dann wird versucht, den im Parameter <p Handle> übergebenen Wert als Zugriffsnummer
	// zu verwenden.
	// @supby <o TRiASObjectHandleMap>
	// @xref <i ITRiASObjectHandleMap>, <t OBJECTMAPMODE>, <e OBJECTMAPMODE.OBJECTMAPMODE_UsePredefinedHandle>
		[id(100), helpstring("Liefert die eindeutige Zugriffsnummer für das übergebene Objekt.")] HRESULT GetObjectHandle([in] VARIANT NameOrHandle, [in] IUnknown *Object, [in] OBJECTMAPMODE Mode, [in, out] INT_PTR *Handle);

	// @method HRESULT | ITRiASObjectHandleMap | GetObject | Die <om .GetObject> -Methode liefert 
	// das unter der übergebenen Zugriffsnummer registrierte Objekt.
	// @parm LONG | Handle | Der Parameter <p Handle> muß eine gültige Zugriffsnummer eines 
	// registrierten Objektes enthalten.
	// @parm IUnknown ** | Object | Nach erfolgreicher Abarbeitung enthält dieser Parameter den für das
	// Objekt registrierten Interface-Pointer
	// @supby <o TRiASObjectHandleMap>
	// @xref <i ITRiASObjectHandleMap>
		[id(101), helpstring("Liefert das unter der übergebenen Zugriffsnummer registrierte Objekt.")] HRESULT GetObject([in] INT_PTR Handle, [out, retval] IUnknown **Object);

	// @method HRESULT | ITRiASObjectHandleMap | RemoveObject | Die <om .RemoveObject> -Methode entfernt 
	// das durch die übergebene Zugriffsnummer referenzierte Objekt aus der Objekttabelle.
	// @parm LONG | Handle | Der Parameter <p Handle> muß die gültige Zugriffsnummer des Objektes
	// enthalten, welches aus der Tabelle entfernt werden soll.
	// @comm Wenn das Objekt mit dem Wert <e OBJECTMAPMODE.OBJECTMAPMODE_RegistrationKeepsAlive> 
	// registriert wurde, dann bewirkt diese Methode, daß das Objekt nicht nur aus der Tabelle 
	// entfernt sondern gleichzeitig freigegeben wird (Release).
	// @supby <o TRiASObjectHandleMap>
	// @xref <i ITRiASObjectHandleMap>, <t OBJECTMAPMODE>
	// @end
		[id(102), helpstring("Entfernt das durch die übergebene Zugriffsnummer referenzierte Objekt aus der Objekttabelle.")] HRESULT RemoveObject([in] INT_PTR Handle, [in /*, optional*/, defaultvalue(OBJECTMAPMODE_RemoveThisReference)] OBJECTMAPMODE Mode);

	// @method HRESULT | ITRiASObjectHandleMap | ShutDown | Die <om .ShutDown> -Methode Koppelt diese 
	// Tabelle vom normalen Leben ab.
	// @supby <o TRiASObjectHandleMap>
	// @xref <i ITRiASObjectHandleMap>
		[id(DISPID_PROPERTYSHUTDOWN), helpstring("Koppelt diese Tabelle vom normalen Leben ab.")] HRESULT ShutDown();

	// @method HRESULT | ITRiASObjectHandleMap | GetObjectEx | Die <om .GetObjectEx> -Methode liefert 
	// das unter der übergebenen Zugriffsnummer registrierte Objekt unter Berücksichtigung des übergebenen
	// Modes.
	// @parm LONG | Handle | Der Parameter <p Handle> muß eine gültige Zugriffsnummer eines 
	// registrierten Objektes enthalten.
	// @parm <t OBJECTMAPMODE> | Mode | Der Parameter <p Mode> gibt den Mode vor welcher entscheidet, 
	// wie das geforderte Objekt gesucht werden soll.
	// @parm IUnknown ** | Object | Nach erfolgreicher Abarbeitung enthält dieser Parameter den für das
	// Objekt registrierten Interface-Pointer
	// @supby <o TRiASObjectHandleMap>
	// @xref <i ITRiASObjectHandleMap>
	// @end
		[id(103), helpstring("Liefert das unter der übergebenen Zugriffsnummer registrierte Objekt.")] HRESULT GetObjectEx([in] INT_PTR Handle, [in /*, optional*/, defaultvalue(OBJECTMAPMODE_GetObjectFromHandle)] OBJECTMAPMODE Mode, [out, retval] IUnknown **Object);
	};

// @doc INTERFACE GENERIC
	[
		object,
		uuid(70168376-7737-11D2-9EF1-006008447800),
		dual,
		helpstring("IObjectWithName Interface"),
		pointer_default(unique)
	]
	interface IObjectWithName : IUnknown
	{
	// @property BSTR | IObjectWithName | Name | Liefert bzw. setzt den Bezeichner dieses Objektes.
	// @xref <i IObjectWithName>
		[propget, helpstring("Liefert den Bezeichner dieses Objektes.")] HRESULT Name([out, retval] BSTR *pVal);
		[propput, helpstring("Setzt den Bezeichner dieser Objektes.")] HRESULT Name([in] BSTR newVal);
	};

///////////////////////////////////////////////////////////////////////////////
// @doc INTERFACE HELPER
// @interface ITRiASObjectsOperations | Das Interface <i ITRiASObjectsOperations>
// stellt diverse allgemein nützliche Operationen über Objektmengen (<o TRiASObjects> -Objekten
// zur Verfügung.
// @supby <o TRiASObjectsOperations>, <o TRiASObjects>
// @xref <o TRiASObjectsOperations>, <i TRiASObjects>
// @group Methoden und Eigenschaften von <i ITRiASObjectsOperations> 
// @index | IOBJECTSOPERATIONS
// @doc IOBJECTSOPERATIONS
	[
		object,
		uuid(F45F28D7-7D2F-11D2-9EF6-006008447800),
		dual,
		helpstring("ITRiASObjectsOperations Interface"),
		pointer_default(unique)
	]
	interface ITRiASObjectsOperations : IDispatch
	{
	// @method HRESULT | ITRiASObjectsOperations | MakeNewObjects | Die <om .MakeNewObjects> -Methode 
	// erzeugt eine neue Objektmenge.
	// @parm IDispatch * | Parent | Der Parameter <p Parent> enthält einen Verweis auf das Objekt, welches als
	// übergeordnetes Objekt in Bezug auf die neu zu erzeugende Objektsammlung verwendet werden soll. 
	// @parm BSTR | Name | Der Parameter <p Name> enthält den Namen (Bezeichner) der neu erzeugten Objektmenge.
	// @parm BSTR | Type | Der Parameter <p Type> enthält den Typ (ProgID) der neu zu erzeugenden Objektmenge.
	// Ist der übergebene Typ ungültig, dann wird eine Objektmenge vom Typ "TRiASDB.TRiASObjects.1" erzeugt.
	// @parm <t OBJECTSCOLLECTIONTYPE> | CollType | der Parameter <p CollType> enthält den Typ der neu zu
	// erzeugenden Objektmenge.
	// @parm <i ITRiASObjects> ** | ObjsOut | Der Parameter <p ObjsOut> enthält nach erfolgreicher Abarbeitung 
	// der Methode die neu erzeugte Objektsammlung.
	// @supby <o TRiASObjectsOperations>, <o TRiASObjects>
	// @xref <i ITRiASObjectsOperations>, <i ITRiASObjects>
		[id(1), helpstring("Erzeugt eine neue Objektmenge.")] HRESULT MakeNewObjects([in] IDispatch *Parent, [in] BSTR Name, [in] BSTR Type, [in] OBJECTSCOLLECTIONTYPE CollType, [out, retval] ITRiASObjects **ObjsOut);

	// @method HRESULT | ITRiASObjectsOperations | Union | Die <om .Union> -Methode bildet die Vereinigungsmenge
	// der Objekte beider übergebenen Objektmengen. Die Ausgabeobjektmenge enthält nach Abarbeitung der 
	// <om .Union> -Methode all jene Objekte, die in wenigstens einer der beiden Eingabeobjektmenge 
	// enthalten sind.
	// @parm <i ITRiASObjects> * | Objs1 | Die erste zu vereinigende Objektmenge.
	// @parm <i ITRiASObjects> * | Objs2 | Die zweite zu vereinigende Objektmenge.
	// @parm BSTR | Name | Der Parameter <p Name> enthält den Namen (Bezeichner) der neu erzeugten Objektmenge.
	// @parm BSTR | Type | Der Parameter <p Type> enthält den Typ (ProgID) der neu zu erzeugenden Objektmenge.
	// Ist der übergebene Typ ungültig, dann wird eine Objektmenge vom Typ "TRiASDB.TRiASObjects.1" erzeugt.
	// @parm <t OBJECTSCOLLECTIONTYPE> | CollType | der Parameter <p CollType> enthält den Typ der neu zu
	// erzeugenden Objektmenge.
	// @parm <i ITRiASObjects> ** | ObjsOut | Der Parameter <p ObjsOut> enthält nach erfolgreicher Abarbeitung 
	// der Methode die gebildete Vereinigungsmenge.
	// @comm ACHTUNG: die beiden Eingabeobjektmengen müssen nach identischen Ordnungskriterien
	// sortiert sein.
	// @supby <o TRiASObjectsOperations>, <o TRiASObjects>
	// @xref <i ITRiASObjectsOperations>, <t OBJECTSCOLLECTIONTYPE>, <i ITRiASObjects>
		[id(2), helpstring("Bildet die Vereinigungsmenge der Objekte beider übergebenen Objektmengen.")] HRESULT Union([in] ITRiASObjects *Objs1, [in] ITRiASObjects *Objs2, [in] BSTR Name, [in] BSTR Type, [in] OBJECTSCOLLECTIONTYPE CollType, [out, retval] ITRiASObjects **ObjsOut);

	// @method HRESULT | ITRiASObjectsOperations | Intersection | Die <om .Intersection> -Methode bildet 
	// die Schnittmenge der Objekte beider übergebenen Objektmengen. Die Ausgabeobjektmenge enthält nach 
	// Abarbeitung der <om .Intersection> -Methode all jene Objekte, die in beiden Eingabeobjektmengen 
	// enthalten sind.
	// @parm <i ITRiASObjects> * | Objs1 | Die erste zu schneidende Objektmenge.
	// @parm <i ITRiASObjects> * | Objs2 | Die zweite zu schneidende Objektmenge.
	// @parm BSTR | Name | Der Parameter <p Name> enthält den Namen (Bezeichner) der neu erzeugten Objektmenge.
	// @parm BSTR | Type | Der Parameter <p Type> enthält den Typ (ProgID) der neu zu erzeugenden Objektmenge.
	// Ist der übergebene Typ ungültig, dann wird eine Objektmenge vom Typ "TRiASDB.TRiASObjects.1" erzeugt.
	// @parm <t OBJECTSCOLLECTIONTYPE> | CollType | der Parameter <p CollType> enthält den Typ der neu zu
	// erzeugenden Objektmenge.
	// @parm <i ITRiASObjects> ** | ObjsOut | Der Parameter <p ObjsOut> enthält nach erfolgreicher Abarbeitung 
	// der Methode die gebildete Schnittmenge.
	// @comm ACHTUNG: die beiden Eingabeobjektmengen müssen nach identischen Ordnungskriterien
	// sortiert sein.
	// @supby <o TRiASObjectsOperations>, <o TRiASObjects>
	// @xref <i ITRiASObjectsOperations>, <t OBJECTSCOLLECTIONTYPE>, <i ITRiASObjects>
		[id(3), helpstring("Bildet die Schnittmenge der Objekte beider übergebenen Objektmengen.")] HRESULT Intersection([in] ITRiASObjects *Obj1, [in] ITRiASObjects *Objs2, [in] BSTR Name, [in] BSTR Type, [in] OBJECTSCOLLECTIONTYPE CollType, [out, retval] ITRiASObjects **ObjsOut);

	// @method HRESULT | ITRiASObjectsOperations | Difference | Die <om .Difference> -Methode bildet 
	// die Differenzmenge der Objekte beider übergebenen Objektmengen. Die Ausgabeobjektmenge enthält nach 
	// Abarbeitung der <om .Difference> -Methode all jene Objekte, die in der ersten jedoch nicht der zweiten 
	// Eingabeobjektmenge enthalten sind.
	// @parm <i ITRiASObjects> * | Objs1 | Die erste zu bearbeitende Objektmenge.
	// @parm <i ITRiASObjects> * | Objs2 | Die zweite zu bearbeitende Objektmenge.
	// @parm BSTR | Name | Der Parameter <p Name> enthält den Namen (Bezeichner) der neu erzeugten Objektmenge.
	// @parm BSTR | Type | Der Parameter <p Type> enthält den Typ (ProgID) der neu zu erzeugenden Objektmenge.
	// Ist der übergebene Typ ungültig, dann wird eine Objektmenge vom Typ "TRiASDB.TRiASObjects.1" erzeugt.
	// @parm <t OBJECTSCOLLECTIONTYPE> | CollType | der Parameter <p CollType> enthält den Typ der neu zu
	// erzeugenden Objektmenge.
	// @parm <i ITRiASObjects> ** | ObjsOut | Der Parameter <p ObjsOut> enthält nach erfolgreicher Abarbeitung 
	// der Methode die gebildete Differenzmenge.
	// @comm ACHTUNG: die beiden Eingabeobjektmengen müssen nach identischen Ordnungskriterien
	// sortiert sein.
	// @supby <o TRiASObjectsOperations>, <o TRiASObjects>
	// @xref <i ITRiASObjectsOperations>, <t OBJECTSCOLLECTIONTYPE>, <i ITRiASObjects>
		[id(4), helpstring("Bildet die Differenzmenge der Objekte beider übergebenen Objektmengen.")] HRESULT Difference([in] ITRiASObjects *Obj1, [in] ITRiASObjects *Objs2, [in] BSTR Name, [in] BSTR Type, [in] OBJECTSCOLLECTIONTYPE CollType, [out, retval] ITRiASObjects **ObjsOut);

	// @method HRESULT | ITRiASObjectsOperations | SymmetricDifference | Die <om .SymmetricDifference> 
	// -Methode bildet die symmetrische Differenzmenge der Objekte beider übergebenen Objektmengen. Die 
	// Ausgabeobjektmenge enthält nach Abarbeitung der <om .SymmetricDifference> -Methode all jene Objekte, 
	// die genau einer der beiden Eingabeobjektmengen enthalten sind.
	// @parm <i ITRiASObjects> * | Objs1 | Die erste zu bearbeitende Objektmenge.
	// @parm <i ITRiASObjects> * | Objs2 | Die zweite zu bearbeitende Objektmenge.
	// @parm BSTR | Name | Der Parameter <p Name> enthält den Namen (Bezeichner) der neu erzeugten Objektmenge.
	// @parm BSTR | Type | Der Parameter <p Type> enthält den Typ (ProgID) der neu zu erzeugenden Objektmenge.
	// Ist der übergebene Typ ungültig, dann wird eine Objektmenge vom Typ "TRiASDB.TRiASObjects.1" erzeugt.
	// @parm <t OBJECTSCOLLECTIONTYPE> | CollType | der Parameter <p CollType> enthält den Typ der neu zu
	// erzeugenden Objektmenge.
	// @parm <i ITRiASObjects> ** | ObjsOut | Der Parameter <p ObjsOut> enthält nach erfolgreicher Abarbeitung 
	// der Methode die gebildete symmetrische Differenzmenge.
	// @comm ACHTUNG: die beiden Eingabeobjektmengen müssen nach identischen Ordnungskriterien
	// sortiert sein.
	// @supby <o TRiASObjectsOperations>, <o TRiASObjects>
	// @xref <i ITRiASObjectsOperations>, <t OBJECTSCOLLECTIONTYPE>, <i ITRiASObjects>
		[id(5), helpstring("Bildet die symmetrische Differenzmenge der Objekte beider übergebenen Objektmengen.")] HRESULT SymmetricDifference([in] ITRiASObjects *Obj1, [in] ITRiASObjects *Objs2, [in] BSTR Name, [in] BSTR Type, [in] OBJECTSCOLLECTIONTYPE CollType, [out, retval] ITRiASObjects **ObjsOut);

	// @method HRESULT | ITRiASObjectsOperations | Includes | Die <om .Includes> -Methode stellt fest,
	// ob die Folge der Objekte der zweiten Objektmenge vollständig in der ersten Objektmenge enthalten ist.
	// @parm <i ITRiASObjects> * | Objs1 | Die erste zu untersuchende Objektmenge.
	// @parm <i ITRiASObjects> * | Objs2 | Die zweite zu untersuchende Objektmenge.
	// @parm VARIANT_BOOL | Includes | Der Parameter <p Includes> entält nach erfolgreicher Abarbeitung
	// die Information darüber, ob die Folge der Objekte der zweiten Objektmenge vollständig in der ersten
	// übergebenen Objektmenge enthalten ist (<cv VARIANT_TRUE>) oder nicht (<cv VARIANT_FALSE>).
	// @comm ACHTUNG: die beiden Eingabeobjektmengen müssen nach identischen Ordnungskriterien
	// sortiert sein.
	// @supby <o TRiASObjectsOperations>, <o TRiASObjects>
	// @xref <i ITRiASObjectsOperations>, <t OBJECTSCOLLECTIONTYPE>, <i ITRiASObjects>
		[id(6), helpstring("Stellt fest, ob die Folge der Objekte der zweiten Objektmenge vollständig in der ersten Objektmenge enthalten ist.")] HRESULT Includes([in] ITRiASObjects *Objs1, [in] ITRiASObjects *Objs2, [out, retval] VARIANT_BOOL *Includes);
	};

	[
		object,
		uuid(9D793C97-B60C-11D2-95A8-006008447800),
		helpstring("ITRiASHandle Interface"),
		pointer_default(unique)
	]
	interface ITRiASHandle : IUnknown
	{
		[helpstring("Liefert das Handle eines Objektes.")] HRESULT GetHandle ([out, retval] INT_PTR *Handle);
		[helpstring("Setzt das Handle eines Objektes.")] HRESULT PutHandle ([in] INT_PTR Handle);
	};

///////////////////////////////////////////////////////////////////////////////
// @doc INTERFACE HELPER
// @interface ITRiASQueryVisInfo | Das Interface <i ITRiASQueryVisInfo> dient dem
// Zugriff auf spezielle objektklassenbezogene bzw. Objektbezogene Darstellungsparameter.
// @supby <o TRiASObjects>, <o TRiASObjects>
// @xref <o TRiASObjects>, <i TRiASObjects>
// @group Methoden und Eigenschaften von <i ITRiASQueryVisInfo> 
// @index | IQUERYVISINFO
// @doc IQUERYVISINFO
	[
		object,
		uuid(83650330-3389-11D3-94F9-0080C786297B),
		oleautomation,
		helpstring("ITRiASQueryVisInfo Interface"),
		pointer_default(unique)
	]
	interface ITRiASQueryVisInfo : IUnknown
	{
	// @property <i DVisInfo> * | ITRiASQueryVisInfo | VisInfo | Die <op .VisInfo>- Eigenschaft liefert
	// die zugeordnete Visualisierungsinformation.
	// @parm <t OBJECTTYPE> | Type | Der optionale Parameter <p Type> legt fest, für welchen Objekttyp die 
	// Visualisierungsinformation abgefragt werden soll.
	// @comm Die Eigenschaft <op .VisInfo> kann nicht gesetzt werden.
	// @supby <o TRiASViewItem> 
	// @xref <i ITRiASViewItem>, <i DVisInfo>
	// @end
		[propget, id(4), helpstring("Liefert die zugeordneten Visualisierungsinformation.")] HRESULT VisInfo([in /*, optional*/, defaultvalue(OBJECTTYPE_Unknown)] OBJECTTYPE Type, [out, retval] DVisInfo **pVal);
	};

///////////////////////////////////////////////////////////////////////////////
// @doc INTERFACE HELPER
// @interface IReconnectDialog | Das Interface <i IReconnectDialog> dient der
// Anzeige einer geeigneten Nutzeroberfläche zur Wiederherstellung einer
// Datenbankverbindung.
// @group Methoden und Eigenschaften von <i IReconnectDialog> 
// @index | IRECONNECTDIALOG
// @doc IRECONNECTDIALOG
	[
		object,
		uuid(96EE4262-A649-40E6-A51E-6F51C13E0D03),
		oleautomation,
		helpstring("IReconnectDialog Interface"),
		pointer_default(unique)
	]
	interface IReconnectDialog : IUnknown
	{
	// @method String | IReconnectDialog | GetReconnectParams | Die Methode 
	// <op .GetReconnectParams> zeigt eine geeignete Nutzeroberfläche an, die es
	// erlaubt, die Verbindung zu einer Datenbank wiederherzustellen.
	// @end
		[id(1), helpstring("Zeigt Nutzeroberfläche zum Wiederherstellen einer Datenbankverbindung an.")] HRESULT GetReconnectParams([in] INT_PTR hWnd, [in] BSTR Name, [in] BSTR Desc, [in] BSTR ConnectString, [in] BSTR bstrPath, [in, out] BSTR *NewName, [in, out] BSTR *NewConnectString, [in, out] BSTR *NewPath);
	};

///////////////////////////////////////////////////////////////////////////////
// @doc INTERFACE HELPER
// @interface ICreateDatabase | Das Interface <i ICreateDatabase> dient dem
// Anlegen einer neuen Datenbank entsprechend den vorgegebenen Parametern.
// @group Methoden und Eigenschaften von <i ICreateDatabase> 
// @index | ICREATEDATABASE
// @doc ICREATEDATABASE
	[
		object,
		uuid(AC060987-CE9F-45A4-9E5F-0184B0A4CA24),
		oleautomation,
		helpstring("ICreateDatabase Interface"),
		pointer_default(unique)
	]
	interface ICreateDatabase : IUnknown
	{
	// @method String | ICreateDatabase | CreateDatabase | Die Methode 
	// <op .CreateDatabase> legt eine neue Datenbank an.
	// @end
		[id(1), helpstring("Legt eine neue Datenbank an.")] HRESULT CreateDatabase([in] BSTR name, [in] BSTR Locale, [in] BSTR Source);
	};

///////////////////////////////////////////////////////////////////////////////
// @doc INTERFACE HELPER
// @interface ITRiASConnectionFilter | Das Interface <i ITRiASConnectionFilter> 
// dient dem Zugriff auf die Eigenschaften eines Verbindungs-Filters.
// @group Methoden und Eigenschaften von <i ITRiASConnectionFilter> 
// @index | ITRIASCONNECTIONFILTER
// @doc ITRIASCONNECTIONFILTER
	[
		object,
		uuid(2878DC6F-0786-4643-8D89-3672898B8DDB),
		dual,
		helpstring("ITRiASConnectionFilter Interface"),
		pointer_default(unique)
	]
	interface ITRiASConnectionFilter : IDispatch
	{
	cpp_quote("#if !defined(_CONNECTIONFILTERTYPE_DEFINED)")
	cpp_quote("#define _CONNECTIONFILTERTYPE_DEFINED")
	// @doc CONNECTIONFILTERTYPEENUM 
	// @enum CONNECTIONFILTERTYPE | Der Typ eines räumlichen Verbindungsfilters.
	// @xref <i ITRiASConnectionFilter>
		typedef [public, v1_enum, helpstring("Der Typ eines räumlichen Verbindungsfilters")]
		enum _tagCONNECTIONFILTERTYPE {
			[helpstring("Unbekannter Typ")]
				CONNECTIONFILTERTYPE_Unknown = 0,		// @emem Unbekannter Typ
			[helpstring("Liefert sämtliche Objekte, deren Container vollständig im gegebenen Rechteck enthalten ist oder dieses überlappt")]
				CONNECTIONFILTERTYPE_Rectangle_OverlappedContainers = 0x1,	// @emem Liefert 
					// sämtliche Objekte, deren Container vollständig im gegebenen 
					// Rechteck enthalten ist oder dieses überlappt.
			[helpstring("Liefert sämtliche Objekte, deren Container vollständig im gegebenen Rechteck enthalten ist")]
				CONNECTIONFILTERTYPE_Rectangle_ContainedContainers = 0x2,	// @emem Liefert 
					// sämtliche Objekte, deren Container vollständig im gegebenen 
					// Rechteck enthalten ist.
			[helpstring("Liefert sämtliche Objekte, die Stützpunkt-genau vollständig im gegebenen Rechteck enthalten sind oder dieses überlappen")]
				CONNECTIONFILTERTYPE_Rectangle_OverlappedPoints = 0x3,		// @emem Liefert 
					// sämtliche Objekte, die Stützpunkt-genau vollständig im gegebenen 
					// Rechteck enthalten sind oder dieses überlappen.
			[helpstring("Liefert sämtliche Objekte, die Stützpunkt-genau vollständig im gegebenen Rechteck enthalten sind")]
				CONNECTIONFILTERTYPE_Rectangle_ContainedPoints = 0x4,		// @emem Liefert 
					// sämtliche Objekte, die Stützpunkt-genau vollständig im gegebenen 
					// Rechteck enthalten sind.
			[helpstring("Liefert sämtliche Objekte, die vollständig im gegebenen Rechteck enthalten sind oder dieses überlappen")]
				CONNECTIONFILTERTYPE_Rectangle_OverlappedObjects = 0x5,		// @emem Liefert 
					// sämtliche Objekte, die vollständig im gegebenen 
					// Rechteck enthalten sind oder dieses überlappen.
			[helpstring("Liefert sämtliche Objekte, die vollständig im gegebenen Rechteck enthalten sind")]
				CONNECTIONFILTERTYPE_Rectangle_ContainedObjects = 0x6,		// @emem Liefert 
					// sämtliche Objekte, die vollständig im gegebenen 
					// Rechteck enthalten sind.

			[helpstring("Liefert sämtliche Objekte, deren Container vollständig im gegebenen Polygon enthalten ist oder dieses überlappt")]
				CONNECTIONFILTERTYPE_Polygon_OverlappedContainers = 0x11,		// @emem Liefert 
					// sämtliche Objekte, deren Container vollständig im gegebenen 
					// Polygon enthalten ist oder dieses überlappt.
			[helpstring("Liefert sämtliche Objekte, deren Container vollständig im gegebenen Polygon enthalten ist")]
				CONNECTIONFILTERTYPE_Polygon_ContainedContainers = 0x12,		// @emem Liefert 
					// sämtliche Objekte, deren Container vollständig im gegebenen 
					// Polygon enthalten ist.
			[helpstring("Liefert sämtliche Objekte, die Stützpunkt-genau vollständig im gegebenen Polygon enthalten sind oder dieses überlappen")]
				CONNECTIONFILTERTYPE_Polygon_OverlappedPoints = 0x13,		// @emem Liefert 
					// sämtliche Objekte, die Stützpunkt-genau vollständig im gegebenen 
					// Polygon enthalten sind oder dieses überlappen.
			[helpstring("Liefert sämtliche Objekte, die Stützpunkt-genau vollständig im gegebenen Polygon enthalten sind")]
				CONNECTIONFILTERTYPE_Polygon_ContainedPoints = 0x14,		// @emem Liefert 
					// sämtliche Objekte, die Stützpunkt-genau vollständig im gegebenen 
					// Polygon enthalten sind.
			[helpstring("Liefert sämtliche Objekte, die vollständig im gegebenen Polygon enthalten sind oder dieses überlappen")]
				CONNECTIONFILTERTYPE_Polygon_OverlappedObjects = 0x15,		// @emem Liefert 
					// sämtliche Objekte, die vollständig im gegebenen 
					// Polygon enthalten sind oder dieses überlappen.
			[helpstring("Liefert sämtliche Objekte, die vollständig im gegebenen Polygon enthalten sind")]
				CONNECTIONFILTERTYPE_Polygon_ContainedObjects = 0x16,		// @emem Liefert 
					// sämtliche Objekte, die vollständig im gegebenen 
					// Polygon enthalten sind.
		} CONNECTIONFILTERTYPE;
	cpp_quote("#endif // _CONNECTIONFILTERTYPE_DEFINED")

		[propget, id(DISPID_VALUE), helpstring("Liest den Namen des Verbindungsfilters.")] HRESULT Name([out, retval] BSTR *pVal);
		[propput, id(DISPID_VALUE), helpstring("Setzt den Namen des Verbindungsfilters.")] HRESULT Name([in] BSTR newVal);
		[propget, id(2), helpstring("Liest die Geometrie des Verbindungsfilters.")] HRESULT Geometry([out, retval] IDispatch **Geometry);
		[propput, id(2), helpstring("Setzt die Geometrie des Verbindungsfilters.")] HRESULT Geometry([in] IDispatch *Geometry);
		[propget, id(3), helpstring("Liest den Typ des Verbindungsfilters.")] HRESULT Type([out, retval] CONNECTIONFILTERTYPE *prgType);
		[propput, id(3), helpstring("Setzt den Typ des Verbindungsfilters.")] HRESULT Type([in] CONNECTIONFILTERTYPE rgType);
	};

///////////////////////////////////////////////////////////////////////////////
// @doc INTERFACE HELPER
// @interface ITRiASConnectionFilters | Das Interface <i ITRiASConnectionFilters> 
// dient dem Zugriff alle Verbindungs-Filter.
// @group Methoden und Eigenschaften von <i ITRiASConnectionFilters> 
// @index | ITRIASCONNECTIONFILTERS
// @doc ITRIASCONNECTIONFILTERS
	[
		object,
		uuid(FC0EEE23-5A65-4131-AA9E-D231A97C5A9A),
		dual,
		helpstring("ITRiASConnectionFilters Interface"),
		pointer_default(unique)
	]
	interface ITRiASConnectionFilters : IDispatch
	{
		[id(100), helpstring("Create and add a new connection filter.")] HRESULT Add([in] BSTR Name, [out, retval] ITRiASConnectionFilter **Filter);
	};

#endif // !defined(_TRIASDBINTERFACES_IDL__C750A280_39CB_11D3_94FA_0080C786297B__INCLUDED_)
