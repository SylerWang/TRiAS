// $Header: $
// Copyright© 1998-$$year$$ $$company$$, All rights reserved
// Created: $$date_n_time$$
//
// This file was generated by the TRiASDB Data Server Wizard $$this_version$$
//
$$IF(EMIT_WARRANTIES)
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY 
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR 
// PURPOSE.
//
$$ENDIF // EMIT_WARRANTIES
// @doc 
// @module $$root$$DBEngine.cpp |  Databaseengine für TRiASDB Data Server $$root$$

#include "stdafx.h"

#include "Version.h"
#include "Strings.h"

#include "$$root$$.h"
#include "$$root$$DBEngine.h"
#include "$$root$$Database.h"

#if defined(_DEBUG)
#if defined(_MFC_VER)
#define new DEBUG_NEW
#endif // defined(_MFC_VER)
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// globale Instanz der DBEngine
C$$safe_root$$DBEngine *g_pDBEngine = NULL;
STARTMODE g_rgStartMode = STARTMODE_Normal;

///////////////////////////////////////////////////////////////////////////////
// C$$safe_root$$DBEngine

STDMETHODIMP C$$safe_root$$DBEngine::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITRiASDBEngine,
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

HRESULT C$$safe_root$$DBEngine::FinalConstruct (void)
{
	return S_OK;
}

void C$$safe_root$$DBEngine::FinalRelease()
{
	_ASSERTE(NULL == g_pDBEngine);	// existiert nicht mehr (sollte jedenfalls)
}

///////////////////////////////////////////////////////////////////////////////
// ITRiASDBEngine
STDMETHODIMP C$$safe_root$$DBEngine::get_Version (BSTR *pVal)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	CHECKOUTPOINTER(pVal);	

CString strVersion;

	strVersion.Format (_T("%d.%02d.%03d"), $$SAFE_ROOT$$_VERSION, $$SAFE_ROOT$$_RELEASE, $$SAFE_ROOT$$_BUILD);

CComBSTR bstrVersion (strVersion);

	*pVal = bstrVersion.Detach();
	return S_OK;
}

STDMETHODIMP C$$safe_root$$DBEngine::put_Password (BSTR bstrPwd)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	CHECKINPOINTER(bstrPwd);	

	m_bstrPassword = bstrPwd;
	return S_OK;
}

STDMETHODIMP C$$safe_root$$DBEngine::put_UserName (BSTR bstrUser)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	CHECKINPOINTER(bstrUser);

	m_bstrUserName = bstrUser;
	return S_OK;
}

STDMETHODIMP C$$safe_root$$DBEngine::get_Description (BSTR * pVal)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	CHECKOUTPOINTER(pVal);	

CComBSTR bstr;

	if (!bstr.LoadString (IDS_DBENGINE_DESC))
		return E_OUTOFMEMORY;

	*pVal = bstr.Detach();
	return S_OK;
}

STDMETHODIMP C$$safe_root$$DBEngine::Start (STARTMODE rgMode)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)
	_ASSERTE(NULL == g_pDBEngine);	// darf nur einmal gerufen werden

	COM_TRY {
	// singletions instantiieren
		m_Service = WTRiASCSStorageService(CLSID_TRiASCSStorageService);

	// fertig initialisieren
		g_pDBEngine = this;
		g_rgStartMode = rgMode;
		m_fIsStarted = true;
	} COM_CATCH;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// Liefert Enumerator, der alle bekannten Projekttypen enthält

#pragma TODO("Im folgenden Feld müssen alle durch diesen Modul unterstützten Datenserver aufgelistet sein.")
const LPCOLESTR s_poleTypesNormal[] = 
{
	g_cbDatabase,		// ProgID des Database-Objektes (s. $$root$$Database.h)
};

typedef CComEnum<IEnumString, &IID_IEnumString, LPOLESTR, _Copy<LPOLESTR> > CEnumString;

STDMETHODIMP C$$safe_root$$DBEngine::EnumDataBaseTypes (IUnknown **ppIEnum)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	CHECKOUTPOINTER(ppIEnum);	

CComObject<CEnumString> *pIEnum = NULL;

	ATLTRY(pIEnum = new CComObject<CEnumString>());
	if (NULL == pIEnum) return E_OUTOFMEMORY;

// die Funktion Init des EnumTemplates erwartet die Adressen des ersten und 
// letzten+1 Elementes eines Vektors
LPOLESTR *ppStringsStart = (LPOLESTR *)&s_poleTypesNormal[0];
LPOLESTR *ppStringsEnd = (LPOLESTR *)&s_poleTypesNormal[_countof(s_poleTypesNormal)];

HRESULT hr = pIEnum -> Init (ppStringsStart, ppStringsEnd, static_cast<ITRiASDBEngine *>(this), AtlFlagCopy);

	if (SUCCEEDED(hr))
		hr = pIEnum -> QueryInterface(IID_IEnumString, (LPVOID *)ppIEnum);

	if (FAILED(hr))		// bei Fehler alles freigeben
		delete pIEnum;

	return hr;
}

STDMETHODIMP C$$safe_root$$DBEngine::Stop()
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	ERROR_EXPR_TRUE(!m_fIsStarted, TRIASDB_E_NOT_STARTED);

	g_pDBEngine = NULL;				// das letzte vom Tage
	return S_OK;
}
