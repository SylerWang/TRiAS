// $Header: $
// Copyright© 1998-$$year$$ $$company$$, All rights reserved
// Created: $$date_n_time$$ 
//
// This file was generated by the TRiASDB Data Server Wizard $$this_version$$
//
$$IF(EMIT_WARRANTIES)
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY 
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR 
// PURPOSE.
//
$$ENDIF // EMIT_WARRANTIES
// @doc
// @module $$root$$Objects.cpp | Implementation of the <c C$$safe_root$$Objects> class

#include "stdafx.h"

#include "Strings.h"

#include "$$root$$.h"
#include "$$root$$Objects.h"
$$IF(EMIT_SAMPLE_CODE)
$$IF(READ_WRITE)
// BEGIN_SAMPLE_CODE
#include "$$root$$PropertySupport.h"
// END_SAMPLE_CODE
$$ENDIF // $$IF(READ_WRITE)
$$ENDIF // $$IF(EMIT_SAMPLE_CODE)

#if defined(_DEBUG)
#if defined(_MFC_VER)
#define new DEBUG_NEW
#endif // defined(_MFC_VER)
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif // _DEBUG

///////////////////////////////////////////////////////////////////////////////
// C$$safe_root$$Objects

STDMETHODIMP C$$safe_root$$Objects::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITRiASObjects,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// ITRiASObjectsCallback

STDMETHODIMP C$$safe_root$$Objects::get_DefaultType (BSTR *pbstrType)
{
	CHECKOUTPOINTER(pbstrType);

CIID Guid (CLSID_$$safe_root$$Object);		// DefaultType der _Elemente_ (hier: Object)!
CComBSTR bstrType (Guid.ProgID().c_str());

	*pbstrType = bstrType.Detach();
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Erstmalige Initialisierung
STDMETHODIMP C$$safe_root$$Objects::SetupObjects(SETUPOBJECTSMODE rgMode)
{
HRESULT hr = E_INVALIDARG;

	switch (rgMode) {
	case SETUPOBJECTSMODE_Count:
		hr = EnsureObjectsCount();
		_ASSERTE(HasType (m_rgInitState, INITSTATE_CountsInitialized));
		break;

	case SETUPOBJECTSMODE_Load:
		ERROR_EXPR_TRUE(!m_fIsInitialized, E_UNEXPECTED);
		hr =  EnsureObjectsLoaded();
		_ASSERTE(HasType (m_rgInitState, INITSTATE_ObjectsInitialized));
		break;

	case SETUPOBJECTSMODE_InitOrLoad:	// wird während der Initialisierung gerufen
$$IF(EMIT_SAMPLE_CODE)
	// BEGIN_SAMPLE_CODE
		COM_TRY {
		// Properties zum aggregierten Objekt hinzufügen
		WTRiASPropertyMapHandler MapHandler(m_BaseUnk);

			THROW_FAILED_HRESULT(MapHandler -> AddMapEntry (
				CComBSTR(g_cbObjectsCursor), (INT_PTR)&CLSID_$$safe_root$$CursorProperty, PROPERTYSUPPORT_NOFLAGS, vtMissing));

		} COM_CATCH;
	// END_SAMPLE_CODE
$$ENDIF // $IF(EMIT_SAMPLE_CODE)
$$IF(!EMIT_PERSISTSTREAM_OBJECTS)
		m_fIsDirty = false;
		m_fIsInitialized = true;
$$ENDIF // IF(EMIT_PERSISTSTREAM_OBJECTS)
		hr = S_OK;
		break;

	case SETUPOBJECTSMODE_ResetObjectInfo:		// alles über die zugehörigen Objekte vergessen
$$IF(!EMIT_PERSISTSTREAM_OBJECTS)
		m_fIsDirty = true;
$$ENDIF // IF(EMIT_PERSISTSTREAM_OBJECTS)
		m_rgInitState = INITSTATE_NotInitialized;
		hr = S_OK;
		break;

	default:
		_ASSERTE(SETUPOBJECTSMODE_Count == rgMode || 
			SETUPOBJECTSMODE_Load == rgMode || 
			SETUPOBJECTSMODE_InitOrLoad == rgMode ||
			SETUPOBJECTSMODE_ResetObjectInfo == rgMode);
		break;
	}
	return hr;
}

HRESULT C$$safe_root$$Objects::EnsureObjectsCount()
{
	if (HasType (m_rgInitState, INITSTATE_CountsInitialized))
		return S_OK;		// wurden bereits geladen

#pragma TODO("Sämtliche Objekte dieser Objektklasse zählen und Typen feststellen.")

	COM_TRY {
	WTRiASObjects BaseObjs;
	long lObjCount = 0;
	OBJECTTYPE rgTypes = OBJECTTYPE_Unknown;

		THROW_FAILED_HRESULT(m_BaseUnk -> QueryInterface (BaseObjs.ppi()));

$$IF(EMIT_SAMPLE_CODE)
	// BEGIN_SAMPLEDATA
		using namespace sample_data;

	LONG lCursor (GetPropertyFrom (BaseObjs, g_cbObjectsCursor, -1L));

		_ASSERTE(0 < lCursor);
		lObjCount = g_ObjectClasses[lCursor-1] -> m_iObjectCount;
		rgTypes = g_ObjectClasses[lCursor-1] -> m_rgTypes;
	// END_SAMPLE_DATA

$$ELSE
//		lObjCount = ...;	// Anzahl der Objekte feststellen
//		rgTypes = ...;		// vertretene Objekttypen feststellen

$$ENDIF
	// Ergebnis der schweißtreibenden Arbeit dem aggregierten Objekt mitteilen
		THROW_FAILED_HRESULT(BaseObjs -> put_Count (lObjCount));		// Basisklasse informieren
		THROW_FAILED_HRESULT(BaseObjs -> put_Types (rgTypes));

	// Zähler sind jetzt initialisiert
		SetType (m_rgInitState, INITSTATE_CountsInitialized);

	} COM_CATCH;
	return S_OK;
}

HRESULT C$$safe_root$$Objects::EnsureObjectsLoaded()
{
	if (HasType (m_rgInitState, INITSTATE_ObjectsInitialized))
		return S_OK;		// wurden bereits geladen

#pragma TODO("Sämtliche Objekte dieser Objektklasse instantiieren und zum aggregierten Objekt hinzufügen.")

	COM_TRY {
	WTRiASObjects BaseObjs;
	
		THROW_FAILED_HRESULT(m_BaseUnk -> QueryInterface (BaseObjs.ppi()));

$$IF(EMIT_SAMPLE_CODE)
	// BEGIN_SAMPLEDATA
		using namespace sample_data;

	LONG lCursor (GetPropertyFrom (BaseObjs, g_cbObjectsCursor, -1L));

		_ASSERTE(0 < lCursor);

	// alle Objekte durchgehen und instantiieren
	const OBJECTCLASS *pClass = g_ObjectClasses[lCursor-1];
	WDispatch App;

		THROW_FAILED_HRESULT(BaseObjs -> get_Application (App.ppi()));
		for (int i = 0; i < pClass -> m_iObjectCount; i++) {
		int iObject = pClass -> m_pObjects[i];

			_ASSERTE(0 <= iObject && iObject < g_iObjectCount);

		const OBJECT *pObject = g_Objects[iObject];
		WTRiASObject Obj (CLSID_$$safe_root$$Object);

		// fertig initialisieren
			THROW_FAILED_HRESULT(WPersistStreamInit(Obj) -> InitNew());
			THROW_FAILED_HRESULT(Obj -> put_Application(App));
			THROW_FAILED_HRESULT(Obj -> put_Parent(BaseObjs));

		// Typ etc. setzen
			THROW_FAILED_HRESULT(Obj -> put_Type (pObject -> m_rgType));
			THROW_FAILED_HRESULT(Obj -> put_Name (CComBSTR(pObject -> m_pcoleGuid)));

		// an dem erzeugten Objekt unsere Nummer (cursor) speichern
			THROW_FAILED_HRESULT(SetPropertyBy (Obj, g_cbObjectCursor, CComVariant(iObject+1), true));

		// das neu instantiierte Objekt zu dieser Objektklasse hinzufügen
			THROW_FAILED_HRESULT(BaseObjs -> _Add (Obj, VARIANT_TRUE));
		}
	// END_SAMPLE_DATA
$$ELSE
	//WTRiASObject Object;
	//
	//	for (... jedes existierende Objekt in dieser Objektklasse  ...) {
	//		
	//		RETURN_FAILED_HRESULT(BaseObjs -> _Add (Object, VARIANT_TRUE));
	//	}
$$ENDIF
	// Objekte sind jetzt initialisiert
		SetType (m_rgInitState, INITSTATE_ObjectsInitialized);

	// Features initialisieren
		THROW_FAILED_HRESULT(SetupFeatures (
			SETUPFEATURESMODE(SETUPFEATURESMODE_Normal|SETUPFEATURESMODE_Force)));

	} COM_CATCH;
	return S_OK;
}

STDMETHODIMP C$$safe_root$$Objects::SetupFeatures(SETUPFEATURESMODE rgMode)
{
	ERROR_EXPR_TRUE(!m_fIsInitialized, E_UNEXPECTED);

// unterstützte Attribute mit Objektmenge assoziieren
	if (!m_fHasFeatures || (rgMode & SETUPFEATURESMODE_Force)) {
		COM_TRY {
		WTRiASFeatures Feats (CLSID_$$safe_root$$Features);

			THROW_FAILED_HRESULT(WTRiASObjects(m_BaseUnk) -> put_Features (Feats))
			THROW_FAILED_HRESULT(Feats -> Refresh());	// ruft C$$safe_root$$Features::SetupFeatures()
			m_fHasFeatures = true;

		} COM_CATCH;
	}

// existierende Geometrien mit dieser Objektklasse assoziieren
	if (!m_fHasGeoFeatures || (rgMode & SETUPFEATURESMODE_Force)) {
		COM_TRY {
		WTRiASFeatures GeoFeats (CLSID_$$safe_root$$GeoFeatures);

			THROW_FAILED_HRESULT(WTRiASObjects(m_BaseUnk) -> put_GeometryFeatures (GeoFeats))
			THROW_FAILED_HRESULT(GeoFeats -> Refresh());	// ruft C$$safe_root$$GeoFeatures::SetupFeatures()
			m_fHasGeoFeatures = true;

		} COM_CATCH;
	}
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Ein neues Objekt soll erzeugt werden
STDMETHODIMP C$$safe_root$$Objects::OnCreate (BSTR Name, BSTR Type, OBJECTTYPE rgType, ITRiASObject **ppIObj)
{
	CHECKOUTPOINTER(ppIObj);
$$IF(READ_WRITE)
#if defined(_READWRITE)
	COM_TRY {
	// jetzt wirklich erzeugen
	CIID ClsId (Type, CIID::INITCIID_InitFromProgId);

		if (!ClsId)	ClsId = CLSID_$$safe_root$$Object;	// default ClsId
	
	WTRiASObject Obj (ClsId);

#pragma TODO("Neues Objekt entsprechend Typ (rgType) initialisieren.")

		THROW_FAILED_HRESULT(Obj -> put_Name(Name));

	// wenn Feature bereits zu dieser Attributmenge gehört, dann liefert _Add den Wert S_FALSE
		THROW_FAILED_HRESULT(WTRiASObjects(m_BaseUnk) -> _Add (Obj, VARIANT_TRUE));
		*ppIObj = Obj.detach();

	} COM_CATCH;
	return S_OK;
#else
	return TRIASDB_E_OBJECTSNOTUPDATABLE;
#endif // defined(_READWRITE)
$$ELSE
	return TRIASDB_E_DATABASENOTUPDATABLE;
$$ENDIF
}

/////////////////////////////////////////////////////////////////////////////
// Irgend was wurde modifiziert
STDMETHODIMP C$$safe_root$$Objects::OnChanging(CHANGEDOBJECTS rgWhat, VARIANT vNewValue, VARIANT_BOOL *pDisAllow)
{
	CHECKOUTPOINTER(pDisAllow);

$$IF(READ_WRITE)
#if defined(_READWRITE)
	*pDisAllow = VARIANT_FALSE;		// immer einverstanden sein
	return S_OK;
#else
	*pDisAllow = VARIANT_TRUE;		// nie einverstanden sein
	return TRIASDB_E_DATABASENOTUPDATABLE;
#endif // defined(_READWRITE)
$$ELSE
	*pDisAllow = VARIANT_TRUE;		// verhindert Modifikation (rgWhat siehe OnChanged)
	return TRIASDB_E_DATABASENOTUPDATABLE;
$$ENDIF
}

/////////////////////////////////////////////////////////////////////////////
// Irgend was wurde modifiziert
STDMETHODIMP C$$safe_root$$Objects::OnChanged(CHANGEDOBJECTS rgWhat, VARIANT vOldValue)
{
$$IF(READ_WRITE)
#if defined(_READWRITE)
	switch(rgWhat) {
	case CHANGEDOBJECTS_Name:
		return OnChangedName(vOldValue);

	case CHANGEDOBJECTS_Description:
		return OnChangedDescription(vOldValue);

	case CHANGEDOBJECTS_OKS:
		return OnChangedOKS(vOldValue);

	case CHANGEDOBJECTS_Handle:
		return OnChangedHandle(vOldValue);

	case CHANGEDOBJECTS_Types:
		return OnChangedTypes(vOldValue);

	case CHANGEDOBJECTS_ROMode:
		return OnChangedROMode(vOldValue);

	default:
		break;
	}
	return E_INVALIDARG;
#else
	return TRIASDB_E_DATABASENOTUPDATABLE;
#endif // defined(_READWRITE)
$$ELSE
	return TRIASDB_E_DATABASENOTUPDATABLE;
$$ENDIF
}

/////////////////////////////////////////////////////////////////////////////
// Ein Objekt soll gelöscht werden
STDMETHODIMP C$$safe_root$$Objects::OnDelete (INT_PTR hObj)
{
$$IF(READ_WRITE)
#if defined(_READWRITE)
#pragma TODO("Gegebenenfalls Objekt aus Datenquelle löschen.")

	// S_OK:	Objekt wurde gelöscht
	// S_FALSE: das Objekt soll sich selbst löschen (geschieht nicht hier)
	// ansonsten Fehlercode
	return S_FALSE;
#else
	return TRIASDB_E_OBJECTSNOTUPDATABLE;
#endif // defined(_READWRITE)
$$ELSE
	return TRIASDB_E_OBJECTSNOTUPDATABLE;
$$ENDIF
}

/////////////////////////////////////////////////////////////////////////////
// Ein Objekt soll zu dieser Objektmenge hinzugefügt werden
STDMETHODIMP C$$safe_root$$Objects::OnAdd (ITRiASObject *pIObj, CLASSIFYMODE rgMode)
{
	if (CLASSIFYMODE_DoNotClassify == rgMode)
		return S_OK;	// nicht umklassifizieren/Rekursion verhindern

$$IF(READ_WRITE)
#if defined(_READWRITE)
#pragma TODO("Objekt zu dieser Objektklasse hinzufügen und evtl. aus alter Objektklasse entfernen (s. OnRemove).")

	// S_OK:	  erfolgreich dieser Objektklasse zugeordnet
	// E_NOTIMPL: Objekt muß in neue Objektklasse umkopiert werden (geschieht nicht hier)
	return S_OK;
#else
	return TRIASDB_E_OBJECTSNOTUPDATABLE;
#endif // defined(_READWRITE)
$$ELSE
	return TRIASDB_E_OBJECTSNOTUPDATABLE;
$$ENDIF
}

// Ein Objekt soll aus dieser Objektmenge entfernt werden
STDMETHODIMP C$$safe_root$$Objects::OnRemove (ITRiASObject *pIObj)
{
$$IF(READ_WRITE)
#if defined(_READWRITE)
#pragma TODO("Gegebenenfalls Objekt aus dieser Objektklasse entfernen (s. OnAdd).")

	// S_OK:	erfolgreich entfernt
	// S_FALSE:	wird in 'OnAdd' der neuen Objektklasse zugeordnet und aus alter Objektklasse entfernt
	// ansonsten Fehlercode
	return S_FALSE;
#else
	return TRIASDB_E_OBJECTSNOTUPDATABLE;
#endif // defined(_READWRITE)
$$ELSE
	return TRIASDB_E_OBJECTSNOTUPDATABLE;
$$ENDIF
}

// Eine Zugriffsnummer eines Attributes kann an dieser Stelle auf ein konkretes
// Attribut dieser Objektklasse gemappt werden
STDMETHODIMP C$$safe_root$$Objects::MapFeatureHandle (VARIANT vNameOrHandle, VARIANT *pvNewNameOrHandle)
{
	// default: nicht verändern
	return CComVariant(vNameOrHandle).Detach (pvNewNameOrHandle);
}

// Objekt wird logisch freigegeben
STDMETHODIMP C$$safe_root$$Objects::OnFinalRelease()
{
$$IF(EMIT_SAMPLE_CODE)
// BEGIN_SAMPLE_CODE
	COM_TRY {
	// unsere Nummer (Cursor) freigeben und damit dieses Objekt aus der Handlemap herauslöschen
		THROW_FAILED_HRESULT(DelPropertyBy (WDispatch(m_BaseUnk), g_cbObjectsCursor));
	} COM_CATCH;
// END_SAMPLE_CODE
$$ENDIF // $$IF(EMIT_SAMPLE_CODE)
	return S_OK;
}

$$IF(READ_WRITE)
#if defined(_READWRITE)
/////////////////////////////////////////////////////////////////////////////
// Helperfunktionen
HRESULT C$$safe_root$$Objects::OnChangedName(VARIANT vOldValue)
{
// neuen Namen vom Bezugsobjekt besorgen
CComBSTR bstrName;
WTRiASObjects BaseObjs;

	RETURN_FAILED_HRESULT(m_BaseUnk -> QueryInterface (BaseObjs.ppi()));
	RETURN_FAILED_HRESULT(BaseObjs -> get_Name (CLEARED(&bstrName)));

#pragma TODO("Neuen Namen der Objektklasse in Datenquelle speichern.")

	m_fIsDirty = true;
	return S_OK;
}

HRESULT C$$safe_root$$Objects::OnChangedDescription(VARIANT vOldValue)
{
// neue Beschreibung vom Bezugsobjekt besorgen
CComBSTR bstrDesc;
WTRiASObjects BaseObjs;

	RETURN_FAILED_HRESULT(m_BaseUnk -> QueryInterface (BaseObjs.ppi()));
	RETURN_FAILED_HRESULT(BaseObjs -> get_Description(CLEARED(&bstrDesc)));

#pragma TODO("Neue Beschreibung (Langtext) der Objektklasse in Datenquelle speichern.")

	m_fIsDirty = true;
	return S_OK;
}

HRESULT C$$safe_root$$Objects::OnChangedOKS(VARIANT vOldValue)
{
// neuen Objektklassenschlüssel vom Bezugsobjekt besorgen
CComBSTR bstrOKS;
WTRiASObjects BaseObjs;

	RETURN_FAILED_HRESULT(m_BaseUnk -> QueryInterface (BaseObjs.ppi()));
	RETURN_FAILED_HRESULT(BaseObjs -> get_OKS(CLEARED(&bstrOKS)));

#pragma TODO("Neuen Objektklassenschlüssel der Objektklasse in Datenquelle speichern.")

	m_fIsDirty = true;
	return S_OK;
}

HRESULT C$$safe_root$$Objects::OnChangedHandle(VARIANT vOldValue)
{
// neue Zugriffsnummer vom Bezugsobjekt besorgen
INT_PTR hObjs = NULL;
WTRiASObjects BaseObjs;

	RETURN_FAILED_HRESULT(m_BaseUnk -> QueryInterface (BaseObjs.ppi()));
	RETURN_FAILED_HRESULT(BaseObjs -> get_Handle(&hObjs));

#pragma TODO("Neue Zugriffsnummer der Objektklasse ggf. auswerten.")

	m_fIsDirty = true;
	return S_OK;
}

HRESULT C$$safe_root$$Objects::OnChangedTypes(VARIANT vOldValue)
{
// neue Objekttypen vom Bezugsobjekt besorgen
OBJECTTYPE rgTypes = OBJECTTYPE_Unknown;
WTRiASObjects BaseObjs;

	RETURN_FAILED_HRESULT(m_BaseUnk -> QueryInterface (BaseObjs.ppi()));
	RETURN_FAILED_HRESULT(BaseObjs -> get_Types(&rgTypes));

#pragma TODO("Neue Objekttypen der Objektklasse ggf. auswerten.")

	m_fIsDirty = true;
	return S_OK;
}

HRESULT C$$safe_root$$Objects::OnChangedROMode(VARIANT vOldValue)
{
// neuen Schreibschutzmode vom Bezugsobjekt besorgen
VARIANT_BOOL fUpdatable = VARIANT_FALSE;
WTRiASObjects BaseObjs;

	RETURN_FAILED_HRESULT(m_BaseUnk -> QueryInterface (BaseObjs.ppi()));
	RETURN_FAILED_HRESULT(BaseObjs -> get_Updatable(&fUpdatable));

#pragma TODO("Neuen Schreibschutzmode der Objektklasse ggf. auswerten.")

	m_fIsDirty = true;
	return S_OK;
}
#endif // defined(_READWRITE)
$$ENDIF

$$IF(EMIT_PERSISTSTREAM_OBJECTS)
/////////////////////////////////////////////////////////////////////////////
// IPersist
STDMETHODIMP C$$safe_root$$Objects::GetClassID (CLSID *pClassID)
{
	if (NULL == pClassID)
		return E_POINTER;

	*pClassID = GetObjectCLSID();
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// IPersistStream

STDMETHODIMP C$$safe_root$$Objects::IsDirty (void)
{
	return m_fIsDirty ? S_OK : WPersistStreamInit(m_BaseUnk) -> IsDirty();
}

STDMETHODIMP C$$safe_root$$Objects::Load (LPSTREAM pStm)
{
	if (m_fIsInitialized)
		return E_UNEXPECTED;

	COM_TRY {
	// unsere Daten laden
	long lSignature = 0L;

		RETURN_FAILED_HRESULT(LoadLong (pStm, lSignature));			// Signatur
		if ($$SAFE_ROOT$$OBJECTS_SIGNATURE != lSignature)
			return TRIASDB_E_BADOBJECTSIGNATURE;

	long lVersion = 0L;

		RETURN_FAILED_HRESULT(LoadLong (pStm, lVersion));			// VersionInfo
		if ((lVersion & ~$$SAFE_ROOT$$OBJECTS_VERSION_MINOR_MASK) > LASTKNOWN_$$SAFE_ROOT$$OBJECTS_VERSION)
			return TRIASDB_W_NEWEROBJECTSCOLLECTION;

	// jetzt Bezugsobjekt laden
		RETURN_FAILED_HRESULT(WPersistStreamInit(m_BaseUnk) -> Load (pStm));

#pragma TODO("Eigene persistente Daten laden (s. Save).")

	} COM_CATCH;

	m_fIsDirty = false;
	m_fIsInitialized = true;
	return S_OK;
}

STDMETHODIMP C$$safe_root$$Objects::Save (LPSTREAM pStm, BOOL fClearDirty)
{
	RETURN_FAILED_HRESULT(SaveLong(pStm, $$SAFE_ROOT$$OBJECTS_SIGNATURE));
	RETURN_FAILED_HRESULT(SaveLong(pStm, $$SAFE_ROOT$$OBJECTS_VERSION));

// jetzt Bezugsobjekt speichern
	RETURN_FAILED_HRESULT(WPersistStreamInit(m_BaseUnk) -> Save (pStm, fClearDirty));

#pragma TODO("Eigene persistente Daten speichern (s. Load).")

	if (fClearDirty)
		m_fIsDirty = false;
	return S_OK;
}

STDMETHODIMP C$$safe_root$$Objects::GetSizeMax (ULARGE_INTEGER *pcbSize)
{
	if (NULL == pcbSize)
		return E_POINTER;

	RETURN_FAILED_HRESULT(WPersistStreamInit(m_BaseUnk) -> GetSizeMax (pcbSize));
	pcbSize -> QuadPart += 2*sizeof(long);		// Signatur und Version

#pragma TODO("Speicherbedarf der eigenen persistenten Daten berechnen.")
//	pcbSize -> QuadPart += ...;
	return S_OK;
}

//////////////////////////////////////////////////////////////
// IPersistStreamInit

STDMETHODIMP C$$safe_root$$Objects::InitNew (void)
{
	if (m_fIsInitialized)
		return E_UNEXPECTED;

	COM_TRY {
	// jetzt fertig initialiseren
		THROW_FAILED_HRESULT(WPersistStreamInit(m_BaseUnk) -> InitNew());

#pragma TODO("Fertig initialisieren.")

	} COM_CATCH;

	m_fIsDirty = false;	
	m_fIsInitialized = true;
	return S_OK;
}
$$ENDIF // IF(EMIT_PERSISTSTREAM_OBJECTS)

