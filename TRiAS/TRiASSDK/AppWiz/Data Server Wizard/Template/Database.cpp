// $Header: $
// Copyright© 1998-$$year$$ $$company$$, All rights reserved
// Created: $$date_n_time$$
//
// This file was generated by the TRiASDB Data Server Wizard $$this_version$$
//
$$IF(EMIT_WARRANTIES)
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY 
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR 
// PURPOSE.
//
$$ENDIF // EMIT_WARRANTIES
// @doc 
// @module $$root$$Database.cpp | Datenbankobjekt TRiASDB Data Server $$root$$

#include "stdafx.h"

#include <float.h>

#include "Version.h"
#include "Strings.h"

#include "$$root$$.h"
#include "$$root$$Database.h"

///////////////////////////////////////////////////////////////////////////////
// C$$safe_root$$Database

STDMETHODIMP C$$safe_root$$Database::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITRiASDatabase,
		&IID_ITRiASPropertyBase,
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

HRESULT C$$safe_root$$Database::FinalConstruct (void)
{
	return S_OK;
}

void C$$safe_root$$Database::FinalRelease()
{
}

///////////////////////////////////////////////////////////////////////////////
// ITRiASBase
STDMETHODIMP C$$safe_root$$Database::get_Application (IDispatch **pVal)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	CHECKOUTPOINTER(pVal);

WDispatch disp (m_Application);

	*pVal = disp.detach();
	return S_OK;
}

STDMETHODIMP C$$safe_root$$Database::put_Application (IDispatch *newVal)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	m_Application = newVal;
	return S_OK;
}

STDMETHODIMP C$$safe_root$$Database::get_Parent (IDispatch **pVal)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	CHECKOUTPOINTER(pVal);

WDispatch disp (m_Parent);

	*pVal = disp.detach();
	return S_OK;
}

STDMETHODIMP C$$safe_root$$Database::put_Parent (IDispatch *newVal)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	m_Parent = newVal;
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// ITRiASDatabase
STDMETHODIMP C$$safe_root$$Database::get_Handle (INT_PTR *pVal)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	CHECKOUTPOINTER(pVal);
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED);

	*pVal = reinterpret_cast<INT_PTR>(this);
	return S_OK;
}

STDMETHODIMP C$$safe_root$$Database::get_IsDirty (VARIANT_BOOL *pVal)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	CHECKOUTPOINTER(pVal);
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED);

	*pVal = m_fIsDirty ? VARIANT_TRUE : VARIANT_FALSE;
	return S_OK;
}

STDMETHODIMP C$$safe_root$$Database::put_IsDirty (VARIANT_BOOL newVal)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED);

	m_fIsDirty = newVal ? true : false;
	return S_OK;
}

STDMETHODIMP C$$safe_root$$Database::get_OpenedAsCopy (VARIANT_BOOL * pVal)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	CHECKOUTPOINTER(pVal);
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED);
		
	*pVal = VARIANT_FALSE;
	return S_OK;
}

STDMETHODIMP C$$safe_root$$Database::get_CouldOpenTarget (VARIANT_BOOL * pVal)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	CHECKOUTPOINTER(pVal);
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED);
		
	*pVal = VARIANT_FALSE;
	return S_OK;
}

STDMETHODIMP C$$safe_root$$Database::get_SchemaUpdatable (VARIANT_BOOL * pVal)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	CHECKOUTPOINTER(pVal);
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED);
		
#if defined(_READWRITE)
#pragma TODO("get_SchemaUpdatable muß VARIANT_TRUE liefern, wenn die Struktur der Datenquelle modifizierbar ist.")
#endif // defined(_READWRITE)

	*pVal = VARIANT_FALSE;
	return S_OK;
}

STDMETHODIMP C$$safe_root$$Database::get_Name (BSTR *pVal)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	CHECKOUTPOINTER(pVal);
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED);

CComBSTR bstrName (m_bstrName);

	if (!bstrName)
		return E_OUTOFMEMORY;

	*pVal = bstrName.Detach();
	return S_OK;
}

STDMETHODIMP C$$safe_root$$Database::get_Version (BSTR * pVal)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	CHECKOUTPOINTER(pVal);
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED);

char cbBuffer[64];

	wsprintf (cbBuffer, "%d.%02d", $$SAFE_ROOT$$_VERSION_MAJOR, $$SAFE_ROOT$$_VERSION_MINOR);

CComBSTR bstrVersion (cbBuffer);

	*pVal = bstrVersion.Detach();
	return S_OK;
}

STDMETHODIMP C$$safe_root$$Database::get_VersionLong (LONG *pVal)
{
	CHECKOUTPOINTER(pVal);
	*pVal = $$SAFE_ROOT$$_VERSION_MAJOR*100 + $$SAFE_ROOT$$_VERSION_MINOR;
	return S_OK;
}

STDMETHODIMP C$$safe_root$$Database::get_CollatingOrder (LONG * pVal)
{
	CHECKOUTPOINTER(pVal);
	return E_NOTIMPL;
}

STDMETHODIMP C$$safe_root$$Database::get_Connect (BSTR * pVal)
{
	CHECKOUTPOINTER(pVal);
	return E_NOTIMPL;
}

STDMETHODIMP C$$safe_root$$Database::get_Transactions (VARIANT_BOOL * pVal)
{
	CHECKOUTPOINTER(pVal);

#pragma TODO("get_Transactions muß VARIANT_TRUE liefern, wenn Transaktionen unterstützt werden.")
	*pVal = VARIANT_FALSE;
	return S_OK;
}

STDMETHODIMP C$$safe_root$$Database::get_Updatable (VARIANT_BOOL * pVal)
{
	CHECKOUTPOINTER(pVal);

$$IF(READ_WRITE)
#if defined(_READWRITE)
	*pVal = VARIANT_TRUE;
#else
	*pVal = VARIANT_FALSE;
#endif // defined(_READWRITE)
$$ELSE
	*pVal = VARIANT_FALSE;
$$ENDIF
	return S_OK;
}

STDMETHODIMP C$$safe_root$$Database::get_Temporary (VARIANT_BOOL * pVal)
{
	CHECKOUTPOINTER(pVal);
	return E_NOTIMPL;
}

STDMETHODIMP C$$safe_root$$Database::put_Temporary (VARIANT_BOOL pVal)
{
	return E_NOTIMPL;
}

STDMETHODIMP C$$safe_root$$Database::get_TemporaryName (BSTR * pVal)
{
	return get_Name (pVal);
}

STDMETHODIMP C$$safe_root$$Database::get_Type (BSTR * pVal)
{
	CHECKOUTPOINTER(pVal);
		
// ProgID des zugehörigen Datenbankobjektes
CComBSTR bstr (g_cbDatabase);

	*pVal = bstr.Detach();
	return S_OK;
}

STDMETHODIMP C$$safe_root$$Database::get_StorageMode (DATABASESTORAGEMODE * pVal)
{
	CHECKOUTPOINTER(pVal);

$$IF(NAME_IS_FILE)
	*pVal = DATABASESTORAGEMODE_FileBased;
$$ELIF(NAME_IS_DIR)
	*pVal = DATABASESTORAGEMODE_DirectoryBased;
$$ELSE
	*pVal = DATABASESTORAGEMODE_MemoryBased;
$$ENDIF
	return S_OK;
}

STDMETHODIMP C$$safe_root$$Database::CreateDatabase (BSTR Name, BSTR Locale, BSTR Source)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)
$$IF(READ_WRITE)

#if defined(_READWRITE)
#pragma TODO("CreateDatabase erzeugt eine neue Datenquelle.")
#endif // defined(_READWRITE)

	return E_NOTIMPL;
$$ELSE
	return TRIASDB_E_DATABASENOTUPDATABLE;
$$ENDIF
}

STDMETHODIMP C$$safe_root$$Database::CreateDatabaseFromFiles (IUnknown * FileNames, BSTR Locale, BSTR Source)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	return E_NOTIMPL;
}

STDMETHODIMP C$$safe_root$$Database::CreateDatabaseOnStg (IUnknown *pIUnk, BSTR Name, BSTR Locale, BSTR Source)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	return E_NOTIMPL;
}

STDMETHODIMP C$$safe_root$$Database::OpenDatabase (
	BSTR Name, VARIANT_BOOL Exclusive, VARIANT_BOOL fReadOnly, VARIANT_BOOL ModTrack, BSTR Source)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

$$IF(READ_WRITE)
#if !defined(_READWRITE)
$$ENDIF
	_ASSERTE(fReadOnly);		// darf nur schreibgeschützt geöffnet werden
	if (!fReadOnly)
	{
		RETURN_FAILED_HRESULT(E_INVALIDARG);
	}
$$IF(READ_WRITE)
#endif // !defined(_READWRITE)
$$ENDIF

	COM_TRY {
#pragma TODO("OpenDatabase öffnet eine existierende Datenquelle.")

	// neue PropertiesCollection anlegen und initialisieren
		THROW_FAILED_HRESULT(CreatePropertiesCollection());		// --> $$root$$PropertyBase.h

	// KoordinatenSystemService erzeugen und initialisieren
		THROW_FAILED_HRESULT(InitCoordSystemService());

		m_fOpened = true;		// jetzt geöffnet

	} COM_CATCH;
	return S_OK;
}

STDMETHODIMP C$$safe_root$$Database::OpenFilesAsDatabase (
	IUnknown * FileNames, VARIANT_BOOL Exclusive, VARIANT_BOOL ReadOnly, VARIANT_BOOL ModTrack, BSTR Source)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	return E_NOTIMPL;
}

STDMETHODIMP C$$safe_root$$Database::OpenStorageAsDatabase(
	IUnknown *pIUnk, VARIANT_BOOL Exclusive, VARIANT_BOOL fReadOnly, VARIANT_BOOL ModTrack, BSTR Source)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	return E_NOTIMPL;
}

STDMETHODIMP C$$safe_root$$Database::Save()
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)
$$IF(READ_WRITE)
#if defined(_READWRITE)
#pragma TODO("Save speichert die Änderungen der Datenquelle.")

	return E_NOTIMPL;
#else
	return TRIASDB_E_DATABASENOTUPDATABLE;
#endif // defined(_READWRITE)
$$ELSE
	return TRIASDB_E_DATABASENOTUPDATABLE;
$$ENDIF
}

STDMETHODIMP C$$safe_root$$Database::SaveAs (BSTR NewName)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)
$$IF(READ_WRITE)
#if defined(_READWRITE)
#pragma TODO("Save speichert die Änderungen der Datenquelle unter einem neuen Namen.")

	return E_NOTIMPL;
#else
	return TRIASDB_E_DATABASENOTUPDATABLE;
#endif // defined(_READWRITE)
$$ELSE
	return TRIASDB_E_DATABASENOTUPDATABLE;
$$ENDIF
}

STDMETHODIMP C$$safe_root$$Database::Close()
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED);

	COM_TRY {
	// alle Objekte abhängen (_vor_ FreePropertiesCollection, da sonst neue Coll erzeugt wird)
		if (m_ObjectsDefs.IsValid()) {
		// nur, wenn Collection bereits erzeugt worden ist
			m_ObjectsDefs -> put_Parent (NULL);
			m_ObjectsDefs.Assign(NULL);
		}
		
	// alles freigeben
		ShutdownCoordSystemService();
		ReleasePropertySupportObjects();		// --> $$root$$PropertySupport.h
		FreePropertiesCollection();				// --> $$root$$PropertyBase.h

		m_bstrName.Empty();

#pragma TODO("Close schließt die Datenquelle ohne nochmals zu speichern.")
		m_fOpened = false;

	} COM_CATCH;
	return S_OK;
}

STDMETHODIMP C$$safe_root$$Database::BeginTrans()
{
	return E_NOTIMPL;
}

STDMETHODIMP C$$safe_root$$Database::ClearModificationLog(LONG Entry)
{
	return E_NOTIMPL;
}

STDMETHODIMP C$$safe_root$$Database::CommitTrans()
{
	return E_NOTIMPL;
}

STDMETHODIMP C$$safe_root$$Database::Rollback()
{
	return E_NOTIMPL;
}

STDMETHODIMP C$$safe_root$$Database::ReLoad (RELOADDATABASE rgWhat)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

HRESULT hr = S_OK;

	if (RELOADDATABASE_All == rgWhat) {
	// alles neu einlesen
		RETURN_FAILED_HRESULT(OnReLoadObjects());
		RETURN_FAILED_HRESULT(OnReLoadEnvelope());

	} else switch (rgWhat) {
	case RELOADDATABASE_Envelope:
		hr = OnReLoadEnvelope();
		break;

	case RELOADDATABASE_Objects:
		hr = OnReLoadObjects();
		break;
	}
	return hr;
}

HRESULT C$$safe_root$$Database::OnReLoadObjects()
{
#pragma TODO("Sämtliche Objektklassen neu einlesen")
	return S_OK;
}

HRESULT C$$safe_root$$Database::OnReLoadEnvelope()
{
#pragma TODO("Umschließendes Rechteck der Datenquelle neu einlesen")
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// Auffrischen mit den Änderungen aus der Datenquelle
STDMETHODIMP C$$safe_root$$Database::RefreshChangesFromModificationLog (
	ITRiASRefreshChangesCallback *pICallback)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	CHECKINPOINTER(pICallback);
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED)

	return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////////
// ITRiASAccessDatabase

// liefert die Sammlung aller Objektklassen dieser Datenquelle
STDMETHODIMP C$$safe_root$$Database::get_ObjectsDefs (ITRiASObjectsCollection **pVal)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	CHECKOUTPOINTER(pVal);
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED)

// wenn die Collection bereits existiert, dann lediglich diese zurückliefern
	if (m_ObjectsDefs.IsValid()) 
		return LPUNKNOWN(*pVal = m_ObjectsDefs) -> AddRef(), S_OK;

// ansonsten neu erzeugen
	return EnsureObjectsDefs (pVal);
}

HRESULT C$$safe_root$$Database::EnsureObjectsDefs (ITRiASObjectsCollection **pVal)
{
	_ASSERTE(!m_ObjectsDefs.IsValid());
	COM_TRY {
	WTRiASObjectsCollection ObjsColl (CLSID_$$safe_root$$ObjectsCollection);

		THROW_FAILED_HRESULT(ObjsColl -> put_Application(m_Application));
		THROW_FAILED_HRESULT(ObjsColl -> put_Parent(GetDispatch()));

#pragma TODO("ObjsColl mit allen Objektklassen dieser Datenquelle füllen.")

$$IF(EMIT_SAMPLE_CODE)
	// BEGIN_SAMPLE_CODE
		using namespace sample_data;

	CComBSTR bstrGeometry(g_cbGeometry);
	CComBSTR bstrPrimFeature(g_cbObjektname);

		for (int i = 0; i < g_iObjectClassCount; i++) {
		// Objektklasse instantiieren
		const OBJECTCLASS *pClass = g_ObjectClasses[i];
		WTRiASObjects Objs (CLSID_$$safe_root$$Objects);

		// Objektklasse fertig initialisieren
			THROW_FAILED_HRESULT(WPersistStreamInit(Objs) -> InitNew());
			THROW_FAILED_HRESULT(Objs -> put_Application (m_Application));
			THROW_FAILED_HRESULT(Objs -> put_Parent (GetDispatch()));

		// Namen etc. dieser Objektklasse festlegen
			THROW_FAILED_HRESULT(Objs -> put_Name (CComBSTR(pClass -> m_pcoleName)));
			THROW_FAILED_HRESULT(Objs -> put_Description (CComBSTR(pClass -> m_pcoleDescription)));
			THROW_FAILED_HRESULT(Objs -> put_OKS (CComBSTR(pClass -> m_pcoleOKS)));

		// Typen der Objektklasse setzen
			THROW_FAILED_HRESULT(Objs -> put_CollectionType(OBJECTSCOLLECTIONTYPE_Class));
			THROW_FAILED_HRESULT(Objs -> put_Types(pClass -> m_rgTypes));
$$IF(READ_WRITE)
#if defined(_READWRITE)
			THROW_FAILED_HRESULT(Objs -> put_Updatable(VARIANT_TRUE));		// diese Datenquelle ist beschreibbar
#else
			THROW_FAILED_HRESULT(Objs -> put_Updatable(VARIANT_FALSE));		// diese Datenquelle ist schreibgeschützt
#endif // defined(_READWRITE)
$$ELSE
			THROW_FAILED_HRESULT(Objs -> put_Updatable(VARIANT_FALSE));		// diese Datenquelle ist schreibgeschützt
$$ENDIF

		// Namen der Standard-Objekteigenschaften (Geometrie und Normal) setzen
			THROW_FAILED_HRESULT(Objs -> put_DefaultGeometry (bstrGeometry));
			THROW_FAILED_HRESULT(Objs -> put_PrimaryKey (bstrPrimFeature));

		// an der erzeugten Objektklasse unsere Nummer (cursor) speichern
			THROW_FAILED_HRESULT(SetPropertyBy (Objs, g_cbObjectsCursor, CComVariant(i+1), true));

		// die neu instantiierte Objektklasse zur Menge der Objektklassen hinzufügen
			THROW_FAILED_HRESULT(ObjsColl -> _Add (Objs, VARIANT_TRUE));
		}
	// END_SAMPLE_CODE
$$ELSE
//		WTRiASObjects Objs;
//
//			for (... jede existierende Objektklasse in Objs ...) {
//		
//				ObjsColl -> _Add (Objs, VARIANT_TRUE);
//			}
$$ENDIF

		m_ObjectsDefs = ObjsColl;
		if (NULL != pVal)
			*pVal = ObjsColl.detach();

	} COM_CATCH;
	return S_OK;
}

// liefert bzw. erzeugt eine neue Objektklasse dieser Datenquelle
STDMETHODIMP C$$safe_root$$Database::get_ObjectsDef(
	VARIANT vItem, VARIANT_BOOL fCreate, BSTR Type, ITRiASObjects **pIObjDef)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	CHECKOUTPOINTER(pIObjDef);
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED)

	if (!m_ObjectsDefs.IsValid())
	{
		RETURN_FAILED_HRESULT(EnsureObjectsDefs());
	}
	_ASSERTE(m_ObjectsDefs.IsValid());

HRESULT hr = m_ObjectsDefs -> Item (vItem, pIObjDef);

	if (TRIASDB_E_UNKNOWN_OBJECTS == hr && fCreate) {	// evtl. neu erzeugen
	CComVariant v;

		hr = v.ChangeType (VT_BSTR, &vItem);
		if (SUCCEEDED(hr)) {
		CIID ClsId (Type, CIID::INITCIID_InitFromProgId);

			if (!ClsId)	
				hr = m_ObjectsDefs -> Add (V_BSTR(&v), CComBSTR(g_cbNil), pIObjDef);	// default type verwenden
			else
				hr = m_ObjectsDefs -> Add (V_BSTR(&v), CComBSTR(ClsId.ProgID().c_str()), pIObjDef);
			if (S_OK == hr) hr = S_FALSE;				// Objektmenge wurde neu erzeugt
		}
	}
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// Umschließenden Datenbank-Container liefern
STDMETHODIMP C$$safe_root$$Database::get_Envelope (ENVELOPETYPE rgType, IDispatch **pVal)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	CHECKOUTPOINTER(pVal);
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED)

	COM_TRY {
	// Koordinaten deskalieren
	double dXMin = DBL_MAX, dYMin = DBL_MAX, dXMax = -DBL_MAX, dYMax = -DBL_MAX;

#pragma TODO("Umschließendes Rechteck aller Objekte der Datenquelle bestimmen.")
$$IF(EMIT_SAMPLE_CODE)
	// BEGIN_SAMPLE_CODE
		using namespace sample_data;

		dXMin = g_Container.m_pdX[0];
		dYMin = g_Container.m_pdY[0];
		dXMax = g_Container.m_pdX[1];
		dYMax = g_Container.m_pdY[1];
	// END_SAMPLE_CODE
$$ELSE
//		dXMin = ...;
//		dYMin = ...;
//		dXMax = ...;
//		dYMax = ...;
$$ENDIF

	// CS-Transformator besorgen
	WTRiASCSTransform CST (GetPropertyFrom (GetDispatch(), g_cbTRiASCSTransform, (IDispatch *)NULL), false);

		_ASSERTE(CST.IsValid());

	// Container der Datenquelle setzen
	WTRiASSimpleRectangle Rect (CLSID_TRiASCSRectangleGeometry);
	
		THROW_FAILED_HRESULT(WPersistStreamInit(Rect) -> InitNew());
		THROW_FAILED_HRESULT(Rect -> SetRect (dXMin, dYMin, dXMax, dYMax));
		THROW_FAILED_HRESULT(WTRiASTransformGeometry(Rect) -> Transform ((CSID &)m_CtfGuid, CST));
		*pVal = Rect.detach();

	} COM_CATCH;
	return S_OK;
}

STDMETHODIMP C$$safe_root$$Database::get_ObjectCount (long *pVal)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	CHECKOUTPOINTER(pVal);
	ERROR_EXPR_TRUE(!IsOpened(), TRIASDB_E_DATABASE_NOT_OPENED)

$$IF(EMIT_SAMPLE_CODE)
// BEGIN_SAMPLE_CODE
	using namespace sample_data;
	*pVal = g_iObjectCount;
// END_SAMPLE_CODE
$$ELSE
#pragma TODO("Anzahl der Objekte der Datenquelle bestimmen.")
//	*pVal = ...;
$$ENDIF
	return S_OK;
}

STDMETHODIMP C$$safe_root$$Database::get_AttachedCS(BSTR bstrDbName, BSTR *AssocCS)
{
	return E_NOTIMPL;
}

STDMETHODIMP C$$safe_root$$Database::get_ConnectionFilter(ITRiASConnectionFilter **ppIGeom)
{
	return E_NOTIMPL;
}

STDMETHODIMP C$$safe_root$$Database::put_ConnectionFilter(ITRiASConnectionFilter *pIGeom)
{
	return E_NOTIMPL;
}

STDMETHODIMP C$$safe_root$$Database::get_Views (ITRiASViews **pVal)
{
	return E_NOTIMPL;
}

STDMETHODIMP C$$safe_root$$Database::get_StartViewName (BSTR *pVal)
{
	return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////////
// Koordinatensystem neu initialisieren
HRESULT C$$safe_root$$Database::InitCoordSystemService()
{
	COM_TRY {
	// CTF-Service holen/initialisieren
	WTRiASProperties Props (GetProperties());
	WTRiASCSTransform CST (GetProperty (Props, g_cbTRiASCSTransform, (IDispatch *)NULL), false);

		if (!CST.IsValid()) {
		// neuen CTF-Service erzeugen und am Objekt ablegen
		CIID CTFGuid;	// Guid vergeben

			CST = WTRiASCSTransform(CLSID_TRiASCSTransform);

#pragma TODO("Konkretes Koordinatensystem erzeugen und entsprechend Daten initialisieren.")

		WTRiASCS CS (CLSID_TRIASCS);	

$$IF(EMIT_SAMPLE_CODE)
		// BEGIN_SAMPLE_CODE
		// Der hier behandelte Fall setzt vorraus, daß alle Objektklassen dieser
		// Datenquelle in ein und dem selben Koordinatensystem vorliegen.
		// Sollte jede Objektklasse ein eigenes Koordinatensystem besitzen (können),
		// dann muß die hier gezeigte Initialisierung des Koordinatensystemes (TRiASCS)
		// an die jeweiligen C$$safe_root$$Objects -Objekte verlegt werden. Wichtig ist jedoch, 
		// daß das TRiASCSTransform Objekt, wie hier implementiert am C$$safe_root$$Database
		// Objekt als Property verbleibt.

		// hier: WGS84 geodätisch (ohne Projektion) annehmen
			THROW_FAILED_HRESULT(CS -> put_CoordSystemType(tcsCS_Geographic));		// Typ des CoordSystems setzen

		// Geodätische Grundlage initialisieren
			{
			WTRiASCSGCS GCS;

				THROW_FAILED_HRESULT(CS -> get_GeographicCS(GCS.ppi()));
				THROW_FAILED_HRESULT(GCS -> put_GeodeticDatum(tcsGD_WorldGeodeticSystem1984));
				THROW_FAILED_HRESULT(GCS -> put_PrimeMeridian(tcsPM_Greenwich));
				THROW_FAILED_HRESULT(GCS -> put_UnitOfAngle(tcsUOA_Second));
			}

		// Datumsparameter einstellen
			{
			WTRiASCSDatumTransformation DTrans;

				THROW_FAILED_HRESULT(CS -> get_DatumTransformation(DTrans.ppi()));
				THROW_FAILED_HRESULT(DTrans -> put_GeodeticDatum(tcsGD_WorldGeodeticSystem1984));
				THROW_FAILED_HRESULT(DTrans -> put_TransformationAlgorithm(tcsDTA_PositionVector7ParamTransformation));
			}

			THROW_FAILED_HRESULT(CS -> put_GUID (CComBSTR(CTFGuid)));	// Guid zuordnen

		// CS-Guid an der Datenbank speichern
			THROW_FAILED_HRESULT(SetProperty (Props, g_cbCSSGuid, CComBSTR(os_string(CTFGuid).c_str()), true));
		// END_SAMPLE_CODE
$$ENDIF

		// dieses Koordinatensystem als InputCS zum Transformator hinzufügen
			THROW_FAILED_HRESULT(CST -> AddInputCS (CS));
			m_CtfGuid = CTFGuid;			// Guid des Koordinatensystems hier speichern

		// als Property an der Datenbank speichern
			THROW_FAILED_HRESULT(SetProperty (Props, g_cbTRiASCSTransform, CComVariant(CST), true));
		}

	// Ausgabesystem von der Connection holen (hat sich u.U. geändert) und an unserem Transformator
	// setzen
	WTRiASConnection Conn;

		THROW_FAILED_HRESULT(FindSpecificParent (m_Parent, Conn.ppi()));

	WTRiASCS CSOut (GetPropertyFrom (WTRiASPropertyBase(Conn), g_cbTRiASCSService, (IDispatch *)NULL), false);

		_ASSERTE(CSOut.IsValid());	// muß bereits existieren
		THROW_FAILED_HRESULT(CST -> putref_OutputCS (CSOut));
		THROW_FAILED_HRESULT(CSOut -> Recompute());		// TransformationsPfad neu berechnen

	} COM_CATCH;
	return S_OK;
}

// Koordinatensystem freigeben
HRESULT C$$safe_root$$Database::ShutdownCoordSystemService()
{
	COM_TRY {
	WTRiASCSTransform CST (GetProperty (GetProperties(), g_cbTRiASCSTransform, (IDispatch *)NULL), false);

		ERROR_EXPR_TRUE(!CST.IsValid(), E_UNEXPECTED);
		THROW_FAILED_HRESULT(CST -> ShutDown());
	} COM_CATCH;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// OleItemContainerSupport
// nach einer bestimmten Objektklasse fragen
HRESULT C$$safe_root$$Database::GetObjectsDef (
	LPCTSTR pcItem, DWORD dwSpeedNeeded, REFIID riid, LPVOID *ppvObj, bool fTestRunningOnly)
{
	if (!m_ObjectsDefs) {
		if (BINDSPEED_IMMEDIATE == dwSpeedNeeded)
			return MK_E_EXCEEDEDDEADLINE;

	// evtl. Neuerzeugen der benötigten Collection
	WTRiASObjectsCollection Coll;

		RETURN_FAILED_HRESULT(get_ObjectsDefs (Coll.ppi()));	// fills in m_ObjectsDefs
	}
	_ASSERTE(m_ObjectsDefs.IsValid());

HRESULT hr = S_OK;

	COM_TRY {
	WTRiASObjects Objs;
		
		hr = m_ObjectsDefs -> Item (CComVariant(pcItem), Objs.ppi());
		if (TRIASDB_E_UNKNOWN_OBJECTS == hr && !fTestRunningOnly) {
		// Objektklasse ist neu und muß erzeugt werden
			if (BINDSPEED_IMMEDIATE == dwSpeedNeeded)
				return MK_E_EXCEEDEDDEADLINE;
			hr = m_ObjectsDefs -> Add (CComBSTR(pcItem), CComBSTR("TRiASDB.$$safe_root$$Objects.1"), Objs.ppi());
		}

		if (SUCCEEDED(hr) && !fTestRunningOnly && NULL != ppvObj)	// Objektklasse ist (jetzt) bekannt
		{
			_ASSERTE(Objs.IsValid());
			THROW_FAILED_HRESULT(Objs -> QueryInterface (riid, ppvObj));
		}
	} COM_CATCH;
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// nach einem bestimmten Objekt fragen
HRESULT C$$safe_root$$Database::GetObjectDef (
	LPCTSTR pcItem, DWORD dwSpeedNeeded, REFIID riid, LPVOID *ppvObj, bool fTestRunningOnly)
{
	if (BINDSPEED_IMMEDIATE == dwSpeedNeeded)	// muß immer in der eigentlichen Datenbank gesucht werden
		return MK_E_EXCEEDEDDEADLINE;

	COM_TRY {
#pragma TODO("Objekt anhand des übergenenen Displaynames wiederfinden.")

	} COM_CATCH;
	return S_OK;
}

// DisplayName parsen und Moniker liefern
HRESULT C$$safe_root$$Database::ParseObjectsDef (
	LPCTSTR pcItem, ULONG ulSkipped, ULONG *pulEaten, IMoniker **ppmkOut)
{
CComBSTR bstrItem(pcItem);

	RETURN_FAILED_HRESULT(CreateItemMoniker (g_cbMkDel, bstrItem, ppmkOut));
	*pulEaten += bstrItem.Length();
	return S_OK;
}

HRESULT C$$safe_root$$Database::ParseObjectDef (
	LPCTSTR pcItem, ULONG ulSkipped, ULONG *pulEaten, IMoniker **ppmkOut)
{
CComBSTR bstrItem(pcItem);

	RETURN_FAILED_HRESULT(CreateItemMoniker (g_cbMkDel, bstrItem, ppmkOut));
	*pulEaten += bstrItem.Length();
	return S_OK;
}

