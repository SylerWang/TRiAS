// $Header: $
// Copyright© 1998-$$year$$ $$company$$, All rights reserved
// Created: $$date_n_time$$ 
//
// This file was generated by the TRiASDB Data Server Wizard $$this_version$$
//
$$IF(EMIT_WARRANTIES)
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY 
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR 
// PURPOSE.
//
$$ENDIF // EMIT_WARRANTIES
// @doc
// @module $$root$$Features.cpp | Implementation of the <c C$$safe_root$$Features> class

#include "stdafx.h"

#include "Strings.h"

#include "$$root$$.h"
#include "$$root$$Features.h"

#if defined(_DEBUG)
#if defined(_MFC_VER)
#define new DEBUG_NEW
#endif // defined(_MFC_VER)
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// C$$safe_root$$Features

STDMETHODIMP C$$safe_root$$Features::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITRiASFeatures,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// ITRiASFeaturesCallback

STDMETHODIMP C$$safe_root$$Features::get_DefaultType (BSTR *pbstrType)
{
	CHECKOUTPOINTER(pbstrType);

CIID Guid (CLSID_$$safe_root$$Feature);			// DefaultType der _Elemente_ (hier Feature)!
CComBSTR bstrType (Guid.ProgID().c_str());

	*pbstrType = bstrType.Detach();
	return S_OK;
}

// eine neue Objekteigenschaft soll erzeugt werden
STDMETHODIMP C$$safe_root$$Features::OnCreate (VARIANT Name, BSTR Type, FEATURETYPE rgType, ITRiASFeature **ppIFeat)
{
	CHECKOUTPOINTER(ppIFeat);
$$IF(READ_WRITE)
#if defined(_READWRITE)
	COM_TRY {
	// jetzt wirklich erzeugen
	CIID ClsId (Type, CIID::INITCIID_InitFromProgId);

		if (!ClsId)	ClsId = CLSID_$$safe_root$$Feature;	// default ClsId
	
	WTRiASFeature Feat (ClsId);

		THROW_FAILED_HRESULT(WPersistStreamInit(Feat) -> InitNew());

	CComVariant vVal (Name);

		THROW_FAILED_HRESULT(vVal.ChangeType (VT_BSTR));

#pragma TODO("Neue Objekteigenschaft entsprechend Typ (rgType) in 'Feat' erzeugen und initialisieren.")

		THROW_FAILED_HRESULT(Feat -> put_Name(V_BSTR(&vVal)));
		THROW_FAILED_HRESULT(Feat -> put_Type(rgType));

	// wenn Feature bereits zu dieser Attributmenge gehört, dann liefert _Add den Wert S_FALSE
		THROW_FAILED_HRESULT(WTRiASFeatures(m_BaseUnk) -> _Add (Feat, VARIANT_TRUE));
		*ppIFeat = Feat.detach();	// neue Objekteigenschaft liefern

	} COM_CATCH;
	return S_OK;
#else
	return TRIASDB_E_OBJECTSNOTUPDATABLE;
#endif
$$ELSE
	return TRIASDB_E_OBJECTSNOTUPDATABLE;
$$ENDIF
}

STDMETHODIMP C$$safe_root$$Features::OnChanging(CHANGEDFEATURES rgWhat, VARIANT vNewValue, VARIANT_BOOL *pDisAllow)
{
	CHECKOUTPOINTER(pDisAllow);

$$IF(READ_WRITE)
#if defined(_READWRITE)
	*pDisAllow = VARIANT_FALSE;		// immer einverstanden sein
	return S_OK;
#else
	*pDisAllow = VARIANT_TRUE;		// nie einverstanden sein
	return TRIASDB_E_OBJECTSNOTUPDATABLE;
#endif
$$ELSE
	*pDisAllow = VARIANT_TRUE;		// verhindert Modifikation (rgWhat siehe OnChanged)
	return TRIASDB_E_OBJECTSNOTUPDATABLE;
$$ENDIF
}

// Irgend was wurde modifiziert
STDMETHODIMP C$$safe_root$$Features::OnChanged(CHANGEDFEATURES rgWhat, VARIANT vOldValue)
{
	return S_OK;
}

// Objekt wird logisch freigegeben
STDMETHODIMP C$$safe_root$$Features::OnFinalRelease()
{
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Eine Objekteigenschaftsbeschreibung soll gelöscht werden
STDMETHODIMP C$$safe_root$$Features::OnDelete (VARIANT vWhich)
{
$$IF(READ_WRITE)
#if defined(_READWRITE)
#pragma TODO("Gegebenenfalls Objekteigenschaft aus Datenquelle löschen.")

	// S_OK:	Objekteigenschaft wurde gelöscht
	// ansonsten Fehlercode
	return S_OK;
#else
	return TRIASDB_E_OBJECTSNOTUPDATABLE;
#endif
$$ELSE
	return TRIASDB_E_OBJECTSNOTUPDATABLE;
$$ENDIF
}

STDMETHODIMP C$$safe_root$$Features::SetupFeatures(IDispatch *pIParent, SETUPFEATURESMODE rgSetupMode)
{
// Der Parameter pIParent enthält einen Zeiger auf das Bezugsobjekt (Objektklasse oder Objekt) für 
// welches die Objekteigenschaften erzeugt werden sollen
#pragma TODO("Sämtliche Objekteigenschaften instantiieren und zum Bezugsobjekt hinzufügen.")

	COM_TRY {
	WTRiASFeatures BaseFeats;

		THROW_FAILED_HRESULT(m_BaseUnk -> QueryInterface (BaseFeats.ppi()));

$$IF(EMIT_SAMPLE_CODE)
	// BEGIN_SAMPLE_CODE
		using namespace sample_data;

	// Diese Funktion wird sowohl für Objektklassen als auch für Einzelobjekte gerufen
	// (je nach Kontext).
	WTRiASObjects Objs;

		if (SUCCEEDED(pIParent -> QueryInterface (Objs.ppi()))) {
		// pIParent ist eine Objektklasse
		LONG lCursor (GetPropertyFrom (Objs, g_cbObjectsCursor, -1L));

			_ASSERTE(0 < lCursor);

		const OBJECTCLASS *pClass = g_ObjectClasses[lCursor-1];

			for (int i = 0; i < pClass -> m_iFeatDescCount; i++) {
			// ein Attribut instantiieren und zur Menge aller Attribute hinzufügen
				THROW_FAILED_HRESULT(SetupFeature (pIParent, BaseFeats, pClass -> m_iFeatDescs[i]));
			}

		} else {
		// pIParent muß ein Objekt sein
		WTRiASObject Obj;

			THROW_FAILED_HRESULT(pIParent -> QueryInterface (Obj.ppi()));

		// Objektnummer besorgen
		LONG lCursor (GetPropertyFrom (Objs, g_cbObjectsCursor, -1L));

			_ASSERTE(0 < lCursor);

		// auf Objektinfo zugreifen
		const OBJECT *pObject = g_Objects[lCursor-1];

			for (int i = 0; i < pObject -> m_iFeatureCount; i++) {
			// ein Attribut instantiieren und zur Menge aller Attribute hinzufügen
				THROW_FAILED_HRESULT(SetupFeature (pIParent, BaseFeats, pObject -> m_pFeatures[i].m_iFeatDesc));
			}
		}
	// END_SAMPLEDATA
$$ELSE
//		for (... jede existierende Objekteigenschaft in dieser Menge  ...) {
//		WTRiASFeature Feat (CLSID_$$safe_root$$Feature);
//		
//			THROW_FAILED_HRESULT(Feat -> put_Name (...));
//			...
//			RETURN_FAILED_HRESULT(BaseFeats -> _Add (Feat, VARIANT_TRUE));
//		}
$$ENDIF
	} COM_CATCH;
	return S_OK;
}

$$IF(EMIT_SAMPLE_CODE)
// BEGIN_SAMPLE_CODE
// ein Attribut instantiieren und zur Menge aller Attribute hinzufügen, dabei unbedingt darauf
// achten, daß Objekte nicht mehrfach erzeugt werden
HRESULT C$$safe_root$$Features::SetupFeature (
	IDispatch *pIParent, ITRiASFeatures *pIBaseFeats, int iFeatDesc)
{
	using namespace sample_data;

	_ASSERTE(0 <= iFeatDesc && iFeatDesc < g_iFeatDescCount);
	COM_TRY {
	// zuerst versuchen, dieses Feature in der Map wiederzufinden
	WTRiASDatabase DBase;

		THROW_FAILED_HRESULT(FindSpecificParent (pIParent, DBase.ppi()));

	// Der Beispielcode geht davon aus, daß sämtliche C$$safe_root$$Feature Objekte
	// in einer Map am C$$safe_root$$Database Objekt gespeichert werden (wird automatisch durch 
	// die Property "FeatureCursor" erledigt - s.a. Kommentar in der Datei '$$root$$CursorProperty.cpp').
	// Sollte diese Map an anderer Stelle gespeichert werden (z.B. an der betreffenden Objektklasse,
	// so muß auch die Map von dort geholt werden.
	WTRiASObjectHandleMap Map (GetPropertyFrom (DBase, g_cbFeatureMap, (IDispatch *)NULL), false);
	WTRiASFeature Feat;

		if (!Map.IsValid() || S_OK != Map -> GetObject (static_cast<INT_PTR>(iFeatDesc+1), Feat.ppu())) {
		// jetzt wirklich neu erzeugen
		const FEATUREDESC *pFeatDesc = &g_FeatDescs[iFeatDesc];

			Feat = WTRiASFeature(CLSID_$$safe_root$$Feature);		// Feature erzeugen

		// fertig initialisieren
			THROW_FAILED_HRESULT(WPersistStreamInit(Feat) -> InitNew());

		// Namen etc. setzen
			THROW_FAILED_HRESULT(Feat -> put_Parent (pIParent));
			THROW_FAILED_HRESULT(Feat -> put_Type (pFeatDesc -> m_rgType));
			THROW_FAILED_HRESULT(Feat -> put_Name (CComBSTR(pFeatDesc -> m_pcoleName)));
			THROW_FAILED_HRESULT(Feat -> put_Description (CComBSTR(pFeatDesc -> m_pcoleDescription)));

		// an dem erzeugten Attribut seine Nummer (cursor) speichern
			THROW_FAILED_HRESULT(SetPropertyBy (Feat, g_cbFeatureCursor, CComVariant(iFeatDesc+1), true));
		}
		
	// das neu instantiierte Attribut zu dieser Attributsammlung hinzufügen
		THROW_FAILED_HRESULT(pIBaseFeats -> _Add (Feat, VARIANT_TRUE));

	} COM_CATCH;
	return S_OK;
}
// END_SAMPLE_CODE
$$ENDIF
