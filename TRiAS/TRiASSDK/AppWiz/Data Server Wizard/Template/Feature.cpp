// $Header: $
// Copyright© 1998-$$year$$ $$company$$, All rights reserved
// Created: $$date_n_time$$ 
//
// This file was generated by the TRiASDB Data Server Wizard $$this_version$$
//
$$IF(EMIT_WARRANTIES)
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY 
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR 
// PURPOSE.
//
$$ENDIF // EMIT_WARRANTIES
// @doc
// @module $$root$$Feature.cpp | Implementation of the <c C$$safe_root$$Feature> class

#include "stdafx.h"

#include "Strings.h"

#include "$$root$$.h"
#include "$$root$$Feature.h"
$$IF(EMIT_SAMPLE_CODE)
$$IF(READ_WRITE)
// BEGIN_SAMPLE_CODE
#include "$$root$$PropertySupport.h"
// END_SAMPLE_CODE
$$ENDIF // $$IF(READ_WRITE)
$$ENDIF // $$IF(EMIT_SAMPLE_CODE)

#if defined(_DEBUG)
#if defined(_MFC_VER)
#define new DEBUG_NEW
#endif // defined(_MFC_VER)
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// C$$safe_root$$Feature

STDMETHODIMP C$$safe_root$$Feature::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITRiASFeature,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// ITRiASFeatureCallback
STDMETHODIMP C$$safe_root$$Feature::get_DefaultType (BSTR *pbstrType)
{
	CHECKOUTPOINTER(pbstrType);

CIID Guid (GetObjectCLSID());
CComBSTR bstrType (Guid.ProgID().c_str());

	*pbstrType = bstrType.Detach();
	return S_OK;
}

STDMETHODIMP C$$safe_root$$Feature::SetupFeature (SETUPFEATUREMODE rgMode)
{
	_ASSERTE(SETUPFEATUREMODE_InitOrLoad == rgMode);		// z.Zt nur dieses
$$IF(EMIT_SAMPLE_CODE)
$$IF(READ_WRITE)
// BEGIN_SAMPLE_CODE
	COM_TRY {
	// Properties zum aggregierten Objekt hinzufügen
	WTRiASPropertyMapHandler MapHandler(m_BaseUnk);

		THROW_FAILED_HRESULT(MapHandler -> AddMapEntry (
			CComBSTR(g_cbFeatureCursor), (INT_PTR)&CLSID_$$safe_root$$CursorProperty, PROPERTYSUPPORT_NOFLAGS, vtMissing));

	} COM_CATCH;
// END_SAMPLE_CODE
$$ENDIF // $IF(READ_WRITE)
$$ENDIF // $$IF(EMIT_SAMPLE_CODE)
	return S_OK;
}

STDMETHODIMP C$$safe_root$$Feature::OnChanging(CHANGEDFEATURE rgWhat, VARIANT vNewValue, VARIANT_BOOL *pDisAllow)
{
	CHECKOUTPOINTER(pDisAllow);

$$IF(READ_WRITE)
	*pDisAllow = VARIANT_FALSE;		// immer einverstanden sein
	return S_OK;
$$ELSE
	*pDisAllow = VARIANT_TRUE;		// verhindert Modifikation (rgWhat siehe OnChanged)
	return TRIASDB_E_OBJECTSNOTUPDATABLE;
$$ENDIF
}

STDMETHODIMP C$$safe_root$$Feature::OnChanged(CHANGEDFEATURE rgWhat, VARIANT vOldValue)
{
$$IF(READ_WRITE)
	switch (rgWhat) {
	case CHANGEDFEATURE_Name:
		return OnChangedName();

	case CHANGEDFEATURE_Description:
		return OnChangedDescription();

	case CHANGEDFEATURE_Handle:
		return OnChangedHandle();

	case CHANGEDFEATURE_ROMode:
		return OnChangedROMode();

	case CHANGEDFEATURE_Value:
		break;

	case CHANGEDFEATURE_Type:
		return OnChangedType();

	default:
		_ASSERTE(SUCCEEDED(E_INVALIDARG));
		break;
	}
	return E_INVALIDARG;
$$ELSE
	return TRIASDB_E_OBJECTSNOTUPDATABLE;
$$ENDIF
}

$$IF(READ_WRITE)
HRESULT C$$safe_root$$Feature::OnChangedName()
{
// neuen Namen vom Bezugsobjekt besorgen
CComBSTR bstrName;
WTRiASFeature BaseFeat;

	RETURN_FAILED_HRESULT(m_BaseUnk -> QueryInterface (BaseFeat.ppi()));
	RETURN_FAILED_HRESULT(BaseFeat -> get_Name(CLEARED(&bstrName)))

#pragma TODO("Neuen Name der Objekteigenschaft ggf. auswerten.")
	return S_OK;
}

HRESULT C$$safe_root$$Feature::OnChangedDescription()
{
// neue Beschreibung vom Bezugsobjekt besorgen
CComBSTR bstrDesc;
WTRiASFeature BaseFeat;

	RETURN_FAILED_HRESULT(m_BaseUnk -> QueryInterface (BaseFeat.ppi()));
	RETURN_FAILED_HRESULT(BaseFeat -> get_Description(CLEARED(&bstrDesc)))

#pragma TODO("Neue Beschreibung der Objekteigenschaft ggf. auswerten.")
	return S_OK;
}

HRESULT C$$safe_root$$Feature::OnChangedHandle()
{
	return S_OK;
}

HRESULT C$$safe_root$$Feature::OnChangedType()
{
// neuen Typ vom Bezugsobjekt besorgen
FEATURETYPE rgType = FEATURETYPE_Unknown;
WTRiASFeature BaseFeat;

	RETURN_FAILED_HRESULT(m_BaseUnk -> QueryInterface (BaseFeat.ppi()));
	RETURN_FAILED_HRESULT(BaseFeat -> get_Type(&rgType))

#pragma TODO("Neuen Typ der Objekteigenschaft ggf. auswerten.")
	return S_OK;
}

HRESULT C$$safe_root$$Feature::OnChangedROMode()
{
// neuen Schreibschutzmode vom Bezugsobjekt besorgen
VARIANT_BOOL fUpdatable = VARIANT_FALSE;
WTRiASFeature BaseFeat;

	RETURN_FAILED_HRESULT(m_BaseUnk -> QueryInterface (BaseFeat.ppi()));
	RETURN_FAILED_HRESULT(BaseFeat -> get_Updatable(&fUpdatable))

#pragma TODO("Neuen Schreibschutzmode der Objekteigenschaft ggf. auswerten.")
	return S_OK;
}

$$ENDIF
/////////////////////////////////////////////////////////////////////////////
// Eval: Das, worum es eigentlich geht: Wert der Objekteigenschaft abfragen
STDMETHODIMP C$$safe_root$$Feature::Eval(ITRiASObject *pIObj, VARIANT *pVal)
{
#pragma TODO("Wert der Objekteigenschaft bestimmen.")

	COM_TRY {
$$IF(EMIT_SAMPLE_CODE)
	// BEGIN_SAMPLE_CODE
	WTRiASFeature BaseFeat;

		THROW_FAILED_HRESULT(m_BaseUnk -> QueryInterface (BaseFeat.ppi()));
		using namespace sample_data;

	CComBSTR bstrVal;
	LONG lObjCursor = GetPropertyFrom (pIObj, g_cbObjectCursor, -1L);
	LONG lThisCursor = GetPropertyFrom (BaseFeat, g_cbFeatureCursor, -1L);

		_ASSERTE(0 < lObjCursor);
		_ASSERTE(0 < lThisCursor);

	// Objektdaten zuordnen und Attribut wiederfinden
	const OBJECT *pObject = g_Objects[lObjCursor-1];
	const FEATURE *pFeat = pObject -> m_pFeatures;
	bool fFound = false;

		for (int i = 0; i < pObject -> m_iFeatureCount; ++i, ++pFeat) {
			if (lThisCursor-1 == pFeat -> m_iFeatDesc) {
			// das Objekt besitzt dieses Attribut
				bstrVal = pFeat -> m_pcoleFeature;
				fFound = true;
				break;
			}
		}
		if (!fFound)	// das Objekt besitzt diese Objekteigenschaft nicht
			return TRIASDB_E_NOSUCHFEATURE;
	// END_SAMPLE_CODE
$$ELSE
//	CComBSTR bstrVal;
//
//		THROW_FAILED_HRESULT(GetAttributeValue (pIObj, CLEARED(&bstrVal)));
$$ENDIF

	CComVariant var (bstrVal);

		THROW_FAILED_HRESULT(var.Detach (pVal));

	} COM_CATCH;
	return S_OK;
}

STDMETHODIMP C$$safe_root$$Feature::EvalEx(ITRiASObject *pIObj, SAFEARRAY **ppConstraints, VARIANT *pVal)
{
	return Eval (pIObj, pVal);		// ignore constraints	
}

// Wert der Objekteigenschaft modifizieren
STDMETHODIMP C$$safe_root$$Feature::Update(ITRiASObject *pIObj, VARIANT Val)
{
$$IF(READ_WRITE)
#pragma TODO("Neuen Wert der Objekteigenschaft in Datenquelle speichern.")
	return S_OK;
$$ELSE
	return TRIASDB_E_FEATURENOTUPDATABLE;
$$ENDIF
}

// Kopie der Objekteigenschaft erzeugen
STDMETHODIMP C$$safe_root$$Feature::Clone (ITRiASFeature **ppIFeat)
{
	return E_NOTIMPL;
}

// Objekt wird logisch freigegeben
STDMETHODIMP C$$safe_root$$Feature::OnFinalRelease()
{
$$IF(EMIT_SAMPLE_CODE)
$$IF(READ_WRITE)
// BEGIN_SAMPLE_CODE
	COM_TRY {
	// unsere Nummer (Cursor) freigeben und damit dieses Objekt aus der Handlemap herauslöschen
		THROW_FAILED_HRESULT(DelPropertyBy (WDispatch(m_BaseUnk), g_cbFeatureCursor));
	} COM_CATCH;
// END_SAMPLE_CODE
$$ENDIF // $$IF(READ_WRITE)
$$ENDIF // $$IF(EMIT_SAMPLE_CODE)
	return S_OK;
}

$$IF(SEARCHOBJECTS_FEATURE)
///////////////////////////////////////////////////////////////////////////////
// ITRiASSearchObjects

// Testen, ob Recherche hier ausgeführt werden kann
STDMETHODIMP C$$safe_root$$Feature::ConsiderSearch (BSTR bstrCommand, SAFEARRAY *pParams)
{
	// TRIASDB_S_SEARCH_NOT_RECOMMENDED:	// nicht zu empfehlen
	// TRIASDB_S_SEARCH_NOT_SUPPORTED:		// not implemented here
	// S_OK:	// Recherche kann hier ausgeführt werden
	return S_OK;
}

// eigentliche Recherche
STDMETHODIMP C$$safe_root$$Feature::SearchObjects (BSTR bstrCommand, ITRiASObjects *pIObjs, SAFEARRAY *pParams)
{
	if (FAILED(ConsiderSearch(bstrCommand, pParams)))
		return TRIASDB_S_SEARCH_NOT_SUPPORTED;		// not supported search

#pragma TODO("Sämtliche Objekte entsprechend Recherchekriterium suchen (und finden).")

//WTRiASObject Obj;
//
//	for ( ... sämtliche gefundenen Objekte ...) {
//
//		RETURN_FAILED_HRESULT(pIObjs -> _Add (Obj, VARIANT_FALSE));
//	}

	// S_OK:	Objekte gefunden
	// TRIASDB_I_NO_OBJECTS_FOUND:	keine Objekte gefunden
	// ansonsten Fehlercode
	return TRIASDB_I_NO_OBJECTS_FOUND;
}

// Begrenzen der Ausgabeobjektmenge (hier nicht benötigt)
STDMETHODIMP C$$safe_root$$Feature::ConstraintObjects (ITRiASObjects *pObjs)
{
	_ASSERTE(SUCCEEDED(E_NOTIMPL));		// never called in this context
	return E_NOTIMPL;
}
$$ENDIF 

