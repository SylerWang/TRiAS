// $Header: $
// Copyright© 1998-$$year$$ $$company$$, All rights reserved
// Created: $$date_n_time$$ 
//
// This file was generated by the TRiASDB Data Server Wizard $$this_version$$
//
$$IF(EMIT_WARRANTIES)
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY 
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR 
// PURPOSE.
//
$$ENDIF // EMIT_WARRANTIES
// @doc
// @module $$root$$CursorProperty.cpp | Implementation of the <c C$$safe_root$$ObjectCursorProperty> class

#include "stdafx.h"

#include "Strings.h"

#include "$$root$$.h"
#include "$$root$$CursorProperty.h"

#if defined(_DEBUG)
#if defined(_MFC_VER)
#define new DEBUG_NEW
#endif // defined(_MFC_VER)
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// Die vorliegende Klasse implementiert eine spezielle Property 'ObjectCursor'
// eines Objektes (C$$safe_root$$Object), die dafür sorgt, daß in dem Moment, 
// wenn ein Objektcursor für ein Objekt definiert bzw. freigegeben wird, dieses
// Objekt mit seinem Cursor in einer speziellen Tabelle gespeichert bzw. 
// freigegeben wird. 
// Diese Zuordnungstabelle wird für die Recherchen benötigt, um den gefundenen
// Objekten in der Datenbank (Cursor) die zugeordneten C++ Objekte 
// (C$$safe_root$$Object) zuordnen zu können.
// Diese Tabelle ist im vorliegenden Beispiel als Property ('ObjectCursorMap')
// an der Datenbank (C$$safe_root$$Database) abgelegt. 
// Für andere Datenquellen ist es u.U. notwendig die einzelnen Objekte in Bezug 
// zu ihrer Objektklasse zu speichern, dann sollte die Zuordnungstabelle 
// von Cursor zu Objekt auch an der zugehörigen Objektklasse abgelegt werden.)
// 
// Die Verwendung einer GenObjectMap (s. $$root$$Database.h: BEGIN_PROPERTYSUPPORT_MAP)
// beschränkt den CursorTyp auf VT_I4.

/////////////////////////////////////////////////////////////////////////////
// C$$safe_root$$ObjectCursorProperty

void C$$safe_root$$ObjectCursorProperty::FinalRelease()
{
	ResetCursor();		// Cursor wieder freigeben
}

/////////////////////////////////////////////////////////////////////////////
// PropertySupport
// Callback-interface, welches für die Konkretheit der Properties zuständig ist

STDMETHODIMP C$$safe_root$$ObjectCursorProperty::PutValue (BSTR Name, VARIANT Value)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	_ASSERTE(NULL != Name);
	_ASSERTE(!wcscmp (Name, g_cbObjectCursor));	// muß "ObjectCursor" sein

	RETURN_FAILED_HRESULT(m_Value.Copy(&Value));	// Wert setzen
	RETURN_FAILED_HRESULT(SetCursor());				// Zuordnung in Map setzen bzw. entfernen
	return S_OK;
}

STDMETHODIMP C$$safe_root$$ObjectCursorProperty::GetValue (BSTR Name, VARIANT *pVal)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	_ASSERTE(NULL != Name || NULL != pVal);
	_ASSERTE(!wcscmp (Name, g_cbObjectCursor));	// muß "ObjectCursor" sein
	if (NULL == pVal) return E_POINTER;

CComVariant val (m_Value);

	RETURN_FAILED_HRESULT(val.Detach (pVal));
	return S_OK;
}

STDMETHODIMP C$$safe_root$$ObjectCursorProperty::PutType (BSTR Name, PROPERTY_TYPE newVla)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	_ASSERTE(NULL != Name);
	_ASSERTE(!wcscmp (Name, g_cbObjectCursor));	// muß "ObjectCursor" sein

	return E_NOTIMPL;
}

STDMETHODIMP C$$safe_root$$ObjectCursorProperty::GetType (BSTR Name, PROPERTY_TYPE *pVal)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	_ASSERTE(NULL != Name || NULL != pVal);
	_ASSERTE(!wcscmp (Name, g_cbObjectCursor));	// muß "ObjectCursor" sein

	if (NULL == pVal) return E_POINTER;

	*pVal = PROPERTY_TYPE(PROPERTY_TYPE_Dynamic);
	return S_OK;
}

STDMETHODIMP C$$safe_root$$ObjectCursorProperty::PutValueAndType(BSTR Name, VARIANT Value, PROPERTY_TYPE Type)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	_ASSERTE(NULL != Name);
	_ASSERTE(!wcscmp (Name, g_cbObjectCursor));	// muß "ObjectCursor" sein

// Wert setzen
	RETURN_FAILED_HRESULT(m_Value.Copy(&Value));
	return S_OK;		// Typ wird nicht bearbeitet
}

STDMETHODIMP C$$safe_root$$ObjectCursorProperty::GetValueAndType(BSTR Name, VARIANT * pVal, PROPERTY_TYPE * pType)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	_ASSERTE(NULL != Name || NULL != pVal || NULL != pType);
	_ASSERTE(!wcscmp (Name, g_cbObjectCursor));	// muß "ObjectCursor" sein
	if (NULL != pVal) return E_POINTER;
	if (NULL != pType) return E_POINTER;

CComVariant val (m_Value);

	RETURN_FAILED_HRESULT(val.Detach (pVal));
	*pType = PROPERTY_TYPE(PROPERTY_TYPE_Dynamic);
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// IObjectWithSite
STDMETHODIMP C$$safe_root$$ObjectCursorProperty::SetSite (IUnknown *pISite)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	if (NULL != pISite)
		return pISite -> QueryInterface(IID_ITRiASObject, m_Obj.ppv());
	else {
		ResetCursor();
		m_Obj.Assign(NULL);
		return S_OK;
	}
}

STDMETHODIMP C$$safe_root$$ObjectCursorProperty::GetSite (REFIID riid, void **ppvSite)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	if (!m_Obj) 
		return TRIASDB_E_PROPERTY_NOT_INITIALIZED;
	return m_Obj -> QueryInterface (riid, ppvSite);
}

STDMETHODIMP C$$safe_root$$ObjectCursorProperty::Refresh(BSTR bstrName)
{
#if defined(_MFC_VER)
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
#endif // defined(_MFC_VER)

	return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////////
// Helper
HRESULT C$$safe_root$$ObjectCursorProperty::GetObjectCursorMap (ITRiASObjectHandleMap **ppIMap)
{
	if (!m_Obj.IsValid())
		return TRIASDB_E_PROPERTY_NOT_INITIALIZED;

	COM_TRY {
	WTRiASDatabase Parent;

		THROW_FAILED_HRESULT(FindSpecificParent (m_Obj, Parent.ppi()));

	WTRiASObjectHandleMap Map (GetPropertyFrom (Parent, g_cbObjectMap, (IDispatch *)NULL), false);	// GetProperty liefert AddRef'ed ab

		if (!Map.IsValid())
			THROW_FAILED_HRESULT(E_UNEXPECTED);

		*ppIMap = Map.detach();

	} COM_CATCH;
	return S_OK;
}

HRESULT C$$safe_root$$ObjectCursorProperty::SetCursor()
{
	COM_TRY {
	WTRiASObjectHandleMap Map;
	CComVariant vVal;
	HRESULT hr = S_OK;

		THROW_FAILED_HRESULT(GetObjectCursorMap (Map.ppi()));
		THROW_FAILED_HRESULT(vVal.ChangeType (VT_I4, &m_Value));
		Map -> RemoveObject (V_I4(&vVal), OBJECTMAPMODE_RemoveAllReferences);

	OBJECTMAPMODE rgMode = OBJECTMAPMODE(OBJECTMAPMODE_CreateObjectHandle|OBJECTMAPMODE_DoNotRegisterNativeHandle);

		THROW_FAILED_HRESULT(hr = Map -> GetObjectHandle (vtMissing, m_Obj, rgMode, (INT_PTR *)&V_I4(&vVal)));
		_ASSERTE(S_OK == hr);		// Handle darf sich nicht geändert haben

	} COM_CATCH;
	return S_OK;
}

HRESULT C$$safe_root$$ObjectCursorProperty::ResetCursor()
{
	if (!m_Obj)
		return S_FALSE;		// nicht das erste mal

	COM_TRY {
	WTRiASObjectHandleMap Map;
	CComVariant vVal;

		THROW_FAILED_HRESULT(GetObjectCursorMap (Map.ppi()));
		THROW_FAILED_HRESULT(vVal.ChangeType (VT_I4, &m_Value));
		THROW_FAILED_HRESULT(Map -> RemoveObject (V_I4(&vVal), OBJECTMAPMODE_RemoveAllReferences));

	} COM_CATCH;
	return S_OK;
}
